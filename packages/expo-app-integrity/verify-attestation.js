#!/usr/bin/env node

const { Certificate } = require('pkijs');
const { fromBER } = require('asn1js');

/**
 * Android Hardware Attestation Certificate Verifier
 *
 * This script verifies Android hardware attestation certificates generated by
 * the generateHardwareAttestedKey and getAttestationCertificateChain functions
 * in the IntegrityModule.kt file.
 *
 * Usage:
 * node verify-attestation.js <base64-certificate-chain> [challenge]
 *
 * Where:
 * - base64-certificate-chain: Array of base64-encoded certificates (JSON format)
 * - challenge: Optional challenge string used during key generation
 */

class AttestationVerifier {
  constructor() {
    this.GOOGLE_ROOT_CERTIFICATES = [
      // Google Hardware Attestation Root Certificate
      'MIICeDCCAh2gAwIBAgIJAMCf9LMunP9aMAoGCCqGSM49BAMCMIGMMQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmlldzEQMA4GA1UECgwHQW5kcm9pZDEQMA4GA1UECwwHQW5kcm9pZDEsMCoGA1UEAwwjQW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbjAeFw0xNjAxMTEwMDE1NTNaFw0yNjAxMDgwMDE1NTNaMIGMMQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmlldzEQMA4GA1UECgwHQW5kcm9pZDEQMA4GA1UECwwHQW5kcm9pZDEsMCoGA1UEAwwjQW5kcm9pZCBLZXlzdG9yZSBTb2Z0d2FyZSBBdHRlc3RhdGlvbjBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABNe7GGMZr1w8zTwdQAazGgftKJ1zYjt8OXPSj3TYjFLUhNIWJVzb6M7M8z8w/tA8qO3kEjPYTLNsJo3bFWzlVOsHU6swKQYJKoZIhvdMBQgBQx0cAzAgAB',
    ];
  }

  /**
   * Parses a base64-encoded certificate and returns a Certificate object
   */
  parseCertificate(base64Cert) {
    try {
      const certBuffer = Buffer.from(base64Cert, 'base64');
      const asn1 = fromBER(certBuffer);

      if (asn1.offset === -1) {
        throw new Error('Failed to parse ASN.1 data');
      }

      return new Certificate({ schema: asn1.result });
    } catch (error) {
      throw new Error(`Failed to parse certificate: ${error.message}`);
    }
  }

  extractAttestationExtension(certificate) {
    const ATTESTATION_EXTENSION_OID = '1.3.6.1.4.1.11129.2.1.17';

    if (!certificate.extensions) {
      throw new Error('Certificate has no extensions');
    }

    const attestationExt = certificate.extensions.find(
      (ext) => ext.extnID === ATTESTATION_EXTENSION_OID
    );

    if (!attestationExt) {
      throw new Error('Certificate does not contain Android Keystore Attestation Extension');
    }

    return attestationExt;
  }

  /**
   * Parses the attestation extension and extracts key information
   */
  parseAttestationExtension(attestationExt) {
    try {
      const asn1 = fromBER(attestationExt.extnValue.valueBlock.valueHex);

      if (asn1.offset === -1) {
        throw new Error('Failed to parse attestation extension ASN.1');
      }

      // Parse the Android Keystore Attestation Extension
      const parsedData = this.parseAttestationRecord(asn1.result);

      return {
        parsed: true,
        rawData: asn1.result,
        attestationSecurityLevel: parsedData.attestationSecurityLevel,
        keymasterSecurityLevel: parsedData.keymasterSecurityLevel,
        attestationChallenge: parsedData.attestationChallenge,
        softwareEnforced: parsedData.softwareEnforced,
        teeEnforced: parsedData.teeEnforced,
      };
    } catch (error) {
      throw new Error(`Failed to parse attestation extension: ${error.message}`);
    }
  }

  /**
   * Parses the Android Attestation Record structure
   */
  parseAttestationRecord(asn1Data) {
    try {
      // The attestation record is a SEQUENCE containing:
      // attestationVersion INTEGER
      // attestationSecurityLevel SecurityLevel
      // keymasterVersion INTEGER
      // keymasterSecurityLevel SecurityLevel
      // attestationChallenge OCTET_STRING
      // uniqueId OCTET_STRING
      // softwareEnforced AuthorizationList
      // teeEnforced AuthorizationList

      if (asn1Data.constructor.name !== 'Sequence') {
        throw new Error('Expected SEQUENCE at top level');
      }

      const values = asn1Data.valueBlock.value;

      const result = {
        attestationVersion: values[0] ? this.getIntegerValue(values[0]) : null,
        attestationSecurityLevel: values[1] ? this.parseSecurityLevel(values[1]) : null,
        keymasterVersion: values[2] ? this.getIntegerValue(values[2]) : null,
        keymasterSecurityLevel: values[3] ? this.parseSecurityLevel(values[3]) : null,
        attestationChallenge: values[4] ? this.getOctetStringValue(values[4]) : null,
        uniqueId: values[5] ? this.getOctetStringValue(values[5]) : null,
        softwareEnforced: values[6] ? this.parseAuthorizationList(values[6]) : {},
        teeEnforced: values[7] ? this.parseAuthorizationList(values[7]) : {},
      };

      // Debug: log the raw values to understand structure
      // console.log('\\nDEBUG: Attestation record structure:');
      // values.forEach((value, index) => {
      //   console.log(`  [${index}] ${value.constructor.name}: ${this.debugValue(value)}`);
      // });

      return result;
    } catch (error) {
      throw new Error(`Failed to parse attestation record: ${error.message}`);
    }
  }

  /**
   * Parses security level enumeration
   */
  parseSecurityLevel(asn1Value) {
    let level = null;

    if (asn1Value.constructor.name === 'Enumerated') {
      level = asn1Value.valueBlock.valueDec;
    } else if (asn1Value.constructor.name === 'Integer') {
      level = asn1Value.valueBlock.valueDec;
    }

    switch (level) {
      case 0:
        return 'Software';
      case 1:
        return 'TrustedEnvironment'; // TEE
      case 2:
        return 'StrongBox';
      default:
        return `Unknown(${level})`;
    }
  }

  /**
   * Parses Authorization List (software/TEE enforced authorizations)
   */
  parseAuthorizationList(asn1Value) {
    try {
      if (asn1Value.constructor.name !== 'Sequence') {
        return {};
      }

      const authorizations = {};
      const values = asn1Value.valueBlock.value;

      // Debug: show what tags we're finding
      // console.log(`\\nDEBUG: Authorization list has ${values.length} items:`);
      // values.forEach((item, index) => {
      //   if (item.constructor.name === 'Constructed' && item.idBlock.tagClass === 3) {
      //     console.log(`  [${index}] Tag ${item.idBlock.tagNumber}: ${this.debugValue(item)}`);
      //   } else {
      //     console.log(`  [${index}] ${item.constructor.name}: ${this.debugValue(item)}`);
      //   }
      // });

      for (const item of values) {
        if (item.constructor.name === 'Constructed' && item.idBlock.tagClass === 3) {
          // Context-specific tag
          const tag = item.idBlock.tagNumber;

          switch (tag) {
            case 600: // KM_TAG_ATTESTATION_APPLICATION_ID
              authorizations.attestationApplicationId = this.parseAttestationApplicationId(item);
              break;
            case 601: // KM_TAG_ATTESTATION_ID_BRAND
              authorizations.attestationIdBrand = this.getOctetStringFromConstructed(item);
              break;
            case 602: // KM_TAG_ATTESTATION_ID_DEVICE
              authorizations.attestationIdDevice = this.getOctetStringFromConstructed(item);
              break;
            case 603: // KM_TAG_ATTESTATION_ID_PRODUCT
              authorizations.attestationIdProduct = this.getOctetStringFromConstructed(item);
              break;
            case 604: // KM_TAG_ATTESTATION_ID_SERIAL
              authorizations.attestationIdSerial = this.getOctetStringFromConstructed(item);
              break;
            case 605: // KM_TAG_ATTESTATION_ID_IMEI
              authorizations.attestationIdImei = this.getOctetStringFromConstructed(item);
              break;
            case 606: // KM_TAG_ATTESTATION_ID_MEID
              authorizations.attestationIdMeid = this.getOctetStringFromConstructed(item);
              break;
            case 607: // KM_TAG_ATTESTATION_ID_MANUFACTURER
              authorizations.attestationIdManufacturer = this.getOctetStringFromConstructed(item);
              break;
            case 608: // KM_TAG_ATTESTATION_ID_MODEL
              authorizations.attestationIdModel = this.getOctetStringFromConstructed(item);
              break;
            // Additional Android Keymaster tags found in your certificate
            case 1: // KM_TAG_PURPOSE
              authorizations.purpose = this.getIntegerFromConstructed(item);
              break;
            case 2: // KM_TAG_ALGORITHM
              authorizations.algorithm = this.getIntegerFromConstructed(item);
              break;
            case 3: // KM_TAG_KEY_SIZE
              authorizations.keySize = this.getIntegerFromConstructed(item);
              break;
            case 5: // KM_TAG_DIGEST
              authorizations.digest = this.getIntegerFromConstructed(item);
              break;
            case 10: // KM_TAG_EC_CURVE
              authorizations.ecCurve = this.getIntegerFromConstructed(item);
              break;
            case 503: // KM_TAG_CREATION_DATETIME
              authorizations.creationDateTime = this.getIntegerFromConstructed(item);
              break;
            case 701: // KM_TAG_OS_VERSION
              authorizations.osVersion = this.getIntegerFromConstructed(item);
              break;
            case 702: // KM_TAG_OS_PATCHLEVEL
              authorizations.osPatchLevel = this.getIntegerFromConstructed(item);
              break;
            case 704: // KM_TAG_ATTESTATION_ID_BRAND
              authorizations.attestationIdBrand2 = this.getOctetStringFromConstructed(item);
              break;
            case 705: // KM_TAG_ATTESTATION_ID_DEVICE
              authorizations.attestationIdDevice2 = this.getOctetStringFromConstructed(item);
              break;
            case 706: // KM_TAG_ATTESTATION_ID_PRODUCT
              authorizations.attestationIdProduct2 = this.getOctetStringFromConstructed(item);
              break;
            case 709: // KM_TAG_BOOT_PATCHLEVEL
              authorizations.bootPatchLevel = this.getIntegerFromConstructed(item);
              break;
            case 718: // KM_TAG_ATTESTATION_ID_MANUFACTURER
              authorizations.attestationIdManufacturer2 = this.getOctetStringFromConstructed(item);
              break;
            case 719: // KM_TAG_ATTESTATION_ID_MODEL
              authorizations.attestationIdModel2 = this.getOctetStringFromConstructed(item);
              break;
            case 724: // KM_TAG_VENDOR_PATCHLEVEL
              authorizations.vendorPatchLevel = this.getIntegerFromConstructed(item);
              break;
            default:
              // Store unknown tags for debugging
              authorizations[`unknownTag${tag}`] = this.debugValue(item);
              break;
          }
        }
      }

      return authorizations;
    } catch (error) {
      return { parseError: error.message };
    }
  }

  /**
   * Parses Attestation Application ID which contains package info
   */
  parseAttestationApplicationId(constructed) {
    try {
      const octetString = constructed.valueBlock.value[0];
      if (octetString && octetString.constructor.name === 'OctetString') {
        const appIdBytes = new Uint8Array(octetString.valueBlock.valueHex);

        // Parse the nested ASN.1 structure
        const appIdAsn1 = fromBER(appIdBytes.buffer);
        if (appIdAsn1.offset !== -1) {
          return this.parseApplicationId(appIdAsn1.result);
        }
      }
      return null;
    } catch (error) {
      return { parseError: error.message };
    }
  }

  /**
   * Parses Application ID structure to extract package names and signatures
   */
  parseApplicationId(asn1Data) {
    try {
      if (asn1Data.constructor.name !== 'Sequence') {
        return null;
      }

      const values = asn1Data.valueBlock.value;
      const result = {
        packageInfos: [],
        signatureDigests: [],
      };

      // First element should be package infos SET
      if (values[0] && values[0].constructor.name === 'Set') {
        for (const packageInfo of values[0].valueBlock.value) {
          if (packageInfo.constructor.name === 'Sequence') {
            const pkgValues = packageInfo.valueBlock.value;
            if (pkgValues.length >= 2) {
              result.packageInfos.push({
                packageName: this.getOctetStringValue(pkgValues[0]),
                version: this.getIntegerValue(pkgValues[1]),
              });
            }
          }
        }
      }

      // Second element should be signature digests SET
      if (values[1] && values[1].constructor.name === 'Set') {
        for (const digest of values[1].valueBlock.value) {
          if (digest.constructor.name === 'OctetString') {
            result.signatureDigests.push(Buffer.from(digest.valueBlock.valueHex).toString('hex'));
          }
        }
      }

      return result;
    } catch (error) {
      return { parseError: error.message };
    }
  }

  /**
   * Helper methods for ASN.1 parsing
   */
  getIntegerValue(asn1Value) {
    if (asn1Value.constructor.name === 'Integer') {
      return asn1Value.valueBlock.valueDec;
    }
    return null;
  }

  getOctetStringValue(asn1Value) {
    if (asn1Value.constructor.name === 'OctetString') {
      return Buffer.from(asn1Value.valueBlock.valueHex).toString('utf8');
    }
    return null;
  }

  getOctetStringFromConstructed(constructed) {
    if (constructed.valueBlock && constructed.valueBlock.value && constructed.valueBlock.value[0]) {
      return this.getOctetStringValue(constructed.valueBlock.value[0]);
    }
    return null;
  }

  getIntegerFromConstructed(constructed) {
    if (constructed.valueBlock && constructed.valueBlock.value && constructed.valueBlock.value[0]) {
      return this.getIntegerValue(constructed.valueBlock.value[0]);
    }
    return null;
  }

  /**
   * Debug helper to show ASN.1 value contents
   */
  debugValue(asn1Value) {
    try {
      if (asn1Value.constructor.name === 'Integer') {
        return asn1Value.valueBlock.valueDec;
      } else if (asn1Value.constructor.name === 'OctetString') {
        const str = Buffer.from(asn1Value.valueBlock.valueHex).toString('utf8');
        return `"${str}" (${asn1Value.valueBlock.valueHex.byteLength} bytes)`;
      } else if (asn1Value.constructor.name === 'Sequence') {
        return `Sequence with ${asn1Value.valueBlock.value.length} items`;
      } else if (asn1Value.constructor.name === 'Constructed') {
        return `Constructed[tag=${asn1Value.idBlock.tagNumber}] with ${asn1Value.valueBlock.value ? asn1Value.valueBlock.value.length : 0} items`;
      }
      return `${asn1Value.constructor.name}`;
    } catch (e) {
      return `${asn1Value.constructor.name} (parse error)`;
    }
  }

  /**
   * Verifies the certificate chain integrity
   */
  verifyCertificateChain(certificates) {
    if (certificates.length < 2) {
      throw new Error('Certificate chain must contain at least 2 certificates');
    }

    console.log(`Verifying certificate chain with ${certificates.length} certificates`);

    // The first certificate should be the leaf (attested key certificate)
    // Subsequent certificates form the chain up to the root

    const leafCert = certificates[0];
    const intermediateCerts = certificates.slice(1, -1);
    const rootCert = certificates[certificates.length - 1];

    console.log('✓ Certificate chain structure is valid');

    return {
      leaf: leafCert,
      intermediates: intermediateCerts,
      root: rootCert,
    };
  }

  /**
   * Validates that the certificate was generated with hardware-backed security
   */
  validateHardwareAttestation(certificate, expectedChallenge = null) {
    console.log('Validating hardware attestation...');

    try {
      const attestationExt = this.extractAttestationExtension(certificate);
      const attestationData = this.parseAttestationExtension(attestationExt);

      console.log('✓ Attestation extension found and parsed');

      // Additional validation would require parsing the specific ASN.1 structure
      // to verify security level, challenge, and other attestation parameters

      if (expectedChallenge) {
        console.log(`Expected challenge: ${expectedChallenge}`);
        if (attestationData.attestationChallenge) {
          const challengeMatch = attestationData.attestationChallenge === expectedChallenge;
          console.log(`Challenge verification: ${challengeMatch ? '✓ MATCH' : '✗ MISMATCH'}`);
          if (!challengeMatch) {
            console.log(`  Expected: ${expectedChallenge}`);
            console.log(`  Actual: ${attestationData.attestationChallenge}`);
          }
        }
      }

      // Display security level information
      if (attestationData.attestationSecurityLevel) {
        console.log(`✓ Attestation Security Level: ${attestationData.attestationSecurityLevel}`);
      }
      if (attestationData.keymasterSecurityLevel) {
        console.log(`✓ Keymaster Security Level: ${attestationData.keymasterSecurityLevel}`);
      }

      // Display TEE enforced information
      if (attestationData.teeEnforced && Object.keys(attestationData.teeEnforced).length > 0) {
        console.log('✓ TEE Enforced Authorizations:');
        Object.entries(attestationData.teeEnforced).forEach(([key, value]) => {
          console.log(`  ${key}: ${JSON.stringify(value)}`);
        });
      }

      // Display Software enforced information
      if (
        attestationData.softwareEnforced &&
        Object.keys(attestationData.softwareEnforced).length > 0
      ) {
        console.log('✓ Software Enforced Authorizations:');
        Object.entries(attestationData.softwareEnforced).forEach(([key, value]) => {
          if (key === 'attestationApplicationId' && value && value.packageInfos) {
            console.log(`  Package Information:`);
            value.packageInfos.forEach((pkg, idx) => {
              console.log(`    ${idx + 1}. Package: ${pkg.packageName}, Version: ${pkg.version}`);
            });
            if (value.signatureDigests && value.signatureDigests.length > 0) {
              console.log(`  Signature Digests:`);
              value.signatureDigests.forEach((digest, idx) => {
                console.log(`    ${idx + 1}. ${digest}`);
              });
            }
          } else {
            console.log(`  ${key}: ${JSON.stringify(value)}`);
          }
        });
      }

      return {
        valid: true,
        attestationData,
      };
    } catch (error) {
      console.error(`✗ Hardware attestation validation failed: ${error.message}`);
      return {
        valid: false,
        error: error.message,
      };
    }
  }

  /**
   * Verifies the entire attestation certificate chain
   */
  async verifyAttestation(base64Certificates, expectedChallenge = null) {
    try {
      console.log('Starting Android hardware attestation verification...\n');

      // Parse all certificates
      const certificates = base64Certificates.map((base64Cert, index) => {
        console.log(`Parsing certificate ${index + 1}...`);
        return this.parseCertificate(base64Cert);
      });

      // Verify chain structure
      const chain = this.verifyCertificateChain(certificates);

      // Validate hardware attestation on leaf certificate
      const attestationResult = this.validateHardwareAttestation(chain.leaf, expectedChallenge);

      // Display certificate information
      console.log('\n--- Certificate Chain Information ---');
      certificates.forEach((cert, index) => {
        console.log(`Certificate ${index + 1}:`);
        console.log(
          `  Subject: ${cert.subject.typesAndValues.map((tv) => `${tv.type}=${tv.value.valueBlock.value}`).join(', ')}`
        );
        console.log(
          `  Issuer: ${cert.issuer.typesAndValues.map((tv) => `${tv.type}=${tv.value.valueBlock.value}`).join(', ')}`
        );
        console.log(
          `  Serial: ${Buffer.from(cert.serialNumber.valueBlock.valueHex).toString('hex')}`
        );
        console.log(`  Valid From: ${cert.notBefore.value}`);
        console.log(`  Valid To: ${cert.notAfter.value}`);
        console.log('');
      });

      console.log('--- Verification Summary ---');
      console.log(`✓ Certificate chain parsed successfully`);
      console.log(`✓ Chain contains ${certificates.length} certificates`);
      console.log(
        `${attestationResult.valid ? '✓' : '✗'} Hardware attestation: ${attestationResult.valid ? 'VALID' : 'INVALID'}`
      );

      if (!attestationResult.valid) {
        console.log(`Error: ${attestationResult.error}`);
      }

      return {
        valid: attestationResult.valid,
        certificates: certificates.length,
        attestationData: attestationResult.attestationData,
      };
    } catch (error) {
      console.error(`✗ Verification failed: ${error.message}`);
      return {
        valid: false,
        error: error.message,
      };
    }
  }
}

async function main() {
  // const args = process.argv.slice(2);

  // if (args.length < 1) {
  //   console.error('Usage: node verify-attestation.js <certificate-chain-json> [challenge]');
  //   console.error('');
  //   console.error('Example:');
  //   console.error(
  //     '  node verify-attestation.js \'["base64cert1", "base64cert2", "base64cert3"]\' "my-challenge"'
  //   );
  //   process.exit(1);
  // }

  try {
    const certificateChain = [];
    const challenge = 'full_challenge';

    if (!Array.isArray(certificateChain)) {
      throw new Error('Certificate chain must be a JSON array of base64-encoded strings');
    }

    const verifier = new AttestationVerifier();
    const result = await verifier.verifyAttestation(certificateChain, challenge);

    process.exit(result.valid ? 0 : 1);
  } catch (error) {
    console.error(`Error: ${error.message}`);
    process.exit(1);
  }
}

// Export for use as a module
module.exports = { AttestationVerifier };

// Run as CLI if executed directly
if (require.main === module) {
  main();
}

var __BUNDLE_START_TIME__=globalThis.nativePerformanceNow?nativePerformanceNow():Date.now(),__DEV__=false,process=globalThis.process||{},__METRO_GLOBAL_PREFIX__='';process.env=process.env||{};process.env.NODE_ENV=process.env.NODE_ENV||"production";
(function (global) {
  'use strict';

  if (!global[`${__METRO_GLOBAL_PREFIX__}__d`]) {
    global.__r = metroRequire;
    global[`${__METRO_GLOBAL_PREFIX__}__d`] = define;
    global.__c = clear;
    global.__registerSegment = registerSegment;
  }
  var modules = clear();
  const EMPTY = {};
  const CYCLE_DETECTED = {};
  const {
    hasOwnProperty
  } = {};
  function clear() {
    modules = new Map();
    return modules;
  }
  function define(factory, moduleId, dependencyMap) {
    if (modules.has(moduleId)) {
      return;
    }
    const mod = {
      dependencyMap,
      factory,
      hasError: false,
      importedAll: EMPTY,
      importedDefault: EMPTY,
      isInitialized: false,
      publicModule: {
        exports: {}
      }
    };
    modules.set(moduleId, mod);
  }
  function metroRequire(moduleId, moduleIdHint) {
    if (moduleId === null) {
      throw new Error('Cannot find module');
    }
    const module = modules.get(moduleId);
    return module && module.isInitialized ? module.publicModule.exports : guardedLoadModule(moduleId, module, moduleIdHint);
  }
  function metroImportDefault(moduleId) {
    var _modules_get;
    if (modules.has(moduleId) && ((_modules_get = modules.get(moduleId)) == null ? undefined : _modules_get.importedDefault) !== EMPTY) {
      return modules.get(moduleId).importedDefault;
    }
    const exports = metroRequire(moduleId);
    const importedDefault = exports && exports.__esModule ? exports.default : exports;
    return modules.get(moduleId).importedDefault = importedDefault;
  }
  metroRequire.importDefault = metroImportDefault;
  function metroImportAll(moduleId) {
    var _modules_get;
    if (modules.has(moduleId) && ((_modules_get = modules.get(moduleId)) == null ? undefined : _modules_get.importedAll) !== EMPTY) {
      return modules.get(moduleId).importedAll;
    }
    const exports = metroRequire(moduleId);
    let importedAll;
    if (exports && exports.__esModule) {
      importedAll = exports;
    } else {
      importedAll = {};
      if (exports) {
        for (const key in exports) {
          if (hasOwnProperty.call(exports, key)) {
            importedAll[key] = exports[key];
          }
        }
      }
      importedAll.default = exports;
    }
    return modules.get(moduleId).importedAll = importedAll;
  }
  metroRequire[Symbol.for('expo.require')] = true;
  metroRequire.importAll = metroImportAll;
  metroRequire.context = function fallbackRequireContext() {
    throw new Error('The experimental Metro feature `require.context` is not enabled in your project.');
  };
  metroRequire.resolveWeak = function fallbackRequireResolveWeak() {
    throw new Error('require.resolveWeak cannot be called dynamically.');
  };
  metroRequire.unguarded = function requireUnguarded(moduleId, moduleIdHint) {
    const module = modules.get(moduleId);
    return module && module.isInitialized ? module.publicModule.exports : loadModuleImplementation(moduleId, module, moduleIdHint);
  };
  let inGuard = false;
  function guardedLoadModule(moduleId, module, moduleIdHint) {
    if (!inGuard && global.ErrorUtils) {
      inGuard = true;
      let returnValue;
      try {
        returnValue = loadModuleImplementation(moduleId, module, moduleIdHint);
      } catch (e) {
        global.ErrorUtils.reportFatalError(e);
      }
      inGuard = false;
      return returnValue;
    } else {
      return loadModuleImplementation(moduleId, module, moduleIdHint);
    }
  }
  const ID_MASK_SHIFT = 16;
  const LOCAL_ID_MASK = 65535;
  function unpackModuleId(moduleId) {
    if (typeof moduleId !== 'number') {
      throw new Error('Module ID must be a number in unpackModuleId.');
    }
    const segmentId = moduleId >>> ID_MASK_SHIFT;
    const localId = moduleId & LOCAL_ID_MASK;
    return {
      segmentId,
      localId
    };
  }
  metroRequire.unpackModuleId = unpackModuleId;
  function packModuleId(value) {
    return (value.segmentId << ID_MASK_SHIFT) + value.localId;
  }
  metroRequire.packModuleId = packModuleId;
  const moduleDefinersBySegmentID = [];
  const definingSegmentByModuleID = new Map();
  function registerSegment(segmentId, moduleDefiner, moduleIds) {
    moduleDefinersBySegmentID[segmentId] = moduleDefiner;
    if (moduleIds) {
      moduleIds.forEach(moduleId => {
        if (!modules.has(moduleId) && !definingSegmentByModuleID.has(moduleId)) {
          definingSegmentByModuleID.set(moduleId, segmentId);
        }
      });
    }
  }
  function loadModuleImplementation(moduleId, module, moduleIdHint) {
    if (!module && moduleDefinersBySegmentID.length > 0) {
      const segmentId = definingSegmentByModuleID.get(moduleId) ?? 0;
      const definer = moduleDefinersBySegmentID[segmentId];
      if (definer != null) {
        definer(moduleId);
        module = modules.get(moduleId);
        definingSegmentByModuleID.delete(moduleId);
      }
    }
    if (!module) {
      throw unknownModuleError(moduleId, moduleIdHint);
    }
    if (module.hasError) {
      throw module.error;
    }
    module.isInitialized = true;
    const {
      factory,
      dependencyMap
    } = module;
    try {
      const moduleObject = module.publicModule;
      moduleObject.id = moduleId;
      factory == null ? undefined : factory(global, metroRequire, metroImportDefault, metroImportAll, moduleObject, moduleObject.exports, dependencyMap);
      {
        module.factory = undefined;
        module.dependencyMap = undefined;
      }
      return moduleObject.exports;
    } catch (e) {
      module.hasError = true;
      module.error = e;
      module.isInitialized = false;
      module.publicModule.exports = undefined;
      throw e;
    } finally {}
  }
  function unknownModuleError(id, moduleIdHint) {
    let message = 'Requiring unknown module "' + (id ?? moduleIdHint ?? `[unknown optional import]`) + '".';
    return Error(message);
  }
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  global.$$require_external = typeof require !== "undefined" ? require : () => null;
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  let _inGuard = 0;
  let _globalHandler = global.RN$useAlwaysAvailableJSErrorHandling === true ? global.RN$handleException : (e, isFatal) => {
    throw e;
  };
  const ErrorUtils = {
    setGlobalHandler(fun) {
      _globalHandler = fun;
    },
    getGlobalHandler() {
      return _globalHandler;
    },
    reportError(error) {
      _globalHandler && _globalHandler(error, false);
    },
    reportFatalError(error) {
      _globalHandler && _globalHandler(error, true);
    },
    applyWithGuard(fun, context, args, unused_onError, unused_name) {
      try {
        _inGuard++;
        return fun.apply(context, args);
      } catch (e) {
        ErrorUtils.reportError(e);
      } finally {
        _inGuard--;
      }
      return null;
    },
    applyWithGuardIfNeeded(fun, context, args) {
      if (ErrorUtils.inGuard()) {
        return fun.apply(context, args);
      } else {
        ErrorUtils.applyWithGuard(fun, context, args);
      }
      return null;
    },
    inGuard() {
      return !!_inGuard;
    },
    guard(fun, name, context) {
      if (typeof fun !== 'function') {
        console.warn('A function must be passed to ErrorUtils.guard, got ', fun);
        return null;
      }
      const guardName = name ?? fun.name ?? '<generated guard>';
      function guarded(...args) {
        return ErrorUtils.applyWithGuard(fun, context ?? this, args, null, guardName);
      }
      return guarded;
    }
  };
  global.ErrorUtils = ErrorUtils;
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  var _expo = require(_dependencyMap[0]);
  var _App = require(_dependencyMap[1]);
  var App = _interopDefault(_App);
  // registerRootComponent calls AppRegistry.registerComponent('main', () => App);
  // It also ensures that whether you load the app in Expo Go or in a native build,
  // the environment is set up appropriately
  (0, _expo.registerRootComponent)(App.default);
},0,[1,314]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "disableErrorHandling", {
    enumerable: true,
    get: function () {
      return _errorsExpoErrorManager.disableErrorHandling;
    }
  });
  Object.defineProperty(exports, "registerRootComponent", {
    enumerable: true,
    get: function () {
      return _launchRegisterRootComponent2.default;
    }
  });
  Object.defineProperty(exports, "isRunningInExpoGo", {
    enumerable: true,
    get: function () {
      return _environmentExpoGo.isRunningInExpoGo;
    }
  });
  Object.defineProperty(exports, "getExpoGoProjectConfig", {
    enumerable: true,
    get: function () {
      return _environmentExpoGo.getExpoGoProjectConfig;
    }
  });
  Object.defineProperty(exports, "EventEmitter", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.EventEmitter;
    }
  });
  Object.defineProperty(exports, "SharedObject", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.SharedObject;
    }
  });
  Object.defineProperty(exports, "SharedRef", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.SharedRef;
    }
  });
  Object.defineProperty(exports, "NativeModule", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.NativeModule;
    }
  });
  Object.defineProperty(exports, "requireNativeModule", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.requireNativeModule;
    }
  });
  Object.defineProperty(exports, "requireOptionalNativeModule", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.requireOptionalNativeModule;
    }
  });
  Object.defineProperty(exports, "requireNativeView", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.requireNativeViewManager;
    }
  });
  Object.defineProperty(exports, "registerWebModule", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.registerWebModule;
    }
  });
  Object.defineProperty(exports, "reloadAppAsync", {
    enumerable: true,
    get: function () {
      return _expoModulesCore.reloadAppAsync;
    }
  });
  Object.defineProperty(exports, "useEvent", {
    enumerable: true,
    get: function () {
      return _hooksUseEvent.useEvent;
    }
  });
  Object.defineProperty(exports, "useEventListener", {
    enumerable: true,
    get: function () {
      return _hooksUseEvent.useEventListener;
    }
  });
  require(_dependencyMap[0]);
  var _errorsExpoErrorManager = require(_dependencyMap[1]);
  var _launchRegisterRootComponent = require(_dependencyMap[2]);
  var _launchRegisterRootComponent2 = _interopDefault(_launchRegisterRootComponent);
  var _environmentExpoGo = require(_dependencyMap[3]);
  var _expoModulesCore = require(_dependencyMap[4]);
  var _hooksUseEvent = require(_dependencyMap[5]);
},1,[2,17,18,97,98,313]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  require(_dependencyMap[0]);
  require(_dependencyMap[1]);
  require(_dependencyMap[2]);

  // When users dangerously import a file inside of react-native, it breaks the web alias.
  // This is one of the most common, and cryptic web errors that users encounter.
  // This conditional side-effect provides a more helpful error message for debugging.
  // Use a wrapper `__DEV__` to remove this entire block in production.
},2,[3,8,16]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  require(_dependencyMap[0]);
},3,[4]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  require(_dependencyMap[0]);
  Object.defineProperty(globalThis, '__ExpoImportMetaRegistry', {
    value: require(_dependencyMap[1]).ImportMetaRegistry,
    enumerable: false,
    writable: true
  });
},4,[5,6]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {},5,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "ImportMetaRegistry", {
    enumerable: true,
    get: function () {
      return ImportMetaRegistry;
    }
  });
  var _utilsGetBundleUrl = require(_dependencyMap[0]);
  // Copyright 2015-present 650 Industries. All rights reserved.

  /**
   * Registry to handle import.meta functionality for React Native environment
   * Similar to how it works in the web, but adapted for the RN context
   * https://github.com/wintercg/import-meta-registry
   */
  const ImportMetaRegistry = {
    get url() {
      return (0, _utilsGetBundleUrl.getBundleUrl)();
    }
  };
},6,[7]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.getBundleUrl = getBundleUrl;
  // Copyright 2015-present 650 Industries. All rights reserved.

  function getBundleUrl() {
    let scriptURL = null;
    if (typeof window === 'undefined') {
      // For server runtime, we use the filename of the current script
      // @ts-ignore The react-native tsconfig doesn't support CJS
      scriptURL = 'file://' + __filename;
    } else {
      // TODO: Try to support `import.meta.url` when the ecosystem supports ESM,
      // and jest doesn't throw SyntaxError when accessing `import.meta`.
      scriptURL = document.currentScript?.src;
    }
    if (scriptURL == null) {
      return null;
    }
    const url = new URL(scriptURL);
    return `${url.protocol}//${url.host}${url.pathname}`;
  }
},7,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _buildAsyncRequire = require(_dependencyMap[0]);
  /**
   * Copyright © 2024 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  // @ts-ignore: ignore the global which may not always be defined in jest environments.
  global[`${global.__METRO_GLOBAL_PREFIX__ ?? ''}__loadBundleAsync`] = (0, _buildAsyncRequire.buildAsyncRequire)();
},8,[9]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.buildAsyncRequire = buildAsyncRequire;
  var _loadBundle = require(_dependencyMap[0]);
  /**
   * Copyright © 2022 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * Must satisfy the requirements of the Metro bundler.
   * https://github.com/react-native-community/discussions-and-proposals/blob/main/proposals/0605-lazy-bundling.md#__loadbundleasync-in-metro
   */

  /** Create an `loadBundleAsync` function in the expected shape for Metro bundler. */
  function buildAsyncRequire() {
    const cache = new Map();
    return async function universal_loadBundleAsync(path) {
      if (cache.has(path)) {
        return cache.get(path);
      }
      const promise = (0, _loadBundle.loadBundleAsync)(path).catch(error => {
        cache.delete(path);
        throw error;
      });
      cache.set(path, promise);
      return promise;
    };
  }
},9,[10]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.loadBundleAsync = loadBundleAsync;
  var _buildUrlForBundle = require(_dependencyMap[0]);
  var _fetchThenEval = require(_dependencyMap[1]);
  /**
   * Copyright © 2022 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * Load a bundle for a URL using fetch + eval on native and script tag injection on web.
   *
   * @param bundlePath Given a statement like `import('./Bacon')` `bundlePath` would be `Bacon.bundle?params=from-metro`.
   */
  async function loadBundleAsync(bundlePath) {
    const requestUrl = (0, _buildUrlForBundle.buildUrlForBundle)(bundlePath);
    {
      return (0, _fetchThenEval.fetchThenEvalAsync)(requestUrl);
    }
  }
},10,[11,12]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.buildUrlForBundle = buildUrlForBundle;
  /**
   * Copyright © 2022 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * Given a path and some optional additional query parameters, create the dev server bundle URL.
   * @param bundlePath like `/foobar`
   * @param params like `{ platform: "web" }`
   * @returns a URL like "/foobar.bundle?platform=android&modulesOnly=true&runModule=false&runtimeBytecodeVersion=null"
   */
  function buildUrlForBundle(bundlePath) {
    if (bundlePath.match(/^https?:\/\//)) {
      return bundlePath;
    }
    if (typeof window !== 'undefined' &&
    // @ts-expect-error
    typeof window.$$EXPO_INITIAL_PROPS !== 'undefined') {
      // In a webview, you cannot read from an absolute path.
      return bundlePath;
    }
    // NOTE(EvanBacon): This must come from the window origin (at least in dev mode).
    // Otherwise Metro will crash from attempting to load a bundle that doesn't exist.
    return '/' + bundlePath.replace(/^\/+/, '');
  }
},11,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.fetchThenEvalAsync = fetchThenEvalAsync;
  /**
   * Copyright © 2022 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  const currentSrc = typeof document !== 'undefined' && document.currentScript ? 'src' in document.currentScript && document.currentScript.src || null : null;

  // Basically `__webpack_require__.l`.
  function fetchThenEvalAsync(url, {
    scriptType,
    nonce,
    crossOrigin
  } = {}) {
    if (typeof window === 'undefined' || // In development, use the fetch/eval method to detect the server error codes and parse bundler errors for the error overlay.
    false) {
      return require(_dependencyMap[0]).fetchThenEvalAsync(url);
    }
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      if (scriptType) script.type = scriptType;
      if (nonce) script.setAttribute('nonce', nonce);
      // script.setAttribute('data-expo-metro', ...);
      script.src = url;
      if (crossOrigin && script.src.indexOf(window.location.origin + '/') !== 0) {
        script.crossOrigin = crossOrigin;
      }
      script.onload = () => {
        script.parentNode && script.parentNode.removeChild(script);
        resolve();
      };
      // Create a new error object to preserve the original stack trace.
      const error = new AsyncRequireError();

      // Server error or network error.
      script.onerror = ev => {
        let event;
        if (typeof ev === 'string') {
          event = {
            type: 'error',
            target: {
              // @ts-expect-error
              src: event
            }
          };
        } else {
          event = ev;
        }
        const errorType = event && (event.type === 'load' ? 'missing' : event.type);
        // @ts-expect-error
        const realSrc = event?.target?.src;
        error.message = 'Loading module ' + url + ' failed.\n(' + errorType + ': ' + realSrc + ')';
        error.type = errorType;
        error.request = realSrc;
        script.parentNode && script.parentNode.removeChild(script);
        reject(error);
      };
      if (script.src === currentSrc) {
        // NOTE(kitten): We always prevent `fetchThenEval` from loading the "current script".
        // This points at our entrypoint bundle, and we should never reload and reevaluate the
        // entrypoint bundle
        resolve();
      } else {
        document.head.appendChild(script);
      }
    });
  }
  class AsyncRequireError extends Error {
    name = 'AsyncRequireError';
  }
},12,[13]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.fetchThenEvalAsync = fetchThenEvalAsync;
  var _errors = require(_dependencyMap[0]);
  var _fetchAsync = require(_dependencyMap[1]);
  /**
   * Copyright © 2022 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * Load a bundle for a URL using fetch + eval on native and script tag injection on web.
   *
   * @param url Given a statement like `import('./Bacon')` `bundlePath` would be `Bacon`.
   */
  function fetchThenEvalAsync(url) {
    return (0, _fetchAsync.fetchAsync)(url).then(({
      body,
      status,
      headers
    }) => {
      if (headers?.has?.('Content-Type') != null && headers.get('Content-Type').includes('application/json')) {
        // Errors are returned as JSON.
        throw new Error(JSON.parse(body).message || `Unknown error fetching '${url}'`);
      }
      if (status === 200) {
        // eslint-disable-next-line no-eval
        return eval(body);
      } else {
        // Format Metro errors if possible.

        throw new Error(`Failed to load split bundle from URL: ${url}\n${body}`);
      }
    });
  }
},13,[14,15]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "MetroServerError", {
    enumerable: true,
    get: function () {
      return MetroServerError;
    }
  });
  class MetroServerError extends Error {
    code = 'METRO_SERVER_ERROR';
    constructor(errorObject, url) {
      super(errorObject.message);
      this.name = 'MetroServerError';
      this.url = url;
      for (const key in errorObject) {
        this[key] = errorObject[key];
      }
    }
  }
},14,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.fetchAsync = fetchAsync;
  /**
   * Copyright © 2022 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  async function fetchAsync(url) {
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        // No real reason for this but we try to use this format for everything.
        'expo-platform': 'web'
      }
    });
    return {
      body: await response.text(),
      status: response.status,
      headers: response.headers
    };
  }
},15,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {},16,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.createErrorHandler = createErrorHandler;
  exports.disableErrorHandling = disableErrorHandling;
  function createErrorHandler(originalHandler) {
    return (error, isFatal) => originalHandler(error, isFatal);
  }

  /**
   * @hidden
   * @deprecated Will be removed in the future.
   */
  function disableErrorHandling() {}
},17,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return registerRootComponent;
    }
  });
  require(_dependencyMap[0]);
  var _reactNativeWebDistExportsAppRegistry = require(_dependencyMap[1]);
  var AppRegistry = _interopDefault(_reactNativeWebDistExportsAppRegistry);
  require(_dependencyMap[2]);
  // @needsAudit
  /**
   * Sets the initial React component to render natively in the app's root React Native view on Android, iOS, tvOS and the web.
   *
   * This method does the following:
   * - Invokes React Native's `AppRegistry.registerComponent`.
   * - Invokes React Native web's `AppRegistry.runApplication` on web to render to the root `index.html` file.
   * - Polyfills the `process.nextTick` function globally.
   *
   * This method also adds the following dev-only features that are removed in production bundles.
   * - Adds the Fast Refresh and bundle splitting indicator to the app.
   * - Asserts if the `expo-updates` package is misconfigured.
   * - Asserts if `react-native` is not aliased to `react-native-web` when running in the browser.
   * @param component The React component class that renders the rest of your app.
   * @see For information on how to setup `registerRootComponent` in an existing (bare) React Native app, see [Common questions](#rootregistercomponent-setup-for-existing-react-native-projects) below.
   */
  function registerRootComponent(component) {
    let qualifiedComponent = component;
    AppRegistry.default.registerComponent('main', () => qualifiedComponent);
    // Skip querying the DOM if we're in a Node.js environment.
    if (typeof window !== 'undefined') {
      const rootTag = document.getElementById('root');
      AppRegistry.default.runApplication('main', {
        rootTag,
        // Injected by SSR HTML tags.
        hydrate: globalThis.__EXPO_ROUTER_HYDRATE__
      });
    }
  }
},18,[2,19,96]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return AppRegistry;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _fbjsLibInvariant = require(_dependencyMap[1]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _unmountComponentAtNode = require(_dependencyMap[2]);
  var unmountComponentAtNode = _interopDefault(_unmountComponentAtNode);
  var _renderApplication = require(_dependencyMap[3]);
  var renderApplication = _interopDefault(_renderApplication);
  var emptyObject = {};
  var runnables = {};
  var componentProviderInstrumentationHook = component => component();
  var wrapperComponentProvider;

  /**
   * `AppRegistry` is the JS entry point to running all React Native apps.
   */
  class AppRegistry {
    static getAppKeys() {
      return Object.keys(runnables);
    }
    static getApplication(appKey, appParameters) {
      (0, invariant.default)(runnables[appKey] && runnables[appKey].getApplication, "Application " + appKey + " has not been registered. " + 'This is either due to an import error during initialization or failure to call AppRegistry.registerComponent.');
      return runnables[appKey].getApplication(appParameters);
    }
    static registerComponent(appKey, componentProvider) {
      runnables[appKey] = {
        getApplication: appParameters => (0, _renderApplication.getApplication)(componentProviderInstrumentationHook(componentProvider), appParameters ? appParameters.initialProps : emptyObject, wrapperComponentProvider && wrapperComponentProvider(appParameters)),
        run: appParameters => (0, renderApplication.default)(componentProviderInstrumentationHook(componentProvider), wrapperComponentProvider && wrapperComponentProvider(appParameters), appParameters.callback, {
          hydrate: appParameters.hydrate || false,
          initialProps: appParameters.initialProps || emptyObject,
          mode: appParameters.mode || 'concurrent',
          rootTag: appParameters.rootTag
        })
      };
      return appKey;
    }
    static registerConfig(config) {
      config.forEach(_ref => {
        var appKey = _ref.appKey,
          component = _ref.component,
          run = _ref.run;
        if (run) {
          AppRegistry.registerRunnable(appKey, run);
        } else {
          (0, invariant.default)(component, 'No component provider passed in');
          AppRegistry.registerComponent(appKey, component);
        }
      });
    }

    // TODO: fix style sheet creation when using this method
    static registerRunnable(appKey, run) {
      runnables[appKey] = {
        run
      };
      return appKey;
    }
    static runApplication(appKey, appParameters) {
      var isDevelopment = false;
      (0, invariant.default)(runnables[appKey] && runnables[appKey].run, "Application \"" + appKey + "\" has not been registered. " + 'This is either due to an import error during initialization or failure to call AppRegistry.registerComponent.');
      return runnables[appKey].run(appParameters);
    }
    static setComponentProviderInstrumentationHook(hook) {
      componentProviderInstrumentationHook = hook;
    }
    static setWrapperComponentProvider(provider) {
      wrapperComponentProvider = provider;
    }
    static unmountApplicationComponentAtRootTag(rootTag) {
      (0, unmountComponentAtNode.default)(rootTag);
    }
  }
},19,[20,25,26,27]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _objectSpread2;
    }
  });
  var _definePropertyJs = require(_dependencyMap[0]);
  var defineProperty = _interopDefault(_definePropertyJs);
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r) {
        return Object.getOwnPropertyDescriptor(e, r).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), true).forEach(function (r) {
        (0, defineProperty.default)(e, r, t[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
      });
    }
    return e;
  }
},20,[21]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _defineProperty;
    }
  });
  var _toPropertyKeyJs = require(_dependencyMap[0]);
  var toPropertyKey = _interopDefault(_toPropertyKeyJs);
  function _defineProperty(e, r, t) {
    return (r = (0, toPropertyKey.default)(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e[r] = t, e;
  }
},21,[22]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return toPropertyKey;
    }
  });
  var _typeofJs = require(_dependencyMap[0]);
  var _typeof = _interopDefault(_typeofJs);
  var _toPrimitiveJs = require(_dependencyMap[1]);
  var toPrimitive = _interopDefault(_toPrimitiveJs);
  function toPropertyKey(t) {
    var i = (0, toPrimitive.default)(t, "string");
    return "symbol" == (0, _typeof.default)(i) ? i : i + "";
  }
},22,[23,24]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _typeof;
    }
  });
  function _typeof(o) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
  }
},23,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return toPrimitive;
    }
  });
  var _typeofJs = require(_dependencyMap[0]);
  var _typeof = _interopDefault(_typeofJs);
  function toPrimitive(t, r) {
    if ("object" != (0, _typeof.default)(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (undefined !== e) {
      var i = e.call(t, r || "default");
      if ("object" != (0, _typeof.default)(i)) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
},24,[23]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */
  'use strict';

  var validateFormat = function (format) {};
  /**
   * Use invariant() to assert state which your program assumes to be true.
   *
   * Provide sprintf-style format (only %s is supported) and arguments to provide
   * information about what broke and what you were expecting.
   *
   * The invariant message will be stripped in production, but the invariant will
   * remain to ensure logic does not differ in production.
   */

  function invariant(condition, format) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    validateFormat(format);
    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      } else {
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return String(args[argIndex++]);
        }));
        error.name = 'Invariant Violation';
      }
      error.framesToPop = 1; // Skip invariant's own stack frame.

      throw error;
    }
  }
  module.exports = invariant;
},25,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return unmountComponentAtNode;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function unmountComponentAtNode(rootTag) {
    rootTag.unmount();
    return true;
  }
},26,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return renderApplication;
    }
  });
  exports.getApplication = getApplication;
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _AppContainer = require(_dependencyMap[1]);
  var AppContainer = _interopDefault(_AppContainer);
  var _fbjsLibInvariant = require(_dependencyMap[2]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _render = require(_dependencyMap[3]);
  var render = _interopDefault(_render);
  var _StyleSheet = require(_dependencyMap[4]);
  var StyleSheet = _interopDefault(_StyleSheet);
  var _react = require(_dependencyMap[5]);
  var React = _interopDefault(_react);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function renderApplication(RootComponent, WrapperComponent, callback, options) {
    var shouldHydrate = options.hydrate,
      initialProps = options.initialProps,
      rootTag = options.rootTag;
    var renderFn = shouldHydrate ? _render.hydrate : render.default;
    (0, invariant.default)(rootTag, 'Expect to have a valid rootTag, instead got ', rootTag);
    return renderFn(/*#__PURE__*/React.default.createElement(AppContainer.default, {
      WrapperComponent: WrapperComponent,
      ref: callback,
      rootTag: rootTag
    }, /*#__PURE__*/React.default.createElement(RootComponent, initialProps)), rootTag);
  }
  function getApplication(RootComponent, initialProps, WrapperComponent) {
    var element = /*#__PURE__*/React.default.createElement(AppContainer.default, {
      WrapperComponent: WrapperComponent,
      rootTag: {}
    }, /*#__PURE__*/React.default.createElement(RootComponent, initialProps));
    // Don't escape CSS text
    var getStyleElement = props => {
      var sheet = StyleSheet.default.getSheet();
      return /*#__PURE__*/React.default.createElement("style", (0, _extends.default)({}, props, {
        dangerouslySetInnerHTML: {
          __html: sheet.textContent
        },
        id: sheet.id
      }));
    };
    return {
      element,
      getStyleElement
    };
  }
},27,[28,29,25,30,43,35]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _extends;
    }
  });
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function (n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }
},28,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  // NOTE(EvanBacon): `react-native-web` adds a extra `div`s around the root HTML, these
  // make static rendering much harder as we expect the root element to be `<html>`.
  // This resolution will alias to a simple in-out component to avoid the extra HTML.
  function AppContainer({
    children
  }) {
    return children;
  }
  var _default = AppContainer;
},29,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return render;
    }
  });
  exports.hydrate = hydrate;
  var _reactDomClient = require(_dependencyMap[0]);
  var _StyleSheetDom = require(_dependencyMap[1]);
  function hydrate(element, root) {
    (0, _StyleSheetDom.createSheet)(root);
    return (0, _reactDomClient.hydrateRoot)(root, element);
  }
  function render(element, root) {
    (0, _StyleSheetDom.createSheet)(root);
    var reactRoot = (0, _reactDomClient.createRoot)(root);
    reactRoot.render(element);
    return reactRoot;
  }
},30,[31,39]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function checkDCE() {
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
      return;
    }
    try {
      // Verify that the code above has been dead code eliminated (DCE'd).
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      // DevTools shouldn't crash React, no matter what.
      // We should still report in case we break this code.
      console.error(err);
    }
  }
  {
    // DCE check should happen before ReactDOM bundle executes so that
    // DevTools can report bad minification during injection.
    checkDCE();
    module.exports = require(_dependencyMap[0]);
  }
},31,[32]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * react-dom-client.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /*
   Modernizr 3.0.0pre (Custom Build) | MIT
  */
  "use strict";

  var Scheduler = require(_dependencyMap[0]),
    React = require(_dependencyMap[1]),
    ReactDOM = require(_dependencyMap[2]);
  function formatProdErrorMessage(code) {
    var url = "https://react.dev/errors/" + code;
    if (1 < arguments.length) {
      url += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var i = 2; i < arguments.length; i++) url += "&args[]=" + encodeURIComponent(arguments[i]);
    }
    return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function isValidContainer(node) {
    return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
  }
  function getNearestMountedFiber(fiber) {
    var node = fiber,
      nearestMounted = fiber;
    if (fiber.alternate) for (; node.return;) node = node.return;else {
      fiber = node;
      do node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return; while (fiber);
    }
    return 3 === node.tag ? nearestMounted : null;
  }
  function getSuspenseInstanceFromFiber(fiber) {
    if (13 === fiber.tag) {
      var suspenseState = fiber.memoizedState;
      null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
      if (null !== suspenseState) return suspenseState.dehydrated;
    }
    return null;
  }
  function assertIsMounted(fiber) {
    if (getNearestMountedFiber(fiber) !== fiber) throw Error(formatProdErrorMessage(188));
  }
  function findCurrentFiberUsingSlowPath(fiber) {
    var alternate = fiber.alternate;
    if (!alternate) {
      alternate = getNearestMountedFiber(fiber);
      if (null === alternate) throw Error(formatProdErrorMessage(188));
      return alternate !== fiber ? null : fiber;
    }
    for (var a = fiber, b = alternate;;) {
      var parentA = a.return;
      if (null === parentA) break;
      var parentB = parentA.alternate;
      if (null === parentB) {
        b = parentA.return;
        if (null !== b) {
          a = b;
          continue;
        }
        break;
      }
      if (parentA.child === parentB.child) {
        for (parentB = parentA.child; parentB;) {
          if (parentB === a) return assertIsMounted(parentA), fiber;
          if (parentB === b) return assertIsMounted(parentA), alternate;
          parentB = parentB.sibling;
        }
        throw Error(formatProdErrorMessage(188));
      }
      if (a.return !== b.return) a = parentA, b = parentB;else {
        for (var didFindChild = false, child$0 = parentA.child; child$0;) {
          if (child$0 === a) {
            didFindChild = true;
            a = parentA;
            b = parentB;
            break;
          }
          if (child$0 === b) {
            didFindChild = true;
            b = parentA;
            a = parentB;
            break;
          }
          child$0 = child$0.sibling;
        }
        if (!didFindChild) {
          for (child$0 = parentB.child; child$0;) {
            if (child$0 === a) {
              didFindChild = true;
              a = parentB;
              b = parentA;
              break;
            }
            if (child$0 === b) {
              didFindChild = true;
              b = parentB;
              a = parentA;
              break;
            }
            child$0 = child$0.sibling;
          }
          if (!didFindChild) throw Error(formatProdErrorMessage(189));
        }
      }
      if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
    }
    if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
    return a.stateNode.current === a ? fiber : alternate;
  }
  function findCurrentHostFiberImpl(node) {
    var tag = node.tag;
    if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
    for (node = node.child; null !== node;) {
      tag = findCurrentHostFiberImpl(node);
      if (null !== tag) return tag;
      node = node.sibling;
    }
    return null;
  }
  var assign = Object.assign,
    REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
    REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
    REACT_PORTAL_TYPE = Symbol.for("react.portal"),
    REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
    REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
    REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
    REACT_PROVIDER_TYPE = Symbol.for("react.provider"),
    REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
    REACT_CONTEXT_TYPE = Symbol.for("react.context"),
    REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
    REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
    REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
    REACT_MEMO_TYPE = Symbol.for("react.memo"),
    REACT_LAZY_TYPE = Symbol.for("react.lazy");
  Symbol.for("react.scope");
  var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
  Symbol.for("react.legacy_hidden");
  Symbol.for("react.tracing_marker");
  var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
  Symbol.for("react.view_transition");
  var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
  function getIteratorFn(maybeIterable) {
    if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
    maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
    return "function" === typeof maybeIterable ? maybeIterable : null;
  }
  var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  function getComponentNameFromType(type) {
    if (null == type) return null;
    if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
    if ("string" === typeof type) return type;
    switch (type) {
      case REACT_FRAGMENT_TYPE:
        return "Fragment";
      case REACT_PROFILER_TYPE:
        return "Profiler";
      case REACT_STRICT_MODE_TYPE:
        return "StrictMode";
      case REACT_SUSPENSE_TYPE:
        return "Suspense";
      case REACT_SUSPENSE_LIST_TYPE:
        return "SuspenseList";
      case REACT_ACTIVITY_TYPE:
        return "Activity";
    }
    if ("object" === typeof type) switch (type.$$typeof) {
      case REACT_PORTAL_TYPE:
        return "Portal";
      case REACT_CONTEXT_TYPE:
        return (type.displayName || "Context") + ".Provider";
      case REACT_CONSUMER_TYPE:
        return (type._context.displayName || "Context") + ".Consumer";
      case REACT_FORWARD_REF_TYPE:
        var innerType = type.render;
        type = type.displayName;
        type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
        return type;
      case REACT_MEMO_TYPE:
        return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
      case REACT_LAZY_TYPE:
        innerType = type._payload;
        type = type._init;
        try {
          return getComponentNameFromType(type(innerType));
        } catch (x) {}
    }
    return null;
  }
  var isArrayImpl = Array.isArray,
    ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    sharedNotPendingObject = {
      pending: false,
      data: null,
      method: null,
      action: null
    },
    valueStack = [],
    index = -1;
  function createCursor(defaultValue) {
    return {
      current: defaultValue
    };
  }
  function pop(cursor) {
    0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
  }
  function push(cursor, value) {
    index++;
    valueStack[index] = cursor.current;
    cursor.current = value;
  }
  var contextStackCursor = createCursor(null),
    contextFiberStackCursor = createCursor(null),
    rootInstanceStackCursor = createCursor(null),
    hostTransitionProviderCursor = createCursor(null);
  function pushHostContainer(fiber, nextRootInstance) {
    push(rootInstanceStackCursor, nextRootInstance);
    push(contextFiberStackCursor, fiber);
    push(contextStackCursor, null);
    switch (nextRootInstance.nodeType) {
      case 9:
      case 11:
        fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
        break;
      default:
        if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI) nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);else switch (fiber) {
          case "svg":
            fiber = 1;
            break;
          case "math":
            fiber = 2;
            break;
          default:
            fiber = 0;
        }
    }
    pop(contextStackCursor);
    push(contextStackCursor, fiber);
  }
  function popHostContainer() {
    pop(contextStackCursor);
    pop(contextFiberStackCursor);
    pop(rootInstanceStackCursor);
  }
  function pushHostContext(fiber) {
    null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
    var context = contextStackCursor.current;
    var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
    context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
  }
  function popHostContext(fiber) {
    contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
    hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
  }
  var hasOwnProperty = Object.prototype.hasOwnProperty,
    scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
    cancelCallback$1 = Scheduler.unstable_cancelCallback,
    shouldYield = Scheduler.unstable_shouldYield,
    requestPaint = Scheduler.unstable_requestPaint,
    now = Scheduler.unstable_now,
    getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
    ImmediatePriority = Scheduler.unstable_ImmediatePriority,
    UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
    NormalPriority$1 = Scheduler.unstable_NormalPriority,
    LowPriority = Scheduler.unstable_LowPriority,
    IdlePriority = Scheduler.unstable_IdlePriority,
    log$1 = Scheduler.log,
    unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
    rendererID = null,
    injectedHook = null;
  function setIsStrictModeForDevtools(newIsStrictMode) {
    "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
    if (injectedHook && "function" === typeof injectedHook.setStrictMode) try {
      injectedHook.setStrictMode(rendererID, newIsStrictMode);
    } catch (err) {}
  }
  var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
    log = Math.log,
    LN2 = Math.LN2;
  function clz32Fallback(x) {
    x >>>= 0;
    return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
  }
  var nextTransitionLane = 256,
    nextRetryLane = 4194304;
  function getHighestPriorityLanes(lanes) {
    var pendingSyncLanes = lanes & 42;
    if (0 !== pendingSyncLanes) return pendingSyncLanes;
    switch (lanes & -lanes) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return lanes & 4194048;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return lanes & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return lanes;
    }
  }
  function getNextLanes(root, wipLanes, rootHasPendingCommit) {
    var pendingLanes = root.pendingLanes;
    if (0 === pendingLanes) return 0;
    var nextLanes = 0,
      suspendedLanes = root.suspendedLanes,
      pingedLanes = root.pingedLanes;
    root = root.warmLanes;
    var nonIdlePendingLanes = pendingLanes & 134217727;
    0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
    return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
  }
  function checkIfRootIsPrerendering(root, renderLanes) {
    return 0 === (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes);
  }
  function computeExpirationTime(lane, currentTime) {
    switch (lane) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return currentTime + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return currentTime + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function claimNextTransitionLane() {
    var lane = nextTransitionLane;
    nextTransitionLane <<= 1;
    0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
    return lane;
  }
  function claimNextRetryLane() {
    var lane = nextRetryLane;
    nextRetryLane <<= 1;
    0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
    return lane;
  }
  function createLaneMap(initial) {
    for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
    return laneMap;
  }
  function markRootUpdated$1(root, updateLane) {
    root.pendingLanes |= updateLane;
    268435456 !== updateLane && (root.suspendedLanes = 0, root.pingedLanes = 0, root.warmLanes = 0);
  }
  function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
    var previouslyPendingLanes = root.pendingLanes;
    root.pendingLanes = remainingLanes;
    root.suspendedLanes = 0;
    root.pingedLanes = 0;
    root.warmLanes = 0;
    root.expiredLanes &= remainingLanes;
    root.entangledLanes &= remainingLanes;
    root.errorRecoveryDisabledLanes &= remainingLanes;
    root.shellSuspendCounter = 0;
    var entanglements = root.entanglements,
      expirationTimes = root.expirationTimes,
      hiddenUpdates = root.hiddenUpdates;
    for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes;) {
      var index$5 = 31 - clz32(remainingLanes),
        lane = 1 << index$5;
      entanglements[index$5] = 0;
      expirationTimes[index$5] = -1;
      var hiddenUpdatesForLane = hiddenUpdates[index$5];
      if (null !== hiddenUpdatesForLane) for (hiddenUpdates[index$5] = null, index$5 = 0; index$5 < hiddenUpdatesForLane.length; index$5++) {
        var update = hiddenUpdatesForLane[index$5];
        null !== update && (update.lane &= -536870913);
      }
      remainingLanes &= ~lane;
    }
    0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
    0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root.tag && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
  }
  function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
    root.pendingLanes |= spawnedLane;
    root.suspendedLanes &= ~spawnedLane;
    var spawnedLaneIndex = 31 - clz32(spawnedLane);
    root.entangledLanes |= spawnedLane;
    root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194090;
  }
  function markRootEntangled(root, entangledLanes) {
    var rootEntangledLanes = root.entangledLanes |= entangledLanes;
    for (root = root.entanglements; rootEntangledLanes;) {
      var index$6 = 31 - clz32(rootEntangledLanes),
        lane = 1 << index$6;
      lane & entangledLanes | root[index$6] & entangledLanes && (root[index$6] |= entangledLanes);
      rootEntangledLanes &= ~lane;
    }
  }
  function getBumpedLaneForHydrationByLane(lane) {
    switch (lane) {
      case 2:
        lane = 1;
        break;
      case 8:
        lane = 4;
        break;
      case 32:
        lane = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        lane = 128;
        break;
      case 268435456:
        lane = 134217728;
        break;
      default:
        lane = 0;
    }
    return lane;
  }
  function lanesToEventPriority(lanes) {
    lanes &= -lanes;
    return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
  }
  function resolveUpdatePriority() {
    var updatePriority = ReactDOMSharedInternals.p;
    if (0 !== updatePriority) return updatePriority;
    updatePriority = window.event;
    return undefined === updatePriority ? 32 : getEventPriority(updatePriority.type);
  }
  function runWithPriority(priority, fn) {
    var previousPriority = ReactDOMSharedInternals.p;
    try {
      return ReactDOMSharedInternals.p = priority, fn();
    } finally {
      ReactDOMSharedInternals.p = previousPriority;
    }
  }
  var randomKey = Math.random().toString(36).slice(2),
    internalInstanceKey = "__reactFiber$" + randomKey,
    internalPropsKey = "__reactProps$" + randomKey,
    internalContainerInstanceKey = "__reactContainer$" + randomKey,
    internalEventHandlersKey = "__reactEvents$" + randomKey,
    internalEventHandlerListenersKey = "__reactListeners$" + randomKey,
    internalEventHandlesSetKey = "__reactHandles$" + randomKey,
    internalRootNodeResourcesKey = "__reactResources$" + randomKey,
    internalHoistableMarker = "__reactMarker$" + randomKey;
  function detachDeletedInstance(node) {
    delete node[internalInstanceKey];
    delete node[internalPropsKey];
    delete node[internalEventHandlersKey];
    delete node[internalEventHandlerListenersKey];
    delete node[internalEventHandlesSetKey];
  }
  function getClosestInstanceFromNode(targetNode) {
    var targetInst = targetNode[internalInstanceKey];
    if (targetInst) return targetInst;
    for (var parentNode = targetNode.parentNode; parentNode;) {
      if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
        parentNode = targetInst.alternate;
        if (null !== targetInst.child || null !== parentNode && null !== parentNode.child) for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode;) {
          if (parentNode = targetNode[internalInstanceKey]) return parentNode;
          targetNode = getParentSuspenseInstance(targetNode);
        }
        return targetInst;
      }
      targetNode = parentNode;
      parentNode = targetNode.parentNode;
    }
    return null;
  }
  function getInstanceFromNode(node) {
    if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
      var tag = node.tag;
      if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag) return node;
    }
    return null;
  }
  function getNodeFromInstance(inst) {
    var tag = inst.tag;
    if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
    throw Error(formatProdErrorMessage(33));
  }
  function getResourcesFromRoot(root) {
    var resources = root[internalRootNodeResourcesKey];
    resources || (resources = root[internalRootNodeResourcesKey] = {
      hoistableStyles: new Map(),
      hoistableScripts: new Map()
    });
    return resources;
  }
  function markNodeAsHoistable(node) {
    node[internalHoistableMarker] = true;
  }
  var allNativeEvents = new Set(),
    registrationNameDependencies = {};
  function registerTwoPhaseEvent(registrationName, dependencies) {
    registerDirectEvent(registrationName, dependencies);
    registerDirectEvent(registrationName + "Capture", dependencies);
  }
  function registerDirectEvent(registrationName, dependencies) {
    registrationNameDependencies[registrationName] = dependencies;
    for (registrationName = 0; registrationName < dependencies.length; registrationName++) allNativeEvents.add(dependencies[registrationName]);
  }
  var VALID_ATTRIBUTE_NAME_REGEX = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),
    illegalAttributeNameCache = {},
    validatedAttributeNameCache = {};
  function isAttributeNameSafe(attributeName) {
    if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) return true;
    if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
    if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) return validatedAttributeNameCache[attributeName] = true;
    illegalAttributeNameCache[attributeName] = true;
    return false;
  }
  function setValueForAttribute(node, name, value) {
    if (isAttributeNameSafe(name)) if (null === value) node.removeAttribute(name);else {
      switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
          node.removeAttribute(name);
          return;
        case "boolean":
          var prefix$8 = name.toLowerCase().slice(0, 5);
          if ("data-" !== prefix$8 && "aria-" !== prefix$8) {
            node.removeAttribute(name);
            return;
          }
      }
      node.setAttribute(name, "" + value);
    }
  }
  function setValueForKnownAttribute(node, name, value) {
    if (null === value) node.removeAttribute(name);else {
      switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          node.removeAttribute(name);
          return;
      }
      node.setAttribute(name, "" + value);
    }
  }
  function setValueForNamespacedAttribute(node, namespace, name, value) {
    if (null === value) node.removeAttribute(name);else {
      switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          node.removeAttribute(name);
          return;
      }
      node.setAttributeNS(namespace, name, "" + value);
    }
  }
  var prefix, suffix;
  function describeBuiltInComponentFrame(name) {
    if (undefined === prefix) try {
      throw Error();
    } catch (x) {
      var match = x.stack.trim().match(/\n( *(at )?)/);
      prefix = match && match[1] || "";
      suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
    }
    return "\n" + prefix + name + suffix;
  }
  var reentry = false;
  function describeNativeComponentFrame(fn, construct) {
    if (!fn || reentry) return "";
    reentry = true;
    var previousPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = undefined;
    try {
      var RunInRootFrame = {
        DetermineComponentFrameRoot: function () {
          try {
            if (construct) {
              var Fake = function () {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function () {
                  throw Error();
                }
              });
              if ("object" === typeof Reflect && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  var control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x$9) {
                  control = x$9;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x$10) {
                control = x$10;
              }
              (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function () {});
            }
          } catch (sample) {
            if (sample && control && "string" === typeof sample.stack) return [sample.stack, control.stack];
          }
          return [null, null];
        }
      };
      RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
      namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", {
        value: "DetermineComponentFrameRoot"
      });
      var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),
        sampleStack = _RunInRootFrame$Deter[0],
        controlStack = _RunInRootFrame$Deter[1];
      if (sampleStack && controlStack) {
        var sampleLines = sampleStack.split("\n"),
          controlLines = controlStack.split("\n");
        for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot");) RunInRootFrame++;
        for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes("DetermineComponentFrameRoot");) namePropDescriptor++;
        if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length) for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];) namePropDescriptor--;
        for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--) if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
          if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
            do if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
              var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
              fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
              return frame;
            } while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
          }
          break;
        }
      }
    } finally {
      reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
    }
    return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
  }
  function describeFiber(fiber) {
    switch (fiber.tag) {
      case 26:
      case 27:
      case 5:
        return describeBuiltInComponentFrame(fiber.type);
      case 16:
        return describeBuiltInComponentFrame("Lazy");
      case 13:
        return describeBuiltInComponentFrame("Suspense");
      case 19:
        return describeBuiltInComponentFrame("SuspenseList");
      case 0:
      case 15:
        return describeNativeComponentFrame(fiber.type, false);
      case 11:
        return describeNativeComponentFrame(fiber.type.render, false);
      case 1:
        return describeNativeComponentFrame(fiber.type, true);
      case 31:
        return describeBuiltInComponentFrame("Activity");
      default:
        return "";
    }
  }
  function getStackByFiberInDevAndProd(workInProgress) {
    try {
      var info = "";
      do info += describeFiber(workInProgress), workInProgress = workInProgress.return; while (workInProgress);
      return info;
    } catch (x) {
      return "\nError generating stack: " + x.message + "\n" + x.stack;
    }
  }
  function getToStringValue(value) {
    switch (typeof value) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return value;
      case "object":
        return value;
      default:
        return "";
    }
  }
  function isCheckable(elem) {
    var type = elem.type;
    return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
  }
  function trackValueOnNode(node) {
    var valueField = isCheckable(node) ? "checked" : "value",
      descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField),
      currentValue = "" + node[valueField];
    if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
      var get = descriptor.get,
        set = descriptor.set;
      Object.defineProperty(node, valueField, {
        configurable: true,
        get: function () {
          return get.call(this);
        },
        set: function (value) {
          currentValue = "" + value;
          set.call(this, value);
        }
      });
      Object.defineProperty(node, valueField, {
        enumerable: descriptor.enumerable
      });
      return {
        getValue: function () {
          return currentValue;
        },
        setValue: function (value) {
          currentValue = "" + value;
        },
        stopTracking: function () {
          node._valueTracker = null;
          delete node[valueField];
        }
      };
    }
  }
  function track(node) {
    node._valueTracker || (node._valueTracker = trackValueOnNode(node));
  }
  function updateValueIfChanged(node) {
    if (!node) return false;
    var tracker = node._valueTracker;
    if (!tracker) return true;
    var lastValue = tracker.getValue();
    var value = "";
    node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
    node = value;
    return node !== lastValue ? (tracker.setValue(node), true) : false;
  }
  function getActiveElement(doc) {
    doc = doc || ("undefined" !== typeof document ? document : undefined);
    if ("undefined" === typeof doc) return null;
    try {
      return doc.activeElement || doc.body;
    } catch (e) {
      return doc.body;
    }
  }
  var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
  function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
    return value.replace(escapeSelectorAttributeValueInsideDoubleQuotesRegex, function (ch) {
      return "\\" + ch.charCodeAt(0).toString(16) + " ";
    });
  }
  function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
    element.name = "";
    null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
    if (null != value) {
      if ("number" === type) {
        if (0 === value && "" === element.value || element.value != value) element.value = "" + getToStringValue(value);
      } else element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
    } else "submit" !== type && "reset" !== type || element.removeAttribute("value");
    null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
    null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
    null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
    null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
  }
  function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating) {
    null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
    if (null != value || null != defaultValue) {
      if (!("submit" !== type && "reset" !== type || undefined !== value && null !== value)) return;
      defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
      value = null != value ? "" + getToStringValue(value) : defaultValue;
      isHydrating || value === element.value || (element.value = value);
      element.defaultValue = value;
    }
    checked = null != checked ? checked : defaultChecked;
    checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
    element.checked = isHydrating ? element.checked : !!checked;
    element.defaultChecked = !!checked;
    null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
  }
  function setDefaultValue(node, type, value) {
    "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
  }
  function updateOptions(node, multiple, propValue, setDefaultSelected) {
    node = node.options;
    if (multiple) {
      multiple = {};
      for (var i = 0; i < propValue.length; i++) multiple["$" + propValue[i]] = true;
      for (propValue = 0; propValue < node.length; propValue++) i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
    } else {
      propValue = "" + getToStringValue(propValue);
      multiple = null;
      for (i = 0; i < node.length; i++) {
        if (node[i].value === propValue) {
          node[i].selected = true;
          setDefaultSelected && (node[i].defaultSelected = true);
          return;
        }
        null !== multiple || node[i].disabled || (multiple = node[i]);
      }
      null !== multiple && (multiple.selected = true);
    }
  }
  function updateTextarea(element, value, defaultValue) {
    if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
      element.defaultValue !== value && (element.defaultValue = value);
      return;
    }
    element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
  }
  function initTextarea(element, value, defaultValue, children) {
    if (null == value) {
      if (null != children) {
        if (null != defaultValue) throw Error(formatProdErrorMessage(92));
        if (isArrayImpl(children)) {
          if (1 < children.length) throw Error(formatProdErrorMessage(93));
          children = children[0];
        }
        defaultValue = children;
      }
      null == defaultValue && (defaultValue = "");
      value = defaultValue;
    }
    defaultValue = getToStringValue(value);
    element.defaultValue = defaultValue;
    children = element.textContent;
    children === defaultValue && "" !== children && null !== children && (element.value = children);
  }
  function setTextContent(node, text) {
    if (text) {
      var firstChild = node.firstChild;
      if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
        firstChild.nodeValue = text;
        return;
      }
    }
    node.textContent = text;
  }
  var unitlessNumbers = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
  function setValueForStyle(style, styleName, value) {
    var isCustomProperty = 0 === styleName.indexOf("--");
    null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style.setProperty(styleName, "") : "float" === styleName ? style.cssFloat = "" : style[styleName] = "" : isCustomProperty ? style.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style.cssFloat = value : style[styleName] = ("" + value).trim() : style[styleName] = value + "px";
  }
  function setValueForStyles(node, styles, prevStyles) {
    if (null != styles && "object" !== typeof styles) throw Error(formatProdErrorMessage(62));
    node = node.style;
    if (null != prevStyles) {
      for (var styleName in prevStyles) !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
      for (var styleName$16 in styles) styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
    } else for (var styleName$17 in styles) styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
  }
  function isCustomElement(tagName) {
    if (-1 === tagName.indexOf("-")) return false;
    switch (tagName) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var aliases = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]]),
    isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function sanitizeURL(url) {
    return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
  }
  var currentReplayingEvent = null;
  function getEventTarget(nativeEvent) {
    nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
    nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
    return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
  }
  var restoreTarget = null,
    restoreQueue = null;
  function restoreStateOfTarget(target) {
    var internalInstance = getInstanceFromNode(target);
    if (internalInstance && (target = internalInstance.stateNode)) {
      var props = target[internalPropsKey] || null;
      a: switch (target = internalInstance.stateNode, internalInstance.type) {
        case "input":
          updateInput(target, props.value, props.defaultValue, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name);
          internalInstance = props.name;
          if ("radio" === props.type && null != internalInstance) {
            for (props = target; props.parentNode;) props = props.parentNode;
            props = props.querySelectorAll('input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes("" + internalInstance) + '"][type="radio"]');
            for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
              var otherNode = props[internalInstance];
              if (otherNode !== target && otherNode.form === target.form) {
                var otherProps = otherNode[internalPropsKey] || null;
                if (!otherProps) throw Error(formatProdErrorMessage(90));
                updateInput(otherNode, otherProps.value, otherProps.defaultValue, otherProps.defaultValue, otherProps.checked, otherProps.defaultChecked, otherProps.type, otherProps.name);
              }
            }
            for (internalInstance = 0; internalInstance < props.length; internalInstance++) otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
          }
          break a;
        case "textarea":
          updateTextarea(target, props.value, props.defaultValue);
          break a;
        case "select":
          internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
      }
    }
  }
  var isInsideEventHandler = false;
  function batchedUpdates$1(fn, a, b) {
    if (isInsideEventHandler) return fn(a, b);
    isInsideEventHandler = true;
    try {
      var JSCompiler_inline_result = fn(a);
      return JSCompiler_inline_result;
    } finally {
      if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn)) for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
    }
  }
  function getListener(inst, registrationName) {
    var stateNode = inst.stateNode;
    if (null === stateNode) return null;
    var props = stateNode[internalPropsKey] || null;
    if (null === props) return null;
    stateNode = props[registrationName];
    a: switch (registrationName) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
        inst = !props;
        break a;
      default:
        inst = false;
    }
    if (inst) return null;
    if (stateNode && "function" !== typeof stateNode) throw Error(formatProdErrorMessage(231, registrationName, typeof stateNode));
    return stateNode;
  }
  var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement),
    passiveBrowserEventsSupported = false;
  if (canUseDOM) try {
    var options = {};
    Object.defineProperty(options, "passive", {
      get: function () {
        passiveBrowserEventsSupported = true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (e) {
    passiveBrowserEventsSupported = false;
  }
  var root = null,
    startText = null,
    fallbackText = null;
  function getData() {
    if (fallbackText) return fallbackText;
    var start,
      startValue = startText,
      startLength = startValue.length,
      end,
      endValue = "value" in root ? root.value : root.textContent,
      endLength = endValue.length;
    for (start = 0; start < startLength && startValue[start] === endValue[start]; start++);
    var minEnd = startLength - start;
    for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++);
    return fallbackText = endValue.slice(start, 1 < end ? 1 - end : undefined);
  }
  function getEventCharCode(nativeEvent) {
    var keyCode = nativeEvent.keyCode;
    "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
    10 === nativeEvent && (nativeEvent = 13);
    return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
  }
  function functionThatReturnsTrue() {
    return true;
  }
  function functionThatReturnsFalse() {
    return false;
  }
  function createSyntheticEvent(Interface) {
    function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
      this._reactName = reactName;
      this._targetInst = targetInst;
      this.type = reactEventType;
      this.nativeEvent = nativeEvent;
      this.target = nativeEventTarget;
      this.currentTarget = null;
      for (var propName in Interface) Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
      this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
      this.isPropagationStopped = functionThatReturnsFalse;
      return this;
    }
    assign(SyntheticBaseEvent.prototype, {
      preventDefault: function () {
        this.defaultPrevented = true;
        var event = this.nativeEvent;
        event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
      },
      stopPropagation: function () {
        var event = this.nativeEvent;
        event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
      },
      persist: function () {},
      isPersistent: functionThatReturnsTrue
    });
    return SyntheticBaseEvent;
  }
  var EventInterface = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (event) {
        return event.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    },
    SyntheticEvent = createSyntheticEvent(EventInterface),
    UIEventInterface = assign({}, EventInterface, {
      view: 0,
      detail: 0
    }),
    SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
    lastMovementX,
    lastMovementY,
    lastMouseEvent,
    MouseEventInterface = assign({}, UIEventInterface, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: getEventModifierState,
      button: 0,
      buttons: 0,
      relatedTarget: function (event) {
        return undefined === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
      },
      movementX: function (event) {
        if ("movementX" in event) return event.movementX;
        event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
        return lastMovementX;
      },
      movementY: function (event) {
        return "movementY" in event ? event.movementY : lastMovementY;
      }
    }),
    SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
    DragEventInterface = assign({}, MouseEventInterface, {
      dataTransfer: 0
    }),
    SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
    FocusEventInterface = assign({}, UIEventInterface, {
      relatedTarget: 0
    }),
    SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
    AnimationEventInterface = assign({}, EventInterface, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }),
    SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),
    ClipboardEventInterface = assign({}, EventInterface, {
      clipboardData: function (event) {
        return "clipboardData" in event ? event.clipboardData : window.clipboardData;
      }
    }),
    SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),
    CompositionEventInterface = assign({}, EventInterface, {
      data: 0
    }),
    SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),
    normalizeKey = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    },
    translateToKey = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    },
    modifierKeyToProp = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
  function modifierStateGetter(keyArg) {
    var nativeEvent = this.nativeEvent;
    return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
  }
  function getEventModifierState() {
    return modifierStateGetter;
  }
  var KeyboardEventInterface = assign({}, UIEventInterface, {
      key: function (nativeEvent) {
        if (nativeEvent.key) {
          var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
          if ("Unidentified" !== key) return key;
        }
        return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: getEventModifierState,
      charCode: function (event) {
        return "keypress" === event.type ? getEventCharCode(event) : 0;
      },
      keyCode: function (event) {
        return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
      },
      which: function (event) {
        return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
      }
    }),
    SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
    PointerEventInterface = assign({}, MouseEventInterface, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }),
    SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
    TouchEventInterface = assign({}, UIEventInterface, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: getEventModifierState
    }),
    SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
    TransitionEventInterface = assign({}, EventInterface, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }),
    SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),
    WheelEventInterface = assign({}, MouseEventInterface, {
      deltaX: function (event) {
        return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
      },
      deltaY: function (event) {
        return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }),
    SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
    ToggleEventInterface = assign({}, EventInterface, {
      newState: 0,
      oldState: 0
    }),
    SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
    END_KEYCODES = [9, 13, 27, 32],
    canUseCompositionEvent = canUseDOM && "CompositionEvent" in window,
    documentMode = null;
  canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
  var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode,
    useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode),
    SPACEBAR_CHAR = String.fromCharCode(32),
    hasSpaceKeypress = false;
  function isFallbackCompositionEnd(domEventName, nativeEvent) {
    switch (domEventName) {
      case "keyup":
        return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
      case "keydown":
        return 229 !== nativeEvent.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function getDataFromCustomEvent(nativeEvent) {
    nativeEvent = nativeEvent.detail;
    return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
  }
  var isComposing = false;
  function getNativeBeforeInputChars(domEventName, nativeEvent) {
    switch (domEventName) {
      case "compositionend":
        return getDataFromCustomEvent(nativeEvent);
      case "keypress":
        if (32 !== nativeEvent.which) return null;
        hasSpaceKeypress = true;
        return SPACEBAR_CHAR;
      case "textInput":
        return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
      default:
        return null;
    }
  }
  function getFallbackBeforeInputChars(domEventName, nativeEvent) {
    if (isComposing) return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
    switch (domEventName) {
      case "paste":
        return null;
      case "keypress":
        if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
          if (nativeEvent.char && 1 < nativeEvent.char.length) return nativeEvent.char;
          if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
        }
        return null;
      case "compositionend":
        return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
      default:
        return null;
    }
  }
  var supportedInputTypes = {
    color: true,
    date: true,
    datetime: true,
    "datetime-local": true,
    email: true,
    month: true,
    number: true,
    password: true,
    range: true,
    search: true,
    tel: true,
    text: true,
    time: true,
    url: true,
    week: true
  };
  function isTextInputElement(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
  }
  function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
    restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
    inst = accumulateTwoPhaseListeners(inst, "onChange");
    0 < inst.length && (nativeEvent = new SyntheticEvent("onChange", "change", null, nativeEvent, target), dispatchQueue.push({
      event: nativeEvent,
      listeners: inst
    }));
  }
  var activeElement$1 = null,
    activeElementInst$1 = null;
  function runEventInBatch(dispatchQueue) {
    processDispatchQueue(dispatchQueue, 0);
  }
  function getInstIfValueChanged(targetInst) {
    var targetNode = getNodeFromInstance(targetInst);
    if (updateValueIfChanged(targetNode)) return targetInst;
  }
  function getTargetInstForChangeEvent(domEventName, targetInst) {
    if ("change" === domEventName) return targetInst;
  }
  var isInputEventSupported = false;
  if (canUseDOM) {
    var JSCompiler_inline_result$jscomp$282;
    if (canUseDOM) {
      var isSupported$jscomp$inline_417 = "oninput" in document;
      if (!isSupported$jscomp$inline_417) {
        var element$jscomp$inline_418 = document.createElement("div");
        element$jscomp$inline_418.setAttribute("oninput", "return;");
        isSupported$jscomp$inline_417 = "function" === typeof element$jscomp$inline_418.oninput;
      }
      JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417;
    } else JSCompiler_inline_result$jscomp$282 = false;
    isInputEventSupported = JSCompiler_inline_result$jscomp$282 && (!document.documentMode || 9 < document.documentMode);
  }
  function stopWatchingForValueChange() {
    activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
  }
  function handlePropertyChange(nativeEvent) {
    if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
      var dispatchQueue = [];
      createAndAccumulateChangeEvent(dispatchQueue, activeElementInst$1, nativeEvent, getEventTarget(nativeEvent));
      batchedUpdates$1(runEventInBatch, dispatchQueue);
    }
  }
  function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
    "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
  }
  function getTargetInstForInputEventPolyfill(domEventName) {
    if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName) return getInstIfValueChanged(activeElementInst$1);
  }
  function getTargetInstForClickEvent(domEventName, targetInst) {
    if ("click" === domEventName) return getInstIfValueChanged(targetInst);
  }
  function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
    if ("input" === domEventName || "change" === domEventName) return getInstIfValueChanged(targetInst);
  }
  function is(x, y) {
    return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is;
  function shallowEqual(objA, objB) {
    if (objectIs(objA, objB)) return true;
    if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB) return false;
    var keysA = Object.keys(objA),
      keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return false;
    for (keysB = 0; keysB < keysA.length; keysB++) {
      var currentKey = keysA[keysB];
      if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) return false;
    }
    return true;
  }
  function getLeafNode(node) {
    for (; node && node.firstChild;) node = node.firstChild;
    return node;
  }
  function getNodeForCharacterOffset(root, offset) {
    var node = getLeafNode(root);
    root = 0;
    for (var nodeEnd; node;) {
      if (3 === node.nodeType) {
        nodeEnd = root + node.textContent.length;
        if (root <= offset && nodeEnd >= offset) return {
          node: node,
          offset: offset - root
        };
        root = nodeEnd;
      }
      a: {
        for (; node;) {
          if (node.nextSibling) {
            node = node.nextSibling;
            break a;
          }
          node = node.parentNode;
        }
        node = undefined;
      }
      node = getLeafNode(node);
    }
  }
  function containsNode(outerNode, innerNode) {
    return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
  }
  function getActiveElementDeep(containerInfo) {
    containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
    for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement;) {
      try {
        var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
      } catch (err) {
        JSCompiler_inline_result = false;
      }
      if (JSCompiler_inline_result) containerInfo = element.contentWindow;else break;
      element = getActiveElement(containerInfo.document);
    }
    return element;
  }
  function hasSelectionCapabilities(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
  }
  var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode,
    activeElement = null,
    activeElementInst = null,
    lastSelection = null,
    mouseDown = false;
  function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
    var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
    mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = {
      start: doc.selectionStart,
      end: doc.selectionEnd
    } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
      anchorNode: doc.anchorNode,
      anchorOffset: doc.anchorOffset,
      focusNode: doc.focusNode,
      focusOffset: doc.focusOffset
    }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget), dispatchQueue.push({
      event: nativeEvent,
      listeners: doc
    }), nativeEvent.target = activeElement)));
  }
  function makePrefixMap(styleProp, eventName) {
    var prefixes = {};
    prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
    prefixes["Webkit" + styleProp] = "webkit" + eventName;
    prefixes["Moz" + styleProp] = "moz" + eventName;
    return prefixes;
  }
  var vendorPrefixes = {
      animationend: makePrefixMap("Animation", "AnimationEnd"),
      animationiteration: makePrefixMap("Animation", "AnimationIteration"),
      animationstart: makePrefixMap("Animation", "AnimationStart"),
      transitionrun: makePrefixMap("Transition", "TransitionRun"),
      transitionstart: makePrefixMap("Transition", "TransitionStart"),
      transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
      transitionend: makePrefixMap("Transition", "TransitionEnd")
    },
    prefixedEventNames = {},
    style = {};
  canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
  function getVendorPrefixedEventName(eventName) {
    if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
    if (!vendorPrefixes[eventName]) return eventName;
    var prefixMap = vendorPrefixes[eventName],
      styleProp;
    for (styleProp in prefixMap) if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) return prefixedEventNames[eventName] = prefixMap[styleProp];
    return eventName;
  }
  var ANIMATION_END = getVendorPrefixedEventName("animationend"),
    ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),
    ANIMATION_START = getVendorPrefixedEventName("animationstart"),
    TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"),
    TRANSITION_START = getVendorPrefixedEventName("transitionstart"),
    TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"),
    TRANSITION_END = getVendorPrefixedEventName("transitionend"),
    topLevelEventsToReactNames = new Map(),
    simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  simpleEventPluginEvents.push("scrollEnd");
  function registerSimpleEvent(domEventName, reactName) {
    topLevelEventsToReactNames.set(domEventName, reactName);
    registerTwoPhaseEvent(reactName, [domEventName]);
  }
  var CapturedStacks = new WeakMap();
  function createCapturedValueAtFiber(value, source) {
    if ("object" === typeof value && null !== value) {
      var existing = CapturedStacks.get(value);
      if (undefined !== existing) return existing;
      source = {
        value: value,
        source: source,
        stack: getStackByFiberInDevAndProd(source)
      };
      CapturedStacks.set(value, source);
      return source;
    }
    return {
      value: value,
      source: source,
      stack: getStackByFiberInDevAndProd(source)
    };
  }
  var concurrentQueues = [],
    concurrentQueuesIndex = 0,
    concurrentlyUpdatedLanes = 0;
  function finishQueueingConcurrentUpdates() {
    for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex;) {
      var fiber = concurrentQueues[i];
      concurrentQueues[i++] = null;
      var queue = concurrentQueues[i];
      concurrentQueues[i++] = null;
      var update = concurrentQueues[i];
      concurrentQueues[i++] = null;
      var lane = concurrentQueues[i];
      concurrentQueues[i++] = null;
      if (null !== queue && null !== update) {
        var pending = queue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        queue.pending = update;
      }
      0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
    }
  }
  function enqueueUpdate$1(fiber, queue, update, lane) {
    concurrentQueues[concurrentQueuesIndex++] = fiber;
    concurrentQueues[concurrentQueuesIndex++] = queue;
    concurrentQueues[concurrentQueuesIndex++] = update;
    concurrentQueues[concurrentQueuesIndex++] = lane;
    concurrentlyUpdatedLanes |= lane;
    fiber.lanes |= lane;
    fiber = fiber.alternate;
    null !== fiber && (fiber.lanes |= lane);
  }
  function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
    enqueueUpdate$1(fiber, queue, update, lane);
    return getRootForUpdatedFiber(fiber);
  }
  function enqueueConcurrentRenderForLane(fiber, lane) {
    enqueueUpdate$1(fiber, null, null, lane);
    return getRootForUpdatedFiber(fiber);
  }
  function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
    sourceFiber.lanes |= lane;
    var alternate = sourceFiber.alternate;
    null !== alternate && (alternate.lanes |= lane);
    for (var isHidden = false, parent = sourceFiber.return; null !== parent;) parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
    return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
  }
  function getRootForUpdatedFiber(sourceFiber) {
    if (50 < nestedUpdateCount) throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
    for (var parent = sourceFiber.return; null !== parent;) sourceFiber = parent, parent = sourceFiber.return;
    return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
  }
  var emptyContextObject = {};
  function FiberNode(tag, pendingProps, key, mode) {
    this.tag = tag;
    this.key = key;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.refCleanup = this.ref = null;
    this.pendingProps = pendingProps;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = mode;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function createFiberImplClass(tag, pendingProps, key, mode) {
    return new FiberNode(tag, pendingProps, key, mode);
  }
  function shouldConstruct(Component) {
    Component = Component.prototype;
    return !(!Component || !Component.isReactComponent);
  }
  function createWorkInProgress(current, pendingProps) {
    var workInProgress = current.alternate;
    null === workInProgress ? (workInProgress = createFiberImplClass(current.tag, pendingProps, current.key, current.mode), workInProgress.elementType = current.elementType, workInProgress.type = current.type, workInProgress.stateNode = current.stateNode, workInProgress.alternate = current, current.alternate = workInProgress) : (workInProgress.pendingProps = pendingProps, workInProgress.type = current.type, workInProgress.flags = 0, workInProgress.subtreeFlags = 0, workInProgress.deletions = null);
    workInProgress.flags = current.flags & 65011712;
    workInProgress.childLanes = current.childLanes;
    workInProgress.lanes = current.lanes;
    workInProgress.child = current.child;
    workInProgress.memoizedProps = current.memoizedProps;
    workInProgress.memoizedState = current.memoizedState;
    workInProgress.updateQueue = current.updateQueue;
    pendingProps = current.dependencies;
    workInProgress.dependencies = null === pendingProps ? null : {
      lanes: pendingProps.lanes,
      firstContext: pendingProps.firstContext
    };
    workInProgress.sibling = current.sibling;
    workInProgress.index = current.index;
    workInProgress.ref = current.ref;
    workInProgress.refCleanup = current.refCleanup;
    return workInProgress;
  }
  function resetWorkInProgress(workInProgress, renderLanes) {
    workInProgress.flags &= 65011714;
    var current = workInProgress.alternate;
    null === current ? (workInProgress.childLanes = 0, workInProgress.lanes = renderLanes, workInProgress.child = null, workInProgress.subtreeFlags = 0, workInProgress.memoizedProps = null, workInProgress.memoizedState = null, workInProgress.updateQueue = null, workInProgress.dependencies = null, workInProgress.stateNode = null) : (workInProgress.childLanes = current.childLanes, workInProgress.lanes = current.lanes, workInProgress.child = current.child, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.memoizedProps = current.memoizedProps, workInProgress.memoizedState = current.memoizedState, workInProgress.updateQueue = current.updateQueue, workInProgress.type = current.type, renderLanes = current.dependencies, workInProgress.dependencies = null === renderLanes ? null : {
      lanes: renderLanes.lanes,
      firstContext: renderLanes.firstContext
    });
    return workInProgress;
  }
  function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
    var fiberTag = 0;
    owner = type;
    if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);else if ("string" === typeof type) fiberTag = isHostHoistableType(type, pendingProps, contextStackCursor.current) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;else a: switch (type) {
      case REACT_ACTIVITY_TYPE:
        return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
      case REACT_FRAGMENT_TYPE:
        return createFiberFromFragment(pendingProps.children, mode, lanes, key);
      case REACT_STRICT_MODE_TYPE:
        fiberTag = 8;
        mode |= 24;
        break;
      case REACT_PROFILER_TYPE:
        return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
      case REACT_SUSPENSE_TYPE:
        return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
      case REACT_SUSPENSE_LIST_TYPE:
        return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
      default:
        if ("object" === typeof type && null !== type) switch (type.$$typeof) {
          case REACT_PROVIDER_TYPE:
          case REACT_CONTEXT_TYPE:
            fiberTag = 10;
            break a;
          case REACT_CONSUMER_TYPE:
            fiberTag = 9;
            break a;
          case REACT_FORWARD_REF_TYPE:
            fiberTag = 11;
            break a;
          case REACT_MEMO_TYPE:
            fiberTag = 14;
            break a;
          case REACT_LAZY_TYPE:
            fiberTag = 16;
            owner = null;
            break a;
        }
        fiberTag = 29;
        pendingProps = Error(formatProdErrorMessage(130, null === type ? "null" : typeof type, ""));
        owner = null;
    }
    key = createFiberImplClass(fiberTag, pendingProps, key, mode);
    key.elementType = type;
    key.type = owner;
    key.lanes = lanes;
    return key;
  }
  function createFiberFromFragment(elements, mode, lanes, key) {
    elements = createFiberImplClass(7, elements, key, mode);
    elements.lanes = lanes;
    return elements;
  }
  function createFiberFromText(content, mode, lanes) {
    content = createFiberImplClass(6, content, null, mode);
    content.lanes = lanes;
    return content;
  }
  function createFiberFromPortal(portal, mode, lanes) {
    mode = createFiberImplClass(4, null !== portal.children ? portal.children : [], portal.key, mode);
    mode.lanes = lanes;
    mode.stateNode = {
      containerInfo: portal.containerInfo,
      pendingChildren: null,
      implementation: portal.implementation
    };
    return mode;
  }
  var forkStack = [],
    forkStackIndex = 0,
    treeForkProvider = null,
    treeForkCount = 0,
    idStack = [],
    idStackIndex = 0,
    treeContextProvider = null,
    treeContextId = 1,
    treeContextOverflow = "";
  function pushTreeFork(workInProgress, totalChildren) {
    forkStack[forkStackIndex++] = treeForkCount;
    forkStack[forkStackIndex++] = treeForkProvider;
    treeForkProvider = workInProgress;
    treeForkCount = totalChildren;
  }
  function pushTreeId(workInProgress, totalChildren, index) {
    idStack[idStackIndex++] = treeContextId;
    idStack[idStackIndex++] = treeContextOverflow;
    idStack[idStackIndex++] = treeContextProvider;
    treeContextProvider = workInProgress;
    var baseIdWithLeadingBit = treeContextId;
    workInProgress = treeContextOverflow;
    var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
    baseIdWithLeadingBit &= ~(1 << baseLength);
    index += 1;
    var length = 32 - clz32(totalChildren) + baseLength;
    if (30 < length) {
      var numberOfOverflowBits = baseLength - baseLength % 5;
      length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
      baseIdWithLeadingBit >>= numberOfOverflowBits;
      baseLength -= numberOfOverflowBits;
      treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
      treeContextOverflow = length + workInProgress;
    } else treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress;
  }
  function pushMaterializedTreeId(workInProgress) {
    null !== workInProgress.return && (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
  }
  function popTreeContext(workInProgress) {
    for (; workInProgress === treeForkProvider;) treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
    for (; workInProgress === treeContextProvider;) treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
  }
  var hydrationParentFiber = null,
    nextHydratableInstance = null,
    isHydrating = false,
    hydrationErrors = null,
    rootOrSingletonContext = false,
    HydrationMismatchException = Error(formatProdErrorMessage(519));
  function throwOnHydrationMismatch(fiber) {
    var error = Error(formatProdErrorMessage(418, ""));
    queueHydrationError(createCapturedValueAtFiber(error, fiber));
    throw HydrationMismatchException;
  }
  function prepareToHydrateHostInstance(fiber) {
    var instance = fiber.stateNode,
      type = fiber.type,
      props = fiber.memoizedProps;
    instance[internalInstanceKey] = fiber;
    instance[internalPropsKey] = props;
    switch (type) {
      case "dialog":
        listenToNonDelegatedEvent("cancel", instance);
        listenToNonDelegatedEvent("close", instance);
        break;
      case "iframe":
      case "object":
      case "embed":
        listenToNonDelegatedEvent("load", instance);
        break;
      case "video":
      case "audio":
        for (type = 0; type < mediaEventTypes.length; type++) listenToNonDelegatedEvent(mediaEventTypes[type], instance);
        break;
      case "source":
        listenToNonDelegatedEvent("error", instance);
        break;
      case "img":
      case "image":
      case "link":
        listenToNonDelegatedEvent("error", instance);
        listenToNonDelegatedEvent("load", instance);
        break;
      case "details":
        listenToNonDelegatedEvent("toggle", instance);
        break;
      case "input":
        listenToNonDelegatedEvent("invalid", instance);
        initInput(instance, props.value, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name, true);
        track(instance);
        break;
      case "select":
        listenToNonDelegatedEvent("invalid", instance);
        break;
      case "textarea":
        listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children), track(instance);
    }
    type = props.children;
    "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1), instance = true) : instance = false;
    instance || throwOnHydrationMismatch(fiber);
  }
  function popToNextHostParent(fiber) {
    for (hydrationParentFiber = fiber.return; hydrationParentFiber;) switch (hydrationParentFiber.tag) {
      case 5:
      case 13:
        rootOrSingletonContext = false;
        return;
      case 27:
      case 3:
        rootOrSingletonContext = true;
        return;
      default:
        hydrationParentFiber = hydrationParentFiber.return;
    }
  }
  function popHydrationState(fiber) {
    if (fiber !== hydrationParentFiber) return false;
    if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
    var tag = fiber.tag,
      JSCompiler_temp;
    if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
      if (JSCompiler_temp = 5 === tag) JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
      JSCompiler_temp = !JSCompiler_temp;
    }
    JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
    popToNextHostParent(fiber);
    if (13 === tag) {
      fiber = fiber.memoizedState;
      fiber = null !== fiber ? fiber.dehydrated : null;
      if (!fiber) throw Error(formatProdErrorMessage(317));
      a: {
        fiber = fiber.nextSibling;
        for (tag = 0; fiber;) {
          if (8 === fiber.nodeType) if (JSCompiler_temp = fiber.data, "/$" === JSCompiler_temp) {
            if (0 === tag) {
              nextHydratableInstance = getNextHydratable(fiber.nextSibling);
              break a;
            }
            tag--;
          } else "$" !== JSCompiler_temp && "$!" !== JSCompiler_temp && "$?" !== JSCompiler_temp || tag++;
          fiber = fiber.nextSibling;
        }
        nextHydratableInstance = null;
      }
    } else 27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
    return true;
  }
  function resetHydrationState() {
    nextHydratableInstance = hydrationParentFiber = null;
    isHydrating = false;
  }
  function upgradeHydrationErrorsToRecoverable() {
    var queuedErrors = hydrationErrors;
    null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, queuedErrors), hydrationErrors = null);
    return queuedErrors;
  }
  function queueHydrationError(error) {
    null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
  }
  var valueCursor = createCursor(null),
    currentlyRenderingFiber$1 = null,
    lastContextDependency = null;
  function pushProvider(providerFiber, context, nextValue) {
    push(valueCursor, context._currentValue);
    context._currentValue = nextValue;
  }
  function popProvider(context) {
    context._currentValue = valueCursor.current;
    pop(valueCursor);
  }
  function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
    for (; null !== parent;) {
      var alternate = parent.alternate;
      (parent.childLanes & renderLanes) !== renderLanes ? (parent.childLanes |= renderLanes, null !== alternate && (alternate.childLanes |= renderLanes)) : null !== alternate && (alternate.childLanes & renderLanes) !== renderLanes && (alternate.childLanes |= renderLanes);
      if (parent === propagationRoot) break;
      parent = parent.return;
    }
  }
  function propagateContextChanges(workInProgress, contexts, renderLanes, forcePropagateEntireTree) {
    var fiber = workInProgress.child;
    null !== fiber && (fiber.return = workInProgress);
    for (; null !== fiber;) {
      var list = fiber.dependencies;
      if (null !== list) {
        var nextFiber = fiber.child;
        list = list.firstContext;
        a: for (; null !== list;) {
          var dependency = list;
          list = fiber;
          for (var i = 0; i < contexts.length; i++) if (dependency.context === contexts[i]) {
            list.lanes |= renderLanes;
            dependency = list.alternate;
            null !== dependency && (dependency.lanes |= renderLanes);
            scheduleContextWorkOnParentPath(list.return, renderLanes, workInProgress);
            forcePropagateEntireTree || (nextFiber = null);
            break a;
          }
          list = dependency.next;
        }
      } else if (18 === fiber.tag) {
        nextFiber = fiber.return;
        if (null === nextFiber) throw Error(formatProdErrorMessage(341));
        nextFiber.lanes |= renderLanes;
        list = nextFiber.alternate;
        null !== list && (list.lanes |= renderLanes);
        scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);
        nextFiber = null;
      } else nextFiber = fiber.child;
      if (null !== nextFiber) nextFiber.return = fiber;else for (nextFiber = fiber; null !== nextFiber;) {
        if (nextFiber === workInProgress) {
          nextFiber = null;
          break;
        }
        fiber = nextFiber.sibling;
        if (null !== fiber) {
          fiber.return = nextFiber.return;
          nextFiber = fiber;
          break;
        }
        nextFiber = nextFiber.return;
      }
      fiber = nextFiber;
    }
  }
  function propagateParentContextChanges(current, workInProgress, renderLanes, forcePropagateEntireTree) {
    current = null;
    for (var parent = workInProgress, isInsidePropagationBailout = false; null !== parent;) {
      if (!isInsidePropagationBailout) if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;else if (0 !== (parent.flags & 262144)) break;
      if (10 === parent.tag) {
        var currentParent = parent.alternate;
        if (null === currentParent) throw Error(formatProdErrorMessage(387));
        currentParent = currentParent.memoizedProps;
        if (null !== currentParent) {
          var context = parent.type;
          objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
        }
      } else if (parent === hostTransitionProviderCursor.current) {
        currentParent = parent.alternate;
        if (null === currentParent) throw Error(formatProdErrorMessage(387));
        currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
      }
      parent = parent.return;
    }
    null !== current && propagateContextChanges(workInProgress, current, renderLanes, forcePropagateEntireTree);
    workInProgress.flags |= 262144;
  }
  function checkIfContextChanged(currentDependencies) {
    for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies;) {
      if (!objectIs(currentDependencies.context._currentValue, currentDependencies.memoizedValue)) return true;
      currentDependencies = currentDependencies.next;
    }
    return false;
  }
  function prepareToReadContext(workInProgress) {
    currentlyRenderingFiber$1 = workInProgress;
    lastContextDependency = null;
    workInProgress = workInProgress.dependencies;
    null !== workInProgress && (workInProgress.firstContext = null);
  }
  function readContext(context) {
    return readContextForConsumer(currentlyRenderingFiber$1, context);
  }
  function readContextDuringReconciliation(consumer, context) {
    null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
    return readContextForConsumer(consumer, context);
  }
  function readContextForConsumer(consumer, context) {
    var value = context._currentValue;
    context = {
      context: context,
      memoizedValue: value,
      next: null
    };
    if (null === lastContextDependency) {
      if (null === consumer) throw Error(formatProdErrorMessage(308));
      lastContextDependency = context;
      consumer.dependencies = {
        lanes: 0,
        firstContext: context
      };
      consumer.flags |= 524288;
    } else lastContextDependency = lastContextDependency.next = context;
    return value;
  }
  var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function () {
      var listeners = [],
        signal = this.signal = {
          aborted: false,
          addEventListener: function (type, listener) {
            listeners.push(listener);
          }
        };
      this.abort = function () {
        signal.aborted = true;
        listeners.forEach(function (listener) {
          return listener();
        });
      };
    },
    scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
    NormalPriority = Scheduler.unstable_NormalPriority,
    CacheContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0
    };
  function createCache() {
    return {
      controller: new AbortControllerLocal(),
      data: new Map(),
      refCount: 0
    };
  }
  function releaseCache(cache) {
    cache.refCount--;
    0 === cache.refCount && scheduleCallback$2(NormalPriority, function () {
      cache.controller.abort();
    });
  }
  var currentEntangledListeners = null,
    currentEntangledPendingCount = 0,
    currentEntangledLane = 0,
    currentEntangledActionThenable = null;
  function entangleAsyncAction(transition, thenable) {
    if (null === currentEntangledListeners) {
      var entangledListeners = currentEntangledListeners = [];
      currentEntangledPendingCount = 0;
      currentEntangledLane = requestTransitionLane();
      currentEntangledActionThenable = {
        status: "pending",
        value: undefined,
        then: function (resolve) {
          entangledListeners.push(resolve);
        }
      };
    }
    currentEntangledPendingCount++;
    thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
    return thenable;
  }
  function pingEngtangledActionScope() {
    if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
      null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
      var listeners = currentEntangledListeners;
      currentEntangledListeners = null;
      currentEntangledLane = 0;
      currentEntangledActionThenable = null;
      for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
    }
  }
  function chainThenableValue(thenable, result) {
    var listeners = [],
      thenableWithOverride = {
        status: "pending",
        value: null,
        reason: null,
        then: function (resolve) {
          listeners.push(resolve);
        }
      };
    thenable.then(function () {
      thenableWithOverride.status = "fulfilled";
      thenableWithOverride.value = result;
      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
    }, function (error) {
      thenableWithOverride.status = "rejected";
      thenableWithOverride.reason = error;
      for (error = 0; error < listeners.length; error++) (0, listeners[error])(undefined);
    });
    return thenableWithOverride;
  }
  var prevOnStartTransitionFinish = ReactSharedInternals.S;
  ReactSharedInternals.S = function (transition, returnValue) {
    "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
    null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
  };
  var resumedCache = createCursor(null);
  function peekCacheFromPool() {
    var cacheResumedFromPreviousRender = resumedCache.current;
    return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
  }
  function pushTransition(offscreenWorkInProgress, prevCachePool) {
    null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
  }
  function getSuspendedCache() {
    var cacheFromPool = peekCacheFromPool();
    return null === cacheFromPool ? null : {
      parent: CacheContext._currentValue,
      pool: cacheFromPool
    };
  }
  var SuspenseException = Error(formatProdErrorMessage(460)),
    SuspenseyCommitException = Error(formatProdErrorMessage(474)),
    SuspenseActionException = Error(formatProdErrorMessage(542)),
    noopSuspenseyCommitThenable = {
      then: function () {}
    };
  function isThenableResolved(thenable) {
    thenable = thenable.status;
    return "fulfilled" === thenable || "rejected" === thenable;
  }
  function noop$3() {}
  function trackUsedThenable(thenableState, thenable, index) {
    index = thenableState[index];
    undefined === index ? thenableState.push(thenable) : index !== thenable && (thenable.then(noop$3, noop$3), thenable = index);
    switch (thenable.status) {
      case "fulfilled":
        return thenable.value;
      case "rejected":
        throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;
      default:
        if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);else {
          thenableState = workInProgressRoot;
          if (null !== thenableState && 100 < thenableState.shellSuspendCounter) throw Error(formatProdErrorMessage(482));
          thenableState = thenable;
          thenableState.status = "pending";
          thenableState.then(function (fulfilledValue) {
            if ("pending" === thenable.status) {
              var fulfilledThenable = thenable;
              fulfilledThenable.status = "fulfilled";
              fulfilledThenable.value = fulfilledValue;
            }
          }, function (error) {
            if ("pending" === thenable.status) {
              var rejectedThenable = thenable;
              rejectedThenable.status = "rejected";
              rejectedThenable.reason = error;
            }
          });
        }
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;
        }
        suspendedThenable = thenable;
        throw SuspenseException;
    }
  }
  var suspendedThenable = null;
  function getSuspendedThenable() {
    if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
    var thenable = suspendedThenable;
    suspendedThenable = null;
    return thenable;
  }
  function checkIfUseWrappedInAsyncCatch(rejectedReason) {
    if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException) throw Error(formatProdErrorMessage(483));
  }
  var hasForceUpdate = false;
  function initializeUpdateQueue(fiber) {
    fiber.updateQueue = {
      baseState: fiber.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: {
        pending: null,
        lanes: 0,
        hiddenCallbacks: null
      },
      callbacks: null
    };
  }
  function cloneUpdateQueue(current, workInProgress) {
    current = current.updateQueue;
    workInProgress.updateQueue === current && (workInProgress.updateQueue = {
      baseState: current.baseState,
      firstBaseUpdate: current.firstBaseUpdate,
      lastBaseUpdate: current.lastBaseUpdate,
      shared: current.shared,
      callbacks: null
    });
  }
  function createUpdate(lane) {
    return {
      lane: lane,
      tag: 0,
      payload: null,
      callback: null,
      next: null
    };
  }
  function enqueueUpdate(fiber, update, lane) {
    var updateQueue = fiber.updateQueue;
    if (null === updateQueue) return null;
    updateQueue = updateQueue.shared;
    if (0 !== (executionContext & 2)) {
      var pending = updateQueue.pending;
      null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
      updateQueue.pending = update;
      update = getRootForUpdatedFiber(fiber);
      markUpdateLaneFromFiberToRoot(fiber, null, lane);
      return update;
    }
    enqueueUpdate$1(fiber, updateQueue, update, lane);
    return getRootForUpdatedFiber(fiber);
  }
  function entangleTransitions(root, fiber, lane) {
    fiber = fiber.updateQueue;
    if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
      var queueLanes = fiber.lanes;
      queueLanes &= root.pendingLanes;
      lane |= queueLanes;
      fiber.lanes = lane;
      markRootEntangled(root, lane);
    }
  }
  function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
    var queue = workInProgress.updateQueue,
      current = workInProgress.alternate;
    if (null !== current && (current = current.updateQueue, queue === current)) {
      var newFirst = null,
        newLast = null;
      queue = queue.firstBaseUpdate;
      if (null !== queue) {
        do {
          var clone = {
            lane: queue.lane,
            tag: queue.tag,
            payload: queue.payload,
            callback: null,
            next: null
          };
          null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
          queue = queue.next;
        } while (null !== queue);
        null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
      } else newFirst = newLast = capturedUpdate;
      queue = {
        baseState: current.baseState,
        firstBaseUpdate: newFirst,
        lastBaseUpdate: newLast,
        shared: current.shared,
        callbacks: current.callbacks
      };
      workInProgress.updateQueue = queue;
      return;
    }
    workInProgress = queue.lastBaseUpdate;
    null === workInProgress ? queue.firstBaseUpdate = capturedUpdate : workInProgress.next = capturedUpdate;
    queue.lastBaseUpdate = capturedUpdate;
  }
  var didReadFromEntangledAsyncAction = false;
  function suspendIfUpdateReadFromEntangledAsyncAction() {
    if (didReadFromEntangledAsyncAction) {
      var entangledActionThenable = currentEntangledActionThenable;
      if (null !== entangledActionThenable) throw entangledActionThenable;
    }
  }
  function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes) {
    didReadFromEntangledAsyncAction = false;
    var queue = workInProgress$jscomp$0.updateQueue;
    hasForceUpdate = false;
    var firstBaseUpdate = queue.firstBaseUpdate,
      lastBaseUpdate = queue.lastBaseUpdate,
      pendingQueue = queue.shared.pending;
    if (null !== pendingQueue) {
      queue.shared.pending = null;
      var lastPendingUpdate = pendingQueue,
        firstPendingUpdate = lastPendingUpdate.next;
      lastPendingUpdate.next = null;
      null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
      lastBaseUpdate = lastPendingUpdate;
      var current = workInProgress$jscomp$0.alternate;
      null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
    }
    if (null !== firstBaseUpdate) {
      var newState = queue.baseState;
      lastBaseUpdate = 0;
      current = firstPendingUpdate = lastPendingUpdate = null;
      pendingQueue = firstBaseUpdate;
      do {
        var updateLane = pendingQueue.lane & -536870913,
          isHiddenUpdate = updateLane !== pendingQueue.lane;
        if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
          0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
          null !== current && (current = current.next = {
            lane: 0,
            tag: pendingQueue.tag,
            payload: pendingQueue.payload,
            callback: null,
            next: null
          });
          a: {
            var workInProgress = workInProgress$jscomp$0,
              update = pendingQueue;
            updateLane = props;
            var instance = instance$jscomp$0;
            switch (update.tag) {
              case 1:
                workInProgress = update.payload;
                if ("function" === typeof workInProgress) {
                  newState = workInProgress.call(instance, newState, updateLane);
                  break a;
                }
                newState = workInProgress;
                break a;
              case 3:
                workInProgress.flags = workInProgress.flags & -65537 | 128;
              case 0:
                workInProgress = update.payload;
                updateLane = "function" === typeof workInProgress ? workInProgress.call(instance, newState, updateLane) : workInProgress;
                if (null === updateLane || undefined === updateLane) break a;
                newState = assign({}, newState, updateLane);
                break a;
              case 2:
                hasForceUpdate = true;
            }
          }
          updateLane = pendingQueue.callback;
          null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
        } else isHiddenUpdate = {
          lane: updateLane,
          tag: pendingQueue.tag,
          payload: pendingQueue.payload,
          callback: pendingQueue.callback,
          next: null
        }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
        pendingQueue = pendingQueue.next;
        if (null === pendingQueue) if (pendingQueue = queue.shared.pending, null === pendingQueue) break;else isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
      } while (1);
      null === current && (lastPendingUpdate = newState);
      queue.baseState = lastPendingUpdate;
      queue.firstBaseUpdate = firstPendingUpdate;
      queue.lastBaseUpdate = current;
      null === firstBaseUpdate && (queue.shared.lanes = 0);
      workInProgressRootSkippedLanes |= lastBaseUpdate;
      workInProgress$jscomp$0.lanes = lastBaseUpdate;
      workInProgress$jscomp$0.memoizedState = newState;
    }
  }
  function callCallback(callback, context) {
    if ("function" !== typeof callback) throw Error(formatProdErrorMessage(191, callback));
    callback.call(context);
  }
  function commitCallbacks(updateQueue, context) {
    var callbacks = updateQueue.callbacks;
    if (null !== callbacks) for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++) callCallback(callbacks[updateQueue], context);
  }
  var currentTreeHiddenStackCursor = createCursor(null),
    prevEntangledRenderLanesCursor = createCursor(0);
  function pushHiddenContext(fiber, context) {
    fiber = entangledRenderLanes;
    push(prevEntangledRenderLanesCursor, fiber);
    push(currentTreeHiddenStackCursor, context);
    entangledRenderLanes = fiber | context.baseLanes;
  }
  function reuseHiddenContextOnStack() {
    push(prevEntangledRenderLanesCursor, entangledRenderLanes);
    push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
  }
  function popHiddenContext() {
    entangledRenderLanes = prevEntangledRenderLanesCursor.current;
    pop(currentTreeHiddenStackCursor);
    pop(prevEntangledRenderLanesCursor);
  }
  var renderLanes = 0,
    currentlyRenderingFiber = null,
    currentHook = null,
    workInProgressHook = null,
    didScheduleRenderPhaseUpdate = false,
    didScheduleRenderPhaseUpdateDuringThisPass = false,
    shouldDoubleInvokeUserFnsInHooksDEV = false,
    localIdCounter = 0,
    thenableIndexCounter$1 = 0,
    thenableState$1 = null,
    globalClientIdCounter = 0;
  function throwInvalidHookError() {
    throw Error(formatProdErrorMessage(321));
  }
  function areHookInputsEqual(nextDeps, prevDeps) {
    if (null === prevDeps) return false;
    for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) if (!objectIs(nextDeps[i], prevDeps[i])) return false;
    return true;
  }
  function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {
    renderLanes = nextRenderLanes;
    currentlyRenderingFiber = workInProgress;
    workInProgress.memoizedState = null;
    workInProgress.updateQueue = null;
    workInProgress.lanes = 0;
    ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
    shouldDoubleInvokeUserFnsInHooksDEV = false;
    nextRenderLanes = Component(props, secondArg);
    shouldDoubleInvokeUserFnsInHooksDEV = false;
    didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(workInProgress, Component, props, secondArg));
    finishRenderingHooks(current);
    return nextRenderLanes;
  }
  function finishRenderingHooks(current) {
    ReactSharedInternals.H = ContextOnlyDispatcher;
    var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
    renderLanes = 0;
    workInProgressHook = currentHook = currentlyRenderingFiber = null;
    didScheduleRenderPhaseUpdate = false;
    thenableIndexCounter$1 = 0;
    thenableState$1 = null;
    if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
    null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
  }
  function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
    currentlyRenderingFiber = workInProgress;
    var numberOfReRenders = 0;
    do {
      didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
      thenableIndexCounter$1 = 0;
      didScheduleRenderPhaseUpdateDuringThisPass = false;
      if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
      numberOfReRenders += 1;
      workInProgressHook = currentHook = null;
      if (null != workInProgress.updateQueue) {
        var children = workInProgress.updateQueue;
        children.lastEffect = null;
        children.events = null;
        children.stores = null;
        null != children.memoCache && (children.memoCache.index = 0);
      }
      ReactSharedInternals.H = HooksDispatcherOnRerender;
      children = Component(props, secondArg);
    } while (didScheduleRenderPhaseUpdateDuringThisPass);
    return children;
  }
  function TransitionAwareHostComponent() {
    var dispatcher = ReactSharedInternals.H,
      maybeThenable = dispatcher.useState()[0];
    maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
    dispatcher = dispatcher.useState()[0];
    (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
    return maybeThenable;
  }
  function checkDidRenderIdHook() {
    var didRenderIdHook = 0 !== localIdCounter;
    localIdCounter = 0;
    return didRenderIdHook;
  }
  function bailoutHooks(current, workInProgress, lanes) {
    workInProgress.updateQueue = current.updateQueue;
    workInProgress.flags &= -2053;
    current.lanes &= ~lanes;
  }
  function resetHooksOnUnwind(workInProgress) {
    if (didScheduleRenderPhaseUpdate) {
      for (workInProgress = workInProgress.memoizedState; null !== workInProgress;) {
        var queue = workInProgress.queue;
        null !== queue && (queue.pending = null);
        workInProgress = workInProgress.next;
      }
      didScheduleRenderPhaseUpdate = false;
    }
    renderLanes = 0;
    workInProgressHook = currentHook = currentlyRenderingFiber = null;
    didScheduleRenderPhaseUpdateDuringThisPass = false;
    thenableIndexCounter$1 = localIdCounter = 0;
    thenableState$1 = null;
  }
  function mountWorkInProgressHook() {
    var hook = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
    return workInProgressHook;
  }
  function updateWorkInProgressHook() {
    if (null === currentHook) {
      var nextCurrentHook = currentlyRenderingFiber.alternate;
      nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
    } else nextCurrentHook = currentHook.next;
    var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
    if (null !== nextWorkInProgressHook) workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;else {
      if (null === nextCurrentHook) {
        if (null === currentlyRenderingFiber.alternate) throw Error(formatProdErrorMessage(467));
        throw Error(formatProdErrorMessage(310));
      }
      currentHook = nextCurrentHook;
      nextCurrentHook = {
        memoizedState: currentHook.memoizedState,
        baseState: currentHook.baseState,
        baseQueue: currentHook.baseQueue,
        queue: currentHook.queue,
        next: null
      };
      null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
    }
    return workInProgressHook;
  }
  function createFunctionComponentUpdateQueue() {
    return {
      lastEffect: null,
      events: null,
      stores: null,
      memoCache: null
    };
  }
  function useThenable(thenable) {
    var index = thenableIndexCounter$1;
    thenableIndexCounter$1 += 1;
    null === thenableState$1 && (thenableState$1 = []);
    thenable = trackUsedThenable(thenableState$1, thenable, index);
    index = currentlyRenderingFiber;
    null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null === index || null === index.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
    return thenable;
  }
  function use(usable) {
    if (null !== usable && "object" === typeof usable) {
      if ("function" === typeof usable.then) return useThenable(usable);
      if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
    }
    throw Error(formatProdErrorMessage(438, String(usable)));
  }
  function useMemoCache(size) {
    var memoCache = null,
      updateQueue = currentlyRenderingFiber.updateQueue;
    null !== updateQueue && (memoCache = updateQueue.memoCache);
    if (null == memoCache) {
      var current = currentlyRenderingFiber.alternate;
      null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
        data: current.data.map(function (array) {
          return array.slice();
        }),
        index: 0
      })));
    }
    null == memoCache && (memoCache = {
      data: [],
      index: 0
    });
    null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
    updateQueue.memoCache = memoCache;
    updateQueue = memoCache.data[memoCache.index];
    if (undefined === updateQueue) for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++) updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
    memoCache.index++;
    return updateQueue;
  }
  function basicStateReducer(state, action) {
    return "function" === typeof action ? action(state) : action;
  }
  function updateReducer(reducer) {
    var hook = updateWorkInProgressHook();
    return updateReducerImpl(hook, currentHook, reducer);
  }
  function updateReducerImpl(hook, current, reducer) {
    var queue = hook.queue;
    if (null === queue) throw Error(formatProdErrorMessage(311));
    queue.lastRenderedReducer = reducer;
    var baseQueue = hook.baseQueue,
      pendingQueue = queue.pending;
    if (null !== pendingQueue) {
      if (null !== baseQueue) {
        var baseFirst = baseQueue.next;
        baseQueue.next = pendingQueue.next;
        pendingQueue.next = baseFirst;
      }
      current.baseQueue = baseQueue = pendingQueue;
      queue.pending = null;
    }
    pendingQueue = hook.baseState;
    if (null === baseQueue) hook.memoizedState = pendingQueue;else {
      current = baseQueue.next;
      var newBaseQueueFirst = baseFirst = null,
        newBaseQueueLast = null,
        update = current,
        didReadFromEntangledAsyncAction$32 = false;
      do {
        var updateLane = update.lane & -536870913;
        if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
          var revertLane = update.revertLane;
          if (0 === revertLane) null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
            lane: 0,
            revertLane: 0,
            action: update.action,
            hasEagerState: update.hasEagerState,
            eagerState: update.eagerState,
            next: null
          }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);else if ((renderLanes & revertLane) === revertLane) {
            update = update.next;
            revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
            continue;
          } else updateLane = {
            lane: 0,
            revertLane: update.revertLane,
            action: update.action,
            hasEagerState: update.hasEagerState,
            eagerState: update.eagerState,
            next: null
          }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
          updateLane = update.action;
          shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
          pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
        } else revertLane = {
          lane: updateLane,
          revertLane: update.revertLane,
          action: update.action,
          hasEagerState: update.hasEagerState,
          eagerState: update.eagerState,
          next: null
        }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
        update = update.next;
      } while (null !== update && update !== current);
      null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
      if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$32 && (reducer = currentEntangledActionThenable, null !== reducer))) throw reducer;
      hook.memoizedState = pendingQueue;
      hook.baseState = baseFirst;
      hook.baseQueue = newBaseQueueLast;
      queue.lastRenderedState = pendingQueue;
    }
    null === baseQueue && (queue.lanes = 0);
    return [hook.memoizedState, queue.dispatch];
  }
  function rerenderReducer(reducer) {
    var hook = updateWorkInProgressHook(),
      queue = hook.queue;
    if (null === queue) throw Error(formatProdErrorMessage(311));
    queue.lastRenderedReducer = reducer;
    var dispatch = queue.dispatch,
      lastRenderPhaseUpdate = queue.pending,
      newState = hook.memoizedState;
    if (null !== lastRenderPhaseUpdate) {
      queue.pending = null;
      var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
      do newState = reducer(newState, update.action), update = update.next; while (update !== lastRenderPhaseUpdate);
      objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
      hook.memoizedState = newState;
      null === hook.baseQueue && (hook.baseState = newState);
      queue.lastRenderedState = newState;
    }
    return [newState, dispatch];
  }
  function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
    var fiber = currentlyRenderingFiber,
      hook = updateWorkInProgressHook(),
      isHydrating$jscomp$0 = isHydrating;
    if (isHydrating$jscomp$0) {
      if (undefined === getServerSnapshot) throw Error(formatProdErrorMessage(407));
      getServerSnapshot = getServerSnapshot();
    } else getServerSnapshot = getSnapshot();
    var snapshotChanged = !objectIs((currentHook || hook).memoizedState, getServerSnapshot);
    snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
    hook = hook.queue;
    var create = subscribeToStore.bind(null, fiber, hook, subscribe);
    updateEffectImpl(2048, 8, create, [subscribe]);
    if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
      fiber.flags |= 2048;
      pushSimpleEffect(9, createEffectInstance(), updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), null);
      if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
      isHydrating$jscomp$0 || 0 !== (renderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
    }
    return getServerSnapshot;
  }
  function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
    fiber.flags |= 16384;
    fiber = {
      getSnapshot: getSnapshot,
      value: renderedSnapshot
    };
    getSnapshot = currentlyRenderingFiber.updateQueue;
    null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
  }
  function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
    inst.value = nextSnapshot;
    inst.getSnapshot = getSnapshot;
    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
  }
  function subscribeToStore(fiber, inst, subscribe) {
    return subscribe(function () {
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    });
  }
  function checkIfSnapshotChanged(inst) {
    var latestGetSnapshot = inst.getSnapshot;
    inst = inst.value;
    try {
      var nextValue = latestGetSnapshot();
      return !objectIs(inst, nextValue);
    } catch (error) {
      return true;
    }
  }
  function forceStoreRerender(fiber) {
    var root = enqueueConcurrentRenderForLane(fiber, 2);
    null !== root && scheduleUpdateOnFiber(root, fiber, 2);
  }
  function mountStateImpl(initialState) {
    var hook = mountWorkInProgressHook();
    if ("function" === typeof initialState) {
      var initialStateInitializer = initialState;
      initialState = initialStateInitializer();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          initialStateInitializer();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
    }
    hook.memoizedState = hook.baseState = initialState;
    hook.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: initialState
    };
    return hook;
  }
  function updateOptimisticImpl(hook, current, passthrough, reducer) {
    hook.baseState = passthrough;
    return updateReducerImpl(hook, currentHook, "function" === typeof reducer ? reducer : basicStateReducer);
  }
  function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
    if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
    fiber = actionQueue.action;
    if (null !== fiber) {
      var actionNode = {
        payload: payload,
        action: fiber,
        next: null,
        isTransition: true,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function (listener) {
          actionNode.listeners.push(listener);
        }
      };
      null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
      setState(actionNode);
      setPendingState = actionQueue.pending;
      null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
    }
  }
  function runActionStateAction(actionQueue, node) {
    var action = node.action,
      payload = node.payload,
      prevState = actionQueue.state;
    if (node.isTransition) {
      var prevTransition = ReactSharedInternals.T,
        currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = action(prevState, payload),
          onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        handleActionReturnValue(actionQueue, node, returnValue);
      } catch (error) {
        onActionError(actionQueue, node, error);
      } finally {
        ReactSharedInternals.T = prevTransition;
      }
    } else try {
      prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
    } catch (error$38) {
      onActionError(actionQueue, node, error$38);
    }
  }
  function handleActionReturnValue(actionQueue, node, returnValue) {
    null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(function (nextState) {
      onActionSuccess(actionQueue, node, nextState);
    }, function (error) {
      return onActionError(actionQueue, node, error);
    }) : onActionSuccess(actionQueue, node, returnValue);
  }
  function onActionSuccess(actionQueue, actionNode, nextState) {
    actionNode.status = "fulfilled";
    actionNode.value = nextState;
    notifyActionListeners(actionNode);
    actionQueue.state = nextState;
    actionNode = actionQueue.pending;
    null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
  }
  function onActionError(actionQueue, actionNode, error) {
    var last = actionQueue.pending;
    actionQueue.pending = null;
    if (null !== last) {
      last = last.next;
      do actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next; while (actionNode !== last);
    }
    actionQueue.action = null;
  }
  function notifyActionListeners(actionNode) {
    actionNode = actionNode.listeners;
    for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
  }
  function actionStateReducer(oldState, newState) {
    return newState;
  }
  function mountActionState(action, initialStateProp) {
    if (isHydrating) {
      var ssrFormState = workInProgressRoot.formState;
      if (null !== ssrFormState) {
        a: {
          var JSCompiler_inline_result = currentlyRenderingFiber;
          if (isHydrating) {
            if (nextHydratableInstance) {
              b: {
                var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType;) {
                  if (!inRootOrSingleton) {
                    JSCompiler_inline_result$jscomp$0 = null;
                    break b;
                  }
                  JSCompiler_inline_result$jscomp$0 = getNextHydratable(JSCompiler_inline_result$jscomp$0.nextSibling);
                  if (null === JSCompiler_inline_result$jscomp$0) {
                    JSCompiler_inline_result$jscomp$0 = null;
                    break b;
                  }
                }
                inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
              }
              if (JSCompiler_inline_result$jscomp$0) {
                nextHydratableInstance = getNextHydratable(JSCompiler_inline_result$jscomp$0.nextSibling);
                JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                break a;
              }
            }
            throwOnHydrationMismatch(JSCompiler_inline_result);
          }
          JSCompiler_inline_result = false;
        }
        JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
      }
    }
    ssrFormState = mountWorkInProgressHook();
    ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
    JSCompiler_inline_result = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: actionStateReducer,
      lastRenderedState: initialStateProp
    };
    ssrFormState.queue = JSCompiler_inline_result;
    ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber, JSCompiler_inline_result);
    JSCompiler_inline_result.dispatch = ssrFormState;
    JSCompiler_inline_result = mountStateImpl(false);
    inRootOrSingleton = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, false, JSCompiler_inline_result.queue);
    JSCompiler_inline_result = mountWorkInProgressHook();
    JSCompiler_inline_result$jscomp$0 = {
      state: initialStateProp,
      dispatch: null,
      action: action,
      pending: null
    };
    JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
    ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber, JSCompiler_inline_result$jscomp$0, inRootOrSingleton, ssrFormState);
    JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
    JSCompiler_inline_result.memoizedState = action;
    return [initialStateProp, ssrFormState, false];
  }
  function updateActionState(action) {
    var stateHook = updateWorkInProgressHook();
    return updateActionStateImpl(stateHook, currentHook, action);
  }
  function updateActionStateImpl(stateHook, currentStateHook, action) {
    currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];
    stateHook = updateReducer(basicStateReducer)[0];
    if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then) try {
      var state = useThenable(currentStateHook);
    } catch (x) {
      if (x === SuspenseException) throw SuspenseActionException;
      throw x;
    } else state = currentStateHook;
    currentStateHook = updateWorkInProgressHook();
    var actionQueue = currentStateHook.queue,
      dispatch = actionQueue.dispatch;
    action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(9, createEffectInstance(), actionStateActionEffect.bind(null, actionQueue, action), null));
    return [state, dispatch, stateHook];
  }
  function actionStateActionEffect(actionQueue, action) {
    actionQueue.action = action;
  }
  function rerenderActionState(action) {
    var stateHook = updateWorkInProgressHook(),
      currentStateHook = currentHook;
    if (null !== currentStateHook) return updateActionStateImpl(stateHook, currentStateHook, action);
    updateWorkInProgressHook();
    stateHook = stateHook.memoizedState;
    currentStateHook = updateWorkInProgressHook();
    var dispatch = currentStateHook.queue.dispatch;
    currentStateHook.memoizedState = action;
    return [stateHook, dispatch, false];
  }
  function pushSimpleEffect(tag, inst, create, createDeps) {
    tag = {
      tag: tag,
      create: create,
      deps: createDeps,
      inst: inst,
      next: null
    };
    inst = currentlyRenderingFiber.updateQueue;
    null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
    create = inst.lastEffect;
    null === create ? inst.lastEffect = tag.next = tag : (createDeps = create.next, create.next = tag, tag.next = createDeps, inst.lastEffect = tag);
    return tag;
  }
  function createEffectInstance() {
    return {
      destroy: undefined,
      resource: undefined
    };
  }
  function updateRef() {
    return updateWorkInProgressHook().memoizedState;
  }
  function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
    var hook = mountWorkInProgressHook();
    createDeps = undefined === createDeps ? null : createDeps;
    currentlyRenderingFiber.flags |= fiberFlags;
    hook.memoizedState = pushSimpleEffect(1 | hookFlags, createEffectInstance(), create, createDeps);
  }
  function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
    var hook = updateWorkInProgressHook();
    deps = undefined === deps ? null : deps;
    var inst = hook.memoizedState.inst;
    null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(1 | hookFlags, inst, create, deps));
  }
  function mountEffect(create, createDeps) {
    mountEffectImpl(8390656, 8, create, createDeps);
  }
  function updateEffect(create, createDeps) {
    updateEffectImpl(2048, 8, create, createDeps);
  }
  function updateInsertionEffect(create, deps) {
    return updateEffectImpl(4, 2, create, deps);
  }
  function updateLayoutEffect(create, deps) {
    return updateEffectImpl(4, 4, create, deps);
  }
  function imperativeHandleEffect(create, ref) {
    if ("function" === typeof ref) {
      create = create();
      var refCleanup = ref(create);
      return function () {
        "function" === typeof refCleanup ? refCleanup() : ref(null);
      };
    }
    if (null !== ref && undefined !== ref) return create = create(), ref.current = create, function () {
      ref.current = null;
    };
  }
  function updateImperativeHandle(ref, create, deps) {
    deps = null !== deps && undefined !== deps ? deps.concat([ref]) : null;
    updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
  }
  function mountDebugValue() {}
  function updateCallback(callback, deps) {
    var hook = updateWorkInProgressHook();
    deps = undefined === deps ? null : deps;
    var prevState = hook.memoizedState;
    if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
    hook.memoizedState = [callback, deps];
    return callback;
  }
  function updateMemo(nextCreate, deps) {
    var hook = updateWorkInProgressHook();
    deps = undefined === deps ? null : deps;
    var prevState = hook.memoizedState;
    if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
    prevState = nextCreate();
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(true);
      try {
        nextCreate();
      } finally {
        setIsStrictModeForDevtools(false);
      }
    }
    hook.memoizedState = [prevState, deps];
    return prevState;
  }
  function mountDeferredValueImpl(hook, value, initialValue) {
    if (undefined === initialValue || 0 !== (renderLanes & 1073741824)) return hook.memoizedState = value;
    hook.memoizedState = initialValue;
    hook = requestDeferredLane();
    currentlyRenderingFiber.lanes |= hook;
    workInProgressRootSkippedLanes |= hook;
    return initialValue;
  }
  function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
    if (objectIs(value, prevValue)) return value;
    if (null !== currentTreeHiddenStackCursor.current) return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
    if (0 === (renderLanes & 42)) return didReceiveUpdate = true, hook.memoizedState = value;
    hook = requestDeferredLane();
    currentlyRenderingFiber.lanes |= hook;
    workInProgressRootSkippedLanes |= hook;
    return prevValue;
  }
  function startTransition(fiber, queue, pendingState, finishedState, callback) {
    var previousPriority = ReactDOMSharedInternals.p;
    ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
    var prevTransition = ReactSharedInternals.T,
      currentTransition = {};
    ReactSharedInternals.T = currentTransition;
    dispatchOptimisticSetState(fiber, false, queue, pendingState);
    try {
      var returnValue = callback(),
        onStartTransitionFinish = ReactSharedInternals.S;
      null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
      if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
        var thenableForFinishedState = chainThenableValue(returnValue, finishedState);
        dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane(fiber));
      } else dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));
    } catch (error) {
      dispatchSetStateInternal(fiber, queue, {
        then: function () {},
        status: "rejected",
        reason: error
      }, requestUpdateLane());
    } finally {
      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
    }
  }
  function noop$2() {}
  function startHostTransition(formFiber, pendingState, action, formData) {
    if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
    var queue = ensureFormComponentIsStateful(formFiber).queue;
    startTransition(formFiber, queue, pendingState, sharedNotPendingObject, null === action ? noop$2 : function () {
      requestFormReset$1(formFiber);
      return action(formData);
    });
  }
  function ensureFormComponentIsStateful(formFiber) {
    var existingStateHook = formFiber.memoizedState;
    if (null !== existingStateHook) return existingStateHook;
    existingStateHook = {
      memoizedState: sharedNotPendingObject,
      baseState: sharedNotPendingObject,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: sharedNotPendingObject
      },
      next: null
    };
    var initialResetState = {};
    existingStateHook.next = {
      memoizedState: initialResetState,
      baseState: initialResetState,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialResetState
      },
      next: null
    };
    formFiber.memoizedState = existingStateHook;
    formFiber = formFiber.alternate;
    null !== formFiber && (formFiber.memoizedState = existingStateHook);
    return existingStateHook;
  }
  function requestFormReset$1(formFiber) {
    var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
    dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
  }
  function useHostTransitionStatus() {
    return readContext(HostTransitionContext);
  }
  function updateId() {
    return updateWorkInProgressHook().memoizedState;
  }
  function updateRefresh() {
    return updateWorkInProgressHook().memoizedState;
  }
  function refreshCache(fiber) {
    for (var provider = fiber.return; null !== provider;) {
      switch (provider.tag) {
        case 24:
        case 3:
          var lane = requestUpdateLane();
          fiber = createUpdate(lane);
          var root$41 = enqueueUpdate(provider, fiber, lane);
          null !== root$41 && (scheduleUpdateOnFiber(root$41, provider, lane), entangleTransitions(root$41, provider, lane));
          provider = {
            cache: createCache()
          };
          fiber.payload = provider;
          return;
      }
      provider = provider.return;
    }
  }
  function dispatchReducerAction(fiber, queue, action) {
    var lane = requestUpdateLane();
    action = {
      lane: lane,
      revertLane: 0,
      action: action,
      hasEagerState: false,
      eagerState: null,
      next: null
    };
    isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
  }
  function dispatchSetState(fiber, queue, action) {
    var lane = requestUpdateLane();
    dispatchSetStateInternal(fiber, queue, action, lane);
  }
  function dispatchSetStateInternal(fiber, queue, action, lane) {
    var update = {
      lane: lane,
      revertLane: 0,
      action: action,
      hasEagerState: false,
      eagerState: null,
      next: null
    };
    if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);else {
      var alternate = fiber.alternate;
      if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) try {
        var currentState = queue.lastRenderedState,
          eagerState = alternate(currentState, action);
        update.hasEagerState = true;
        update.eagerState = eagerState;
        if (objectIs(eagerState, currentState)) return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
      } catch (error) {} finally {}
      action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
      if (null !== action) return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
    }
    return false;
  }
  function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
    action = {
      lane: 2,
      revertLane: requestTransitionLane(),
      action: action,
      hasEagerState: false,
      eagerState: null,
      next: null
    };
    if (isRenderPhaseUpdate(fiber)) {
      if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
    } else throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
  }
  function isRenderPhaseUpdate(fiber) {
    var alternate = fiber.alternate;
    return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
  }
  function enqueueRenderPhaseUpdate(queue, update) {
    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
    var pending = queue.pending;
    null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
    queue.pending = update;
  }
  function entangleTransitionUpdate(root, queue, lane) {
    if (0 !== (lane & 4194048)) {
      var queueLanes = queue.lanes;
      queueLanes &= root.pendingLanes;
      lane |= queueLanes;
      queue.lanes = lane;
      markRootEntangled(root, lane);
    }
  }
  var ContextOnlyDispatcher = {
      readContext: readContext,
      use: use,
      useCallback: throwInvalidHookError,
      useContext: throwInvalidHookError,
      useEffect: throwInvalidHookError,
      useImperativeHandle: throwInvalidHookError,
      useLayoutEffect: throwInvalidHookError,
      useInsertionEffect: throwInvalidHookError,
      useMemo: throwInvalidHookError,
      useReducer: throwInvalidHookError,
      useRef: throwInvalidHookError,
      useState: throwInvalidHookError,
      useDebugValue: throwInvalidHookError,
      useDeferredValue: throwInvalidHookError,
      useTransition: throwInvalidHookError,
      useSyncExternalStore: throwInvalidHookError,
      useId: throwInvalidHookError,
      useHostTransitionStatus: throwInvalidHookError,
      useFormState: throwInvalidHookError,
      useActionState: throwInvalidHookError,
      useOptimistic: throwInvalidHookError,
      useMemoCache: throwInvalidHookError,
      useCacheRefresh: throwInvalidHookError
    },
    HooksDispatcherOnMount = {
      readContext: readContext,
      use: use,
      useCallback: function (callback, deps) {
        mountWorkInProgressHook().memoizedState = [callback, undefined === deps ? null : deps];
        return callback;
      },
      useContext: readContext,
      useEffect: mountEffect,
      useImperativeHandle: function (ref, create, deps) {
        deps = null !== deps && undefined !== deps ? deps.concat([ref]) : null;
        mountEffectImpl(4194308, 4, imperativeHandleEffect.bind(null, create, ref), deps);
      },
      useLayoutEffect: function (create, deps) {
        return mountEffectImpl(4194308, 4, create, deps);
      },
      useInsertionEffect: function (create, deps) {
        mountEffectImpl(4, 2, create, deps);
      },
      useMemo: function (nextCreate, deps) {
        var hook = mountWorkInProgressHook();
        deps = undefined === deps ? null : deps;
        var nextValue = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [nextValue, deps];
        return nextValue;
      },
      useReducer: function (reducer, initialArg, init) {
        var hook = mountWorkInProgressHook();
        if (undefined !== init) {
          var initialState = init(initialArg);
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              init(initialArg);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        } else initialState = initialArg;
        hook.memoizedState = hook.baseState = initialState;
        reducer = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: reducer,
          lastRenderedState: initialState
        };
        hook.queue = reducer;
        reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, reducer);
        return [hook.memoizedState, reducer];
      },
      useRef: function (initialValue) {
        var hook = mountWorkInProgressHook();
        initialValue = {
          current: initialValue
        };
        return hook.memoizedState = initialValue;
      },
      useState: function (initialState) {
        initialState = mountStateImpl(initialState);
        var queue = initialState.queue,
          dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
        queue.dispatch = dispatch;
        return [initialState.memoizedState, dispatch];
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function (value, initialValue) {
        var hook = mountWorkInProgressHook();
        return mountDeferredValueImpl(hook, value, initialValue);
      },
      useTransition: function () {
        var stateHook = mountStateImpl(false);
        stateHook = startTransition.bind(null, currentlyRenderingFiber, stateHook.queue, true, false);
        mountWorkInProgressHook().memoizedState = stateHook;
        return [false, stateHook];
      },
      useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber,
          hook = mountWorkInProgressHook();
        if (isHydrating) {
          if (undefined === getServerSnapshot) throw Error(formatProdErrorMessage(407));
          getServerSnapshot = getServerSnapshot();
        } else {
          getServerSnapshot = getSnapshot();
          if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
          0 !== (workInProgressRootRenderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        hook.memoizedState = getServerSnapshot;
        var inst = {
          value: getServerSnapshot,
          getSnapshot: getSnapshot
        };
        hook.queue = inst;
        mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
        fiber.flags |= 2048;
        pushSimpleEffect(9, createEffectInstance(), updateStoreInstance.bind(null, fiber, inst, getServerSnapshot, getSnapshot), null);
        return getServerSnapshot;
      },
      useId: function () {
        var hook = mountWorkInProgressHook(),
          identifierPrefix = workInProgressRoot.identifierPrefix;
        if (isHydrating) {
          var JSCompiler_inline_result = treeContextOverflow;
          var idWithLeadingBit = treeContextId;
          JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
          identifierPrefix = "\u00ab" + identifierPrefix + "R" + JSCompiler_inline_result;
          JSCompiler_inline_result = localIdCounter++;
          0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
          identifierPrefix += "\u00bb";
        } else JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "\u00ab" + identifierPrefix + "r" + JSCompiler_inline_result.toString(32) + "\u00bb";
        return hook.memoizedState = identifierPrefix;
      },
      useHostTransitionStatus: useHostTransitionStatus,
      useFormState: mountActionState,
      useActionState: mountActionState,
      useOptimistic: function (passthrough) {
        var hook = mountWorkInProgressHook();
        hook.memoizedState = hook.baseState = passthrough;
        var queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null
        };
        hook.queue = queue;
        hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, true, queue);
        queue.dispatch = hook;
        return [passthrough, hook];
      },
      useMemoCache: useMemoCache,
      useCacheRefresh: function () {
        return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber);
      }
    },
    HooksDispatcherOnUpdate = {
      readContext: readContext,
      use: use,
      useCallback: updateCallback,
      useContext: readContext,
      useEffect: updateEffect,
      useImperativeHandle: updateImperativeHandle,
      useInsertionEffect: updateInsertionEffect,
      useLayoutEffect: updateLayoutEffect,
      useMemo: updateMemo,
      useReducer: updateReducer,
      useRef: updateRef,
      useState: function () {
        return updateReducer(basicStateReducer);
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function (value, initialValue) {
        var hook = updateWorkInProgressHook();
        return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
      },
      useTransition: function () {
        var booleanOrThenable = updateReducer(basicStateReducer)[0],
          start = updateWorkInProgressHook().memoizedState;
        return ["boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable), start];
      },
      useSyncExternalStore: updateSyncExternalStore,
      useId: updateId,
      useHostTransitionStatus: useHostTransitionStatus,
      useFormState: updateActionState,
      useActionState: updateActionState,
      useOptimistic: function (passthrough, reducer) {
        var hook = updateWorkInProgressHook();
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      },
      useMemoCache: useMemoCache,
      useCacheRefresh: updateRefresh
    },
    HooksDispatcherOnRerender = {
      readContext: readContext,
      use: use,
      useCallback: updateCallback,
      useContext: readContext,
      useEffect: updateEffect,
      useImperativeHandle: updateImperativeHandle,
      useInsertionEffect: updateInsertionEffect,
      useLayoutEffect: updateLayoutEffect,
      useMemo: updateMemo,
      useReducer: rerenderReducer,
      useRef: updateRef,
      useState: function () {
        return rerenderReducer(basicStateReducer);
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function (value, initialValue) {
        var hook = updateWorkInProgressHook();
        return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
      },
      useTransition: function () {
        var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
          start = updateWorkInProgressHook().memoizedState;
        return ["boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable), start];
      },
      useSyncExternalStore: updateSyncExternalStore,
      useId: updateId,
      useHostTransitionStatus: useHostTransitionStatus,
      useFormState: rerenderActionState,
      useActionState: rerenderActionState,
      useOptimistic: function (passthrough, reducer) {
        var hook = updateWorkInProgressHook();
        if (null !== currentHook) return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        hook.baseState = passthrough;
        return [passthrough, hook.queue.dispatch];
      },
      useMemoCache: useMemoCache,
      useCacheRefresh: updateRefresh
    },
    thenableState = null,
    thenableIndexCounter = 0;
  function unwrapThenable(thenable) {
    var index = thenableIndexCounter;
    thenableIndexCounter += 1;
    null === thenableState && (thenableState = []);
    return trackUsedThenable(thenableState, thenable, index);
  }
  function coerceRef(workInProgress, element) {
    element = element.props.ref;
    workInProgress.ref = undefined !== element ? element : null;
  }
  function throwOnInvalidObjectType(returnFiber, newChild) {
    if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) throw Error(formatProdErrorMessage(525));
    returnFiber = Object.prototype.toString.call(newChild);
    throw Error(formatProdErrorMessage(31, "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber));
  }
  function resolveLazy(lazyType) {
    var init = lazyType._init;
    return init(lazyType._payload);
  }
  function createChildReconciler(shouldTrackSideEffects) {
    function deleteChild(returnFiber, childToDelete) {
      if (shouldTrackSideEffects) {
        var deletions = returnFiber.deletions;
        null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
      }
    }
    function deleteRemainingChildren(returnFiber, currentFirstChild) {
      if (!shouldTrackSideEffects) return null;
      for (; null !== currentFirstChild;) deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
      return null;
    }
    function mapRemainingChildren(currentFirstChild) {
      for (var existingChildren = new Map(); null !== currentFirstChild;) null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
      return existingChildren;
    }
    function useFiber(fiber, pendingProps) {
      fiber = createWorkInProgress(fiber, pendingProps);
      fiber.index = 0;
      fiber.sibling = null;
      return fiber;
    }
    function placeChild(newFiber, lastPlacedIndex, newIndex) {
      newFiber.index = newIndex;
      if (!shouldTrackSideEffects) return newFiber.flags |= 1048576, lastPlacedIndex;
      newIndex = newFiber.alternate;
      if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
      newFiber.flags |= 67108866;
      return lastPlacedIndex;
    }
    function placeSingleChild(newFiber) {
      shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
      return newFiber;
    }
    function updateTextNode(returnFiber, current, textContent, lanes) {
      if (null === current || 6 !== current.tag) return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
      current = useFiber(current, textContent);
      current.return = returnFiber;
      return current;
    }
    function updateElement(returnFiber, current, element, lanes) {
      var elementType = element.type;
      if (elementType === REACT_FRAGMENT_TYPE) return updateFragment(returnFiber, current, element.props.children, lanes, element.key);
      if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type)) return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
      current = createFiberFromTypeAndProps(element.type, element.key, element.props, null, returnFiber.mode, lanes);
      coerceRef(current, element);
      current.return = returnFiber;
      return current;
    }
    function updatePortal(returnFiber, current, portal, lanes) {
      if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
      current = useFiber(current, portal.children || []);
      current.return = returnFiber;
      return current;
    }
    function updateFragment(returnFiber, current, fragment, lanes, key) {
      if (null === current || 7 !== current.tag) return current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current.return = returnFiber, current;
      current = useFiber(current, fragment);
      current.return = returnFiber;
      return current;
    }
    function createChild(returnFiber, newChild, lanes) {
      if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return newChild = createFiberFromText("" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild;
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return lanes = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, null, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
          case REACT_PORTAL_TYPE:
            return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild;
          case REACT_LAZY_TYPE:
            var init = newChild._init;
            newChild = init(newChild._payload);
            return createChild(returnFiber, newChild, lanes);
        }
        if (isArrayImpl(newChild) || getIteratorFn(newChild)) return newChild = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), newChild.return = returnFiber, newChild;
        if ("function" === typeof newChild.then) return createChild(returnFiber, unwrapThenable(newChild), lanes);
        if (newChild.$$typeof === REACT_CONTEXT_TYPE) return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
        throwOnInvalidObjectType(returnFiber, newChild);
      }
      return null;
    }
    function updateSlot(returnFiber, oldFiber, newChild, lanes) {
      var key = null !== oldFiber ? oldFiber.key : null;
      if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
          case REACT_PORTAL_TYPE:
            return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
          case REACT_LAZY_TYPE:
            return key = newChild._init, newChild = key(newChild._payload), updateSlot(returnFiber, oldFiber, newChild, lanes);
        }
        if (isArrayImpl(newChild) || getIteratorFn(newChild)) return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
        if ("function" === typeof newChild.then) return updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes);
        if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
        throwOnInvalidObjectType(returnFiber, newChild);
      }
      return null;
    }
    function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
      if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
          case REACT_PORTAL_TYPE:
            return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
          case REACT_LAZY_TYPE:
            var init = newChild._init;
            newChild = init(newChild._payload);
            return updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);
        }
        if (isArrayImpl(newChild) || getIteratorFn(newChild)) return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
        if ("function" === typeof newChild.then) return updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes);
        if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);
        throwOnInvalidObjectType(returnFiber, newChild);
      }
      return null;
    }
    function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
      for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
        var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
        if (null === newFiber) {
          null === oldFiber && (oldFiber = nextOldFiber);
          break;
        }
        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }
      if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
      if (null === oldFiber) {
        for (; newIdx < newChildren.length; newIdx++) oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++) nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
      shouldTrackSideEffects && oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
      if (null == newChildren) throw Error(formatProdErrorMessage(151));
      for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
        var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
        if (null === newFiber) {
          null === oldFiber && (oldFiber = nextOldFiber);
          break;
        }
        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }
      if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
      if (null === oldFiber) {
        for (; !step.done; newIdx++, step = newChildren.next()) step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next()) step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
      shouldTrackSideEffects && oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
      "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            a: {
              for (var key = newChild.key; null !== currentFirstChild;) {
                if (currentFirstChild.key === key) {
                  key = newChild.type;
                  if (key === REACT_FRAGMENT_TYPE) {
                    if (7 === currentFirstChild.tag) {
                      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                      lanes = useFiber(currentFirstChild, newChild.props.children);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    }
                  } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                    lanes = useFiber(currentFirstChild, newChild.props);
                    coerceRef(lanes, newChild);
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                    break a;
                  }
                  deleteRemainingChildren(returnFiber, currentFirstChild);
                  break;
                } else deleteChild(returnFiber, currentFirstChild);
                currentFirstChild = currentFirstChild.sibling;
              }
              newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(newChild.type, newChild.key, newChild.props, null, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
            }
            return placeSingleChild(returnFiber);
          case REACT_PORTAL_TYPE:
            a: {
              for (key = newChild.key; null !== currentFirstChild;) {
                if (currentFirstChild.key === key) {
                  if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                    lanes = useFiber(currentFirstChild, newChild.children || []);
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                    break a;
                  } else {
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  }
                } else deleteChild(returnFiber, currentFirstChild);
                currentFirstChild = currentFirstChild.sibling;
              }
              lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
              lanes.return = returnFiber;
              returnFiber = lanes;
            }
            return placeSingleChild(returnFiber);
          case REACT_LAZY_TYPE:
            return key = newChild._init, newChild = key(newChild._payload), reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);
        }
        if (isArrayImpl(newChild)) return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
        if (getIteratorFn(newChild)) {
          key = getIteratorFn(newChild);
          if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
          newChild = key.call(newChild);
          return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
        }
        if ("function" === typeof newChild.then) return reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes);
        if (newChild.$$typeof === REACT_CONTEXT_TYPE) return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);
        throwOnInvalidObjectType(returnFiber, newChild);
      }
      return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
    }
    return function (returnFiber, currentFirstChild, newChild, lanes) {
      try {
        thenableIndexCounter = 0;
        var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);
        thenableState = null;
        return firstChildFiber;
      } catch (x) {
        if (x === SuspenseException || x === SuspenseActionException) throw x;
        var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
        fiber.lanes = lanes;
        fiber.return = returnFiber;
        return fiber;
      } finally {}
    };
  }
  var reconcileChildFibers = createChildReconciler(true),
    mountChildFibers = createChildReconciler(false),
    suspenseHandlerStackCursor = createCursor(null),
    shellBoundary = null;
  function pushPrimaryTreeSuspenseHandler(handler) {
    var current = handler.alternate;
    push(suspenseStackCursor, suspenseStackCursor.current & 1);
    push(suspenseHandlerStackCursor, handler);
    null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
  }
  function pushOffscreenSuspenseHandler(fiber) {
    if (22 === fiber.tag) {
      if (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary) {
        var current = fiber.alternate;
        null !== current && null !== current.memoizedState && (shellBoundary = fiber);
      }
    } else reuseSuspenseHandlerOnStack(fiber);
  }
  function reuseSuspenseHandlerOnStack() {
    push(suspenseStackCursor, suspenseStackCursor.current);
    push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
  }
  function popSuspenseHandler(fiber) {
    pop(suspenseHandlerStackCursor);
    shellBoundary === fiber && (shellBoundary = null);
    pop(suspenseStackCursor);
  }
  var suspenseStackCursor = createCursor(0);
  function findFirstSuspended(row) {
    for (var node = row; null !== node;) {
      if (13 === node.tag) {
        var state = node.memoizedState;
        if (null !== state && (state = state.dehydrated, null === state || "$?" === state.data || isSuspenseInstanceFallback(state))) return node;
      } else if (19 === node.tag && undefined !== node.memoizedProps.revealOrder) {
        if (0 !== (node.flags & 128)) return node;
      } else if (null !== node.child) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      if (node === row) break;
      for (; null === node.sibling;) {
        if (null === node.return || node.return === row) return null;
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
    return null;
  }
  function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
    ctor = workInProgress.memoizedState;
    getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
    getDerivedStateFromProps = null === getDerivedStateFromProps || undefined === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
    workInProgress.memoizedState = getDerivedStateFromProps;
    0 === workInProgress.lanes && (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
  }
  var classComponentUpdater = {
    enqueueSetState: function (inst, payload, callback) {
      inst = inst._reactInternals;
      var lane = requestUpdateLane(),
        update = createUpdate(lane);
      update.payload = payload;
      undefined !== callback && null !== callback && (update.callback = callback);
      payload = enqueueUpdate(inst, update, lane);
      null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
    },
    enqueueReplaceState: function (inst, payload, callback) {
      inst = inst._reactInternals;
      var lane = requestUpdateLane(),
        update = createUpdate(lane);
      update.tag = 1;
      update.payload = payload;
      undefined !== callback && null !== callback && (update.callback = callback);
      payload = enqueueUpdate(inst, update, lane);
      null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
    },
    enqueueForceUpdate: function (inst, callback) {
      inst = inst._reactInternals;
      var lane = requestUpdateLane(),
        update = createUpdate(lane);
      update.tag = 2;
      undefined !== callback && null !== callback && (update.callback = callback);
      callback = enqueueUpdate(inst, update, lane);
      null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
    }
  };
  function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
    workInProgress = workInProgress.stateNode;
    return "function" === typeof workInProgress.shouldComponentUpdate ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
  }
  function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
    workInProgress = instance.state;
    "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
    "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
    instance.state !== workInProgress && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }
  function resolveClassComponentProps(Component, baseProps) {
    var newProps = baseProps;
    if ("ref" in baseProps) {
      newProps = {};
      for (var propName in baseProps) "ref" !== propName && (newProps[propName] = baseProps[propName]);
    }
    if (Component = Component.defaultProps) {
      newProps === baseProps && (newProps = assign({}, newProps));
      for (var propName$73 in Component) undefined === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
    }
    return newProps;
  }
  var reportGlobalError = "function" === typeof reportError ? reportError : function (error) {
    if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
      var event = new window.ErrorEvent("error", {
        bubbles: true,
        cancelable: true,
        message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
        error: error
      });
      if (!window.dispatchEvent(event)) return;
    } else if ("object" === typeof process && "function" === typeof process.emit) {
      process.emit("uncaughtException", error);
      return;
    }
    console.error(error);
  };
  function defaultOnUncaughtError(error) {
    reportGlobalError(error);
  }
  function defaultOnCaughtError(error) {
    console.error(error);
  }
  function defaultOnRecoverableError(error) {
    reportGlobalError(error);
  }
  function logUncaughtError(root, errorInfo) {
    try {
      var onUncaughtError = root.onUncaughtError;
      onUncaughtError(errorInfo.value, {
        componentStack: errorInfo.stack
      });
    } catch (e$74) {
      setTimeout(function () {
        throw e$74;
      });
    }
  }
  function logCaughtError(root, boundary, errorInfo) {
    try {
      var onCaughtError = root.onCaughtError;
      onCaughtError(errorInfo.value, {
        componentStack: errorInfo.stack,
        errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
      });
    } catch (e$75) {
      setTimeout(function () {
        throw e$75;
      });
    }
  }
  function createRootErrorUpdate(root, errorInfo, lane) {
    lane = createUpdate(lane);
    lane.tag = 3;
    lane.payload = {
      element: null
    };
    lane.callback = function () {
      logUncaughtError(root, errorInfo);
    };
    return lane;
  }
  function createClassErrorUpdate(lane) {
    lane = createUpdate(lane);
    lane.tag = 3;
    return lane;
  }
  function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
    var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
    if ("function" === typeof getDerivedStateFromError) {
      var error = errorInfo.value;
      update.payload = function () {
        return getDerivedStateFromError(error);
      };
      update.callback = function () {
        logCaughtError(root, fiber, errorInfo);
      };
    }
    var inst = fiber.stateNode;
    null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function () {
      logCaughtError(root, fiber, errorInfo);
      "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
      var stack = errorInfo.stack;
      this.componentDidCatch(errorInfo.value, {
        componentStack: null !== stack ? stack : ""
      });
    });
  }
  function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
    sourceFiber.flags |= 32768;
    if (null !== value && "object" === typeof value && "function" === typeof value.then) {
      returnFiber = sourceFiber.alternate;
      null !== returnFiber && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, true);
      sourceFiber = suspenseHandlerStackCursor.current;
      if (null !== sourceFiber) {
        switch (sourceFiber.tag) {
          case 13:
            return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = new Set([value]) : returnFiber.add(value), attachPingListener(root, value, rootRenderLanes)), false;
          case 22:
            return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
              transitions: null,
              markerInstances: null,
              retryQueue: new Set([value])
            }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = new Set([value]) : sourceFiber.add(value)), attachPingListener(root, value, rootRenderLanes)), false;
        }
        throw Error(formatProdErrorMessage(435, sourceFiber.tag));
      }
      attachPingListener(root, value, rootRenderLanes);
      renderDidSuspendDelayIfPossible();
      return false;
    }
    if (isHydrating) return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root = Error(formatProdErrorMessage(422), {
      cause: value
    }), queueHydrationError(createCapturedValueAtFiber(root, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
      cause: value
    }), queueHydrationError(createCapturedValueAtFiber(returnFiber, sourceFiber))), root = root.current.alternate, root.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
    var wrapperError = Error(formatProdErrorMessage(520), {
      cause: value
    });
    wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
    null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
    4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
    if (null === returnFiber) return true;
    value = createCapturedValueAtFiber(value, sourceFiber);
    sourceFiber = returnFiber;
    do {
      switch (sourceFiber.tag) {
        case 3:
          return sourceFiber.flags |= 65536, root = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root, root = createRootErrorUpdate(sourceFiber.stateNode, value, root), enqueueCapturedUpdate(sourceFiber, root), false;
        case 1:
          if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))) return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
      }
      sourceFiber = sourceFiber.return;
    } while (null !== sourceFiber);
    return false;
  }
  var SelectiveHydrationException = Error(formatProdErrorMessage(461)),
    didReceiveUpdate = false;
  function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
    workInProgress.child = null === current ? mountChildFibers(workInProgress, null, nextChildren, renderLanes) : reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);
  }
  function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {
    Component = Component.render;
    var ref = workInProgress.ref;
    if ("ref" in nextProps) {
      var propsWithoutRef = {};
      for (var key in nextProps) "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
    } else propsWithoutRef = nextProps;
    prepareToReadContext(workInProgress);
    nextProps = renderWithHooks(current, workInProgress, Component, propsWithoutRef, ref, renderLanes);
    key = checkDidRenderIdHook();
    if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    isHydrating && key && pushMaterializedTreeId(workInProgress);
    workInProgress.flags |= 1;
    reconcileChildren(current, workInProgress, nextProps, renderLanes);
    return workInProgress.child;
  }
  function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {
    if (null === current) {
      var type = Component.type;
      if ("function" === typeof type && !shouldConstruct(type) && undefined === type.defaultProps && null === Component.compare) return workInProgress.tag = 15, workInProgress.type = type, updateSimpleMemoComponent(current, workInProgress, type, nextProps, renderLanes);
      current = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);
      current.ref = workInProgress.ref;
      current.return = workInProgress;
      return workInProgress.child = current;
    }
    type = current.child;
    if (!checkScheduledUpdateOrContext(current, renderLanes)) {
      var prevProps = type.memoizedProps;
      Component = Component.compare;
      Component = null !== Component ? Component : shallowEqual;
      if (Component(prevProps, nextProps) && current.ref === workInProgress.ref) return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
    workInProgress.flags |= 1;
    current = createWorkInProgress(type, nextProps);
    current.ref = workInProgress.ref;
    current.return = workInProgress;
    return workInProgress.child = current;
  }
  function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {
    if (null !== current) {
      var prevProps = current.memoizedProps;
      if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref) if (didReceiveUpdate = false, workInProgress.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes)) 0 !== (current.flags & 131072) && (didReceiveUpdate = true);else return workInProgress.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
    return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);
  }
  function updateOffscreenComponent(current, workInProgress, renderLanes) {
    var nextProps = workInProgress.pendingProps,
      nextChildren = nextProps.children,
      prevState = null !== current ? current.memoizedState : null;
    if ("hidden" === nextProps.mode) {
      if (0 !== (workInProgress.flags & 128)) {
        nextProps = null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;
        if (null !== current) {
          nextChildren = workInProgress.child = current.child;
          for (prevState = 0; null !== nextChildren;) prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
          workInProgress.childLanes = prevState & ~nextProps;
        } else workInProgress.childLanes = 0, workInProgress.child = null;
        return deferHiddenOffscreenComponent(current, workInProgress, nextProps, renderLanes);
      }
      if (0 !== (renderLanes & 536870912)) workInProgress.memoizedState = {
        baseLanes: 0,
        cachePool: null
      }, null !== current && pushTransition(workInProgress, null !== prevState ? prevState.cachePool : null), null !== prevState ? pushHiddenContext(workInProgress, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress);else return workInProgress.lanes = workInProgress.childLanes = 536870912, deferHiddenOffscreenComponent(current, workInProgress, null !== prevState ? prevState.baseLanes | renderLanes : renderLanes, renderLanes);
    } else null !== prevState ? (pushTransition(workInProgress, prevState.cachePool), pushHiddenContext(workInProgress, prevState), reuseSuspenseHandlerOnStack(workInProgress), workInProgress.memoizedState = null) : (null !== current && pushTransition(workInProgress, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack(workInProgress));
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
    return workInProgress.child;
  }
  function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes) {
    var JSCompiler_inline_result = peekCacheFromPool();
    JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
      parent: CacheContext._currentValue,
      pool: JSCompiler_inline_result
    };
    workInProgress.memoizedState = {
      baseLanes: nextBaseLanes,
      cachePool: JSCompiler_inline_result
    };
    null !== current && pushTransition(workInProgress, null);
    reuseHiddenContextOnStack();
    pushOffscreenSuspenseHandler(workInProgress);
    null !== current && propagateParentContextChanges(current, workInProgress, renderLanes, true);
    return null;
  }
  function markRef(current, workInProgress) {
    var ref = workInProgress.ref;
    if (null === ref) null !== current && null !== current.ref && (workInProgress.flags |= 4194816);else {
      if ("function" !== typeof ref && "object" !== typeof ref) throw Error(formatProdErrorMessage(284));
      if (null === current || current.ref !== ref) workInProgress.flags |= 4194816;
    }
  }
  function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {
    prepareToReadContext(workInProgress);
    Component = renderWithHooks(current, workInProgress, Component, nextProps, undefined, renderLanes);
    nextProps = checkDidRenderIdHook();
    if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
    workInProgress.flags |= 1;
    reconcileChildren(current, workInProgress, Component, renderLanes);
    return workInProgress.child;
  }
  function replayFunctionComponent(current, workInProgress, nextProps, Component, secondArg, renderLanes) {
    prepareToReadContext(workInProgress);
    workInProgress.updateQueue = null;
    nextProps = renderWithHooksAgain(workInProgress, Component, nextProps, secondArg);
    finishRenderingHooks(current);
    Component = checkDidRenderIdHook();
    if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    isHydrating && Component && pushMaterializedTreeId(workInProgress);
    workInProgress.flags |= 1;
    reconcileChildren(current, workInProgress, nextProps, renderLanes);
    return workInProgress.child;
  }
  function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {
    prepareToReadContext(workInProgress);
    if (null === workInProgress.stateNode) {
      var context = emptyContextObject,
        contextType = Component.contextType;
      "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
      context = new Component(nextProps, context);
      workInProgress.memoizedState = null !== context.state && undefined !== context.state ? context.state : null;
      context.updater = classComponentUpdater;
      workInProgress.stateNode = context;
      context._reactInternals = workInProgress;
      context = workInProgress.stateNode;
      context.props = nextProps;
      context.state = workInProgress.memoizedState;
      context.refs = {};
      initializeUpdateQueue(workInProgress);
      contextType = Component.contextType;
      context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
      context.state = workInProgress.memoizedState;
      contextType = Component.getDerivedStateFromProps;
      "function" === typeof contextType && (applyDerivedStateFromProps(workInProgress, Component, contextType, nextProps), context.state = workInProgress.memoizedState);
      "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress, nextProps, context, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress.memoizedState);
      "function" === typeof context.componentDidMount && (workInProgress.flags |= 4194308);
      nextProps = true;
    } else if (null === current) {
      context = workInProgress.stateNode;
      var unresolvedOldProps = workInProgress.memoizedProps,
        oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
      context.props = oldProps;
      var oldContext = context.context,
        contextType$jscomp$0 = Component.contextType;
      contextType = emptyContextObject;
      "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
      var getDerivedStateFromProps = Component.getDerivedStateFromProps;
      contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
      unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
      contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(workInProgress, context, nextProps, contextType);
      hasForceUpdate = false;
      var oldState = workInProgress.memoizedState;
      context.state = oldState;
      processUpdateQueue(workInProgress, nextProps, context, renderLanes);
      suspendIfUpdateReadFromEntangledAsyncAction();
      oldContext = workInProgress.memoizedState;
      unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, nextProps), oldContext = workInProgress.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, oldProps, nextProps, oldState, oldContext, contextType)) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress.flags |= 4194308), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress.flags |= 4194308), nextProps = false);
    } else {
      context = workInProgress.stateNode;
      cloneUpdateQueue(current, workInProgress);
      contextType = workInProgress.memoizedProps;
      contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
      context.props = contextType$jscomp$0;
      getDerivedStateFromProps = workInProgress.pendingProps;
      oldState = context.context;
      oldContext = Component.contextType;
      oldProps = emptyContextObject;
      "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
      unresolvedOldProps = Component.getDerivedStateFromProps;
      (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(workInProgress, context, nextProps, oldProps);
      hasForceUpdate = false;
      oldState = workInProgress.memoizedState;
      context.state = oldState;
      processUpdateQueue(workInProgress, nextProps, context, renderLanes);
      suspendIfUpdateReadFromEntangledAsyncAction();
      var newState = workInProgress.memoizedState;
      contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(workInProgress, Component, unresolvedOldProps, nextProps), newState = workInProgress.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, contextType$jscomp$0, nextProps, oldState, newState, oldProps) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(nextProps, newState, oldProps)), "function" === typeof context.componentDidUpdate && (workInProgress.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 1024), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress.flags |= 1024), nextProps = false);
    }
    context = nextProps;
    markRef(current, workInProgress);
    nextProps = 0 !== (workInProgress.flags & 128);
    context || nextProps ? (context = workInProgress.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress.flags |= 1, null !== current && nextProps ? (workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes), workInProgress.child = reconcileChildFibers(workInProgress, null, Component, renderLanes)) : reconcileChildren(current, workInProgress, Component, renderLanes), workInProgress.memoizedState = context.state, current = workInProgress.child) : current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    return current;
  }
  function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes) {
    resetHydrationState();
    workInProgress.flags |= 256;
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
    return workInProgress.child;
  }
  var SUSPENDED_MARKER = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function mountSuspenseOffscreenState(renderLanes) {
    return {
      baseLanes: renderLanes,
      cachePool: getSuspendedCache()
    };
  }
  function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes) {
    current = null !== current ? current.childLanes & ~renderLanes : 0;
    primaryTreeDidDefer && (current |= workInProgressDeferredLane);
    return current;
  }
  function updateSuspenseComponent(current, workInProgress, renderLanes) {
    var nextProps = workInProgress.pendingProps,
      showFallback = false,
      didSuspend = 0 !== (workInProgress.flags & 128),
      JSCompiler_temp;
    (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
    JSCompiler_temp && (showFallback = true, workInProgress.flags &= -129);
    JSCompiler_temp = 0 !== (workInProgress.flags & 32);
    workInProgress.flags &= -33;
    if (null === current) {
      if (isHydrating) {
        showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress) : reuseSuspenseHandlerOnStack(workInProgress);
        if (isHydrating) {
          var nextInstance = nextHydratableInstance,
            JSCompiler_temp$jscomp$0;
          if (JSCompiler_temp$jscomp$0 = nextInstance) {
            c: {
              JSCompiler_temp$jscomp$0 = nextInstance;
              for (nextInstance = rootOrSingletonContext; 8 !== JSCompiler_temp$jscomp$0.nodeType;) {
                if (!nextInstance) {
                  nextInstance = null;
                  break c;
                }
                JSCompiler_temp$jscomp$0 = getNextHydratable(JSCompiler_temp$jscomp$0.nextSibling);
                if (null === JSCompiler_temp$jscomp$0) {
                  nextInstance = null;
                  break c;
                }
              }
              nextInstance = JSCompiler_temp$jscomp$0;
            }
            null !== nextInstance ? (workInProgress.memoizedState = {
              dehydrated: nextInstance,
              treeContext: null !== treeContextProvider ? {
                id: treeContextId,
                overflow: treeContextOverflow
              } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, JSCompiler_temp$jscomp$0 = createFiberImplClass(18, null, null, 0), JSCompiler_temp$jscomp$0.stateNode = nextInstance, JSCompiler_temp$jscomp$0.return = workInProgress, workInProgress.child = JSCompiler_temp$jscomp$0, hydrationParentFiber = workInProgress, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = true) : JSCompiler_temp$jscomp$0 = false;
          }
          JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress);
        }
        nextInstance = workInProgress.memoizedState;
        if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance)) return isSuspenseInstanceFallback(nextInstance) ? workInProgress.lanes = 32 : workInProgress.lanes = 536870912, null;
        popSuspenseHandler(workInProgress);
      }
      nextInstance = nextProps.children;
      nextProps = nextProps.fallback;
      if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress), showFallback = workInProgress.mode, nextInstance = mountWorkInProgressOffscreenFiber({
        mode: "hidden",
        children: nextInstance
      }, showFallback), nextProps = createFiberFromFragment(nextProps, showFallback, renderLanes, null), nextInstance.return = workInProgress, nextProps.return = workInProgress, nextInstance.sibling = nextProps, workInProgress.child = nextInstance, showFallback = workInProgress.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes), showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;
      pushPrimaryTreeSuspenseHandler(workInProgress);
      return mountSuspensePrimaryChildren(workInProgress, nextInstance);
    }
    JSCompiler_temp$jscomp$0 = current.memoizedState;
    if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {
      if (didSuspend) workInProgress.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags &= -257, workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes)) : null !== workInProgress.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress), workInProgress.child = current.child, workInProgress.flags |= 128, workInProgress = null) : (reuseSuspenseHandlerOnStack(workInProgress), showFallback = nextProps.fallback, nextInstance = workInProgress.mode, nextProps = mountWorkInProgressOffscreenFiber({
        mode: "visible",
        children: nextProps.children
      }, nextInstance), showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes, null), showFallback.flags |= 2, nextProps.return = workInProgress, showFallback.return = workInProgress, nextProps.sibling = showFallback, workInProgress.child = nextProps, reconcileChildFibers(workInProgress, current.child, null, renderLanes), nextProps = workInProgress.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes), nextProps.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, workInProgress = showFallback);else if (pushPrimaryTreeSuspenseHandler(workInProgress), isSuspenseInstanceFallback(nextInstance)) {
        JSCompiler_temp = nextInstance.nextSibling && nextInstance.nextSibling.dataset;
        if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
        JSCompiler_temp = digest;
        nextProps = Error(formatProdErrorMessage(419));
        nextProps.stack = "";
        nextProps.digest = JSCompiler_temp;
        queueHydrationError({
          value: nextProps,
          source: null,
          stack: null
        });
        workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);
      } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress, renderLanes, false), JSCompiler_temp = 0 !== (renderLanes & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
        JSCompiler_temp = workInProgressRoot;
        if (null !== JSCompiler_temp && (nextProps = renderLanes & -renderLanes, nextProps = 0 !== (nextProps & 42) ? 1 : getBumpedLaneForHydrationByLane(nextProps), nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes)) ? 0 : nextProps, 0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane)) throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
        "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();
        workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);
      } else "$?" === nextInstance.data ? (workInProgress.flags |= 192, workInProgress.child = current.child, workInProgress = null) : (current = JSCompiler_temp$jscomp$0.treeContext, nextHydratableInstance = getNextHydratable(nextInstance.nextSibling), hydrationParentFiber = workInProgress, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && (idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress), workInProgress = mountSuspensePrimaryChildren(workInProgress, nextProps.children), workInProgress.flags |= 4096);
      return workInProgress;
    }
    if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress), showFallback = nextProps.fallback, nextInstance = workInProgress.mode, JSCompiler_temp$jscomp$0 = current.child, digest = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
      mode: "hidden",
      children: nextProps.children
    }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 65011712, null !== digest ? showFallback = createWorkInProgress(digest, showFallback) : (showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes, null), showFallback.flags |= 2), showFallback.return = workInProgress, nextProps.return = workInProgress, nextProps.sibling = showFallback, workInProgress.child = nextProps, nextProps = showFallback, showFallback = workInProgress.child, nextInstance = current.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (digest = CacheContext._currentValue, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== digest ? {
      parent: digest,
      pool: digest
    } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {
      baseLanes: nextInstance.baseLanes | renderLanes,
      cachePool: JSCompiler_temp$jscomp$0
    }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;
    pushPrimaryTreeSuspenseHandler(workInProgress);
    renderLanes = current.child;
    current = renderLanes.sibling;
    renderLanes = createWorkInProgress(renderLanes, {
      mode: "visible",
      children: nextProps.children
    });
    renderLanes.return = workInProgress;
    renderLanes.sibling = null;
    null !== current && (JSCompiler_temp = workInProgress.deletions, null === JSCompiler_temp ? (workInProgress.deletions = [current], workInProgress.flags |= 16) : JSCompiler_temp.push(current));
    workInProgress.child = renderLanes;
    workInProgress.memoizedState = null;
    return renderLanes;
  }
  function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
    primaryChildren = mountWorkInProgressOffscreenFiber({
      mode: "visible",
      children: primaryChildren
    }, workInProgress.mode);
    primaryChildren.return = workInProgress;
    return workInProgress.child = primaryChildren;
  }
  function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
    offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
    offscreenProps.lanes = 0;
    offscreenProps.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    };
    return offscreenProps;
  }
  function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {
    reconcileChildFibers(workInProgress, current.child, null, renderLanes);
    current = mountSuspensePrimaryChildren(workInProgress, workInProgress.pendingProps.children);
    current.flags |= 2;
    workInProgress.memoizedState = null;
    return current;
  }
  function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
    fiber.lanes |= renderLanes;
    var alternate = fiber.alternate;
    null !== alternate && (alternate.lanes |= renderLanes);
    scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);
  }
  function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {
    var renderState = workInProgress.memoizedState;
    null === renderState ? workInProgress.memoizedState = {
      isBackwards: isBackwards,
      rendering: null,
      renderingStartTime: 0,
      last: lastContentRow,
      tail: tail,
      tailMode: tailMode
    } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
  }
  function updateSuspenseListComponent(current, workInProgress, renderLanes) {
    var nextProps = workInProgress.pendingProps,
      revealOrder = nextProps.revealOrder,
      tailMode = nextProps.tail;
    reconcileChildren(current, workInProgress, nextProps.children, renderLanes);
    nextProps = suspenseStackCursor.current;
    if (0 !== (nextProps & 2)) nextProps = nextProps & 1 | 2, workInProgress.flags |= 128;else {
      if (null !== current && 0 !== (current.flags & 128)) a: for (current = workInProgress.child; null !== current;) {
        if (13 === current.tag) null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);else if (19 === current.tag) scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);else if (null !== current.child) {
          current.child.return = current;
          current = current.child;
          continue;
        }
        if (current === workInProgress) break a;
        for (; null === current.sibling;) {
          if (null === current.return || current.return === workInProgress) break a;
          current = current.return;
        }
        current.sibling.return = current.return;
        current = current.sibling;
      }
      nextProps &= 1;
    }
    push(suspenseStackCursor, nextProps);
    switch (revealOrder) {
      case "forwards":
        renderLanes = workInProgress.child;
        for (revealOrder = null; null !== renderLanes;) current = renderLanes.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes), renderLanes = renderLanes.sibling;
        renderLanes = revealOrder;
        null === renderLanes ? (revealOrder = workInProgress.child, workInProgress.child = null) : (revealOrder = renderLanes.sibling, renderLanes.sibling = null);
        initSuspenseListRenderState(workInProgress, false, revealOrder, renderLanes, tailMode);
        break;
      case "backwards":
        renderLanes = null;
        revealOrder = workInProgress.child;
        for (workInProgress.child = null; null !== revealOrder;) {
          current = revealOrder.alternate;
          if (null !== current && null === findFirstSuspended(current)) {
            workInProgress.child = revealOrder;
            break;
          }
          current = revealOrder.sibling;
          revealOrder.sibling = renderLanes;
          renderLanes = revealOrder;
          revealOrder = current;
        }
        initSuspenseListRenderState(workInProgress, true, renderLanes, null, tailMode);
        break;
      case "together":
        initSuspenseListRenderState(workInProgress, false, null, null, undefined);
        break;
      default:
        workInProgress.memoizedState = null;
    }
    return workInProgress.child;
  }
  function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
    null !== current && (workInProgress.dependencies = current.dependencies);
    workInProgressRootSkippedLanes |= workInProgress.lanes;
    if (0 === (renderLanes & workInProgress.childLanes)) if (null !== current) {
      if (propagateParentContextChanges(current, workInProgress, renderLanes, false), 0 === (renderLanes & workInProgress.childLanes)) return null;
    } else return null;
    if (null !== current && workInProgress.child !== current.child) throw Error(formatProdErrorMessage(153));
    if (null !== workInProgress.child) {
      current = workInProgress.child;
      renderLanes = createWorkInProgress(current, current.pendingProps);
      workInProgress.child = renderLanes;
      for (renderLanes.return = workInProgress; null !== current.sibling;) current = current.sibling, renderLanes = renderLanes.sibling = createWorkInProgress(current, current.pendingProps), renderLanes.return = workInProgress;
      renderLanes.sibling = null;
    }
    return workInProgress.child;
  }
  function checkScheduledUpdateOrContext(current, renderLanes) {
    if (0 !== (current.lanes & renderLanes)) return true;
    current = current.dependencies;
    return null !== current && checkIfContextChanged(current) ? true : false;
  }
  function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {
    switch (workInProgress.tag) {
      case 3:
        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
        pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
        resetHydrationState();
        break;
      case 27:
      case 5:
        pushHostContext(workInProgress);
        break;
      case 4:
        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
        break;
      case 10:
        pushProvider(workInProgress, workInProgress.type, workInProgress.memoizedProps.value);
        break;
      case 13:
        var state = workInProgress.memoizedState;
        if (null !== state) {
          if (null !== state.dehydrated) return pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags |= 128, null;
          if (0 !== (renderLanes & workInProgress.child.childLanes)) return updateSuspenseComponent(current, workInProgress, renderLanes);
          pushPrimaryTreeSuspenseHandler(workInProgress);
          current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
          return null !== current ? current.sibling : null;
        }
        pushPrimaryTreeSuspenseHandler(workInProgress);
        break;
      case 19:
        var didSuspendBefore = 0 !== (current.flags & 128);
        state = 0 !== (renderLanes & workInProgress.childLanes);
        state || (propagateParentContextChanges(current, workInProgress, renderLanes, false), state = 0 !== (renderLanes & workInProgress.childLanes));
        if (didSuspendBefore) {
          if (state) return updateSuspenseListComponent(current, workInProgress, renderLanes);
          workInProgress.flags |= 128;
        }
        didSuspendBefore = workInProgress.memoizedState;
        null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
        push(suspenseStackCursor, suspenseStackCursor.current);
        if (state) break;else return null;
      case 22:
      case 23:
        return workInProgress.lanes = 0, updateOffscreenComponent(current, workInProgress, renderLanes);
      case 24:
        pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
    }
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }
  function beginWork(current, workInProgress, renderLanes) {
    if (null !== current) {
      if (current.memoizedProps !== workInProgress.pendingProps) didReceiveUpdate = true;else {
        if (!checkScheduledUpdateOrContext(current, renderLanes) && 0 === (workInProgress.flags & 128)) return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);
        didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
      }
    } else didReceiveUpdate = false, isHydrating && 0 !== (workInProgress.flags & 1048576) && pushTreeId(workInProgress, treeForkCount, workInProgress.index);
    workInProgress.lanes = 0;
    switch (workInProgress.tag) {
      case 16:
        a: {
          current = workInProgress.pendingProps;
          var lazyComponent = workInProgress.elementType,
            init = lazyComponent._init;
          lazyComponent = init(lazyComponent._payload);
          workInProgress.type = lazyComponent;
          if ("function" === typeof lazyComponent) shouldConstruct(lazyComponent) ? (current = resolveClassComponentProps(lazyComponent, current), workInProgress.tag = 1, workInProgress = updateClassComponent(null, workInProgress, lazyComponent, current, renderLanes)) : (workInProgress.tag = 0, workInProgress = updateFunctionComponent(null, workInProgress, lazyComponent, current, renderLanes));else {
            if (undefined !== lazyComponent && null !== lazyComponent) if (init = lazyComponent.$$typeof, init === REACT_FORWARD_REF_TYPE) {
              workInProgress.tag = 11;
              workInProgress = updateForwardRef(null, workInProgress, lazyComponent, current, renderLanes);
              break a;
            } else if (init === REACT_MEMO_TYPE) {
              workInProgress.tag = 14;
              workInProgress = updateMemoComponent(null, workInProgress, lazyComponent, current, renderLanes);
              break a;
            }
            workInProgress = getComponentNameFromType(lazyComponent) || lazyComponent;
            throw Error(formatProdErrorMessage(306, workInProgress, ""));
          }
        }
        return workInProgress;
      case 0:
        return updateFunctionComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
      case 1:
        return lazyComponent = workInProgress.type, init = resolveClassComponentProps(lazyComponent, workInProgress.pendingProps), updateClassComponent(current, workInProgress, lazyComponent, init, renderLanes);
      case 3:
        a: {
          pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
          if (null === current) throw Error(formatProdErrorMessage(387));
          lazyComponent = workInProgress.pendingProps;
          var prevState = workInProgress.memoizedState;
          init = prevState.element;
          cloneUpdateQueue(current, workInProgress);
          processUpdateQueue(workInProgress, lazyComponent, null, renderLanes);
          var nextState = workInProgress.memoizedState;
          lazyComponent = nextState.cache;
          pushProvider(workInProgress, CacheContext, lazyComponent);
          lazyComponent !== prevState.cache && propagateContextChanges(workInProgress, [CacheContext], renderLanes, true);
          suspendIfUpdateReadFromEntangledAsyncAction();
          lazyComponent = nextState.element;
          if (prevState.isDehydrated) {
            if (prevState = {
              element: lazyComponent,
              isDehydrated: false,
              cache: nextState.cache
            }, workInProgress.updateQueue.baseState = prevState, workInProgress.memoizedState = prevState, workInProgress.flags & 256) {
              workInProgress = mountHostRootWithoutHydrating(current, workInProgress, lazyComponent, renderLanes);
              break a;
            } else if (lazyComponent !== init) {
              init = createCapturedValueAtFiber(Error(formatProdErrorMessage(424)), workInProgress);
              queueHydrationError(init);
              workInProgress = mountHostRootWithoutHydrating(current, workInProgress, lazyComponent, renderLanes);
              break a;
            } else {
              current = workInProgress.stateNode.containerInfo;
              switch (current.nodeType) {
                case 9:
                  current = current.body;
                  break;
                default:
                  current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
              }
              nextHydratableInstance = getNextHydratable(current.firstChild);
              hydrationParentFiber = workInProgress;
              isHydrating = true;
              hydrationErrors = null;
              rootOrSingletonContext = true;
              renderLanes = mountChildFibers(workInProgress, null, lazyComponent, renderLanes);
              for (workInProgress.child = renderLanes; renderLanes;) renderLanes.flags = renderLanes.flags & -3 | 4096, renderLanes = renderLanes.sibling;
            }
          } else {
            resetHydrationState();
            if (lazyComponent === init) {
              workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
              break a;
            }
            reconcileChildren(current, workInProgress, lazyComponent, renderLanes);
          }
          workInProgress = workInProgress.child;
        }
        return workInProgress;
      case 26:
        return markRef(current, workInProgress), null === current ? (renderLanes = getResource(workInProgress.type, null, workInProgress.pendingProps, null)) ? workInProgress.memoizedState = renderLanes : isHydrating || (renderLanes = workInProgress.type, current = workInProgress.pendingProps, lazyComponent = getOwnerDocumentFromRootContainer(rootInstanceStackCursor.current).createElement(renderLanes), lazyComponent[internalInstanceKey] = workInProgress, lazyComponent[internalPropsKey] = current, setInitialProperties(lazyComponent, renderLanes, current), markNodeAsHoistable(lazyComponent), workInProgress.stateNode = lazyComponent) : workInProgress.memoizedState = getResource(workInProgress.type, current.memoizedProps, workInProgress.pendingProps, current.memoizedState), null;
      case 27:
        return pushHostContext(workInProgress), null === current && isHydrating && (lazyComponent = workInProgress.stateNode = resolveSingletonInstance(workInProgress.type, workInProgress.pendingProps, rootInstanceStackCursor.current), hydrationParentFiber = workInProgress, rootOrSingletonContext = true, init = nextHydratableInstance, isSingletonScope(workInProgress.type) ? (previousHydratableOnEnteringScopedSingleton = init, nextHydratableInstance = getNextHydratable(lazyComponent.firstChild)) : nextHydratableInstance = init), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), markRef(current, workInProgress), null === current && (workInProgress.flags |= 4194304), workInProgress.child;
      case 5:
        if (null === current && isHydrating) {
          if (init = lazyComponent = nextHydratableInstance) lazyComponent = canHydrateInstance(lazyComponent, workInProgress.type, workInProgress.pendingProps, rootOrSingletonContext), null !== lazyComponent ? (workInProgress.stateNode = lazyComponent, hydrationParentFiber = workInProgress, nextHydratableInstance = getNextHydratable(lazyComponent.firstChild), rootOrSingletonContext = false, init = true) : init = false;
          init || throwOnHydrationMismatch(workInProgress);
        }
        pushHostContext(workInProgress);
        init = workInProgress.type;
        prevState = workInProgress.pendingProps;
        nextState = null !== current ? current.memoizedProps : null;
        lazyComponent = prevState.children;
        shouldSetTextContent(init, prevState) ? lazyComponent = null : null !== nextState && shouldSetTextContent(init, nextState) && (workInProgress.flags |= 32);
        null !== workInProgress.memoizedState && (init = renderWithHooks(current, workInProgress, TransitionAwareHostComponent, null, null, renderLanes), HostTransitionContext._currentValue = init);
        markRef(current, workInProgress);
        reconcileChildren(current, workInProgress, lazyComponent, renderLanes);
        return workInProgress.child;
      case 6:
        if (null === current && isHydrating) {
          if (current = renderLanes = nextHydratableInstance) renderLanes = canHydrateTextInstance(renderLanes, workInProgress.pendingProps, rootOrSingletonContext), null !== renderLanes ? (workInProgress.stateNode = renderLanes, hydrationParentFiber = workInProgress, nextHydratableInstance = null, current = true) : current = false;
          current || throwOnHydrationMismatch(workInProgress);
        }
        return null;
      case 13:
        return updateSuspenseComponent(current, workInProgress, renderLanes);
      case 4:
        return pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), lazyComponent = workInProgress.pendingProps, null === current ? workInProgress.child = reconcileChildFibers(workInProgress, null, lazyComponent, renderLanes) : reconcileChildren(current, workInProgress, lazyComponent, renderLanes), workInProgress.child;
      case 11:
        return updateForwardRef(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
      case 7:
        return reconcileChildren(current, workInProgress, workInProgress.pendingProps, renderLanes), workInProgress.child;
      case 8:
        return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;
      case 12:
        return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;
      case 10:
        return lazyComponent = workInProgress.pendingProps, pushProvider(workInProgress, workInProgress.type, lazyComponent.value), reconcileChildren(current, workInProgress, lazyComponent.children, renderLanes), workInProgress.child;
      case 9:
        return init = workInProgress.type._context, lazyComponent = workInProgress.pendingProps.children, prepareToReadContext(workInProgress), init = readContext(init), lazyComponent = lazyComponent(init), workInProgress.flags |= 1, reconcileChildren(current, workInProgress, lazyComponent, renderLanes), workInProgress.child;
      case 14:
        return updateMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
      case 15:
        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
      case 19:
        return updateSuspenseListComponent(current, workInProgress, renderLanes);
      case 31:
        return lazyComponent = workInProgress.pendingProps, renderLanes = workInProgress.mode, lazyComponent = {
          mode: lazyComponent.mode,
          children: lazyComponent.children
        }, null === current ? (renderLanes = mountWorkInProgressOffscreenFiber(lazyComponent, renderLanes), renderLanes.ref = workInProgress.ref, workInProgress.child = renderLanes, renderLanes.return = workInProgress, workInProgress = renderLanes) : (renderLanes = createWorkInProgress(current.child, lazyComponent), renderLanes.ref = workInProgress.ref, workInProgress.child = renderLanes, renderLanes.return = workInProgress, workInProgress = renderLanes), workInProgress;
      case 22:
        return updateOffscreenComponent(current, workInProgress, renderLanes);
      case 24:
        return prepareToReadContext(workInProgress), lazyComponent = readContext(CacheContext), null === current ? (init = peekCacheFromPool(), null === init && (init = workInProgressRoot, prevState = createCache(), init.pooledCache = prevState, prevState.refCount++, null !== prevState && (init.pooledCacheLanes |= renderLanes), init = prevState), workInProgress.memoizedState = {
          parent: lazyComponent,
          cache: init
        }, initializeUpdateQueue(workInProgress), pushProvider(workInProgress, CacheContext, init)) : (0 !== (current.lanes & renderLanes) && (cloneUpdateQueue(current, workInProgress), processUpdateQueue(workInProgress, null, null, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction()), init = current.memoizedState, prevState = workInProgress.memoizedState, init.parent !== lazyComponent ? (init = {
          parent: lazyComponent,
          cache: lazyComponent
        }, workInProgress.memoizedState = init, 0 === workInProgress.lanes && (workInProgress.memoizedState = workInProgress.updateQueue.baseState = init), pushProvider(workInProgress, CacheContext, lazyComponent)) : (lazyComponent = prevState.cache, pushProvider(workInProgress, CacheContext, lazyComponent), lazyComponent !== init.cache && propagateContextChanges(workInProgress, [CacheContext], renderLanes, true))), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;
      case 29:
        throw workInProgress.pendingProps;
    }
    throw Error(formatProdErrorMessage(156, workInProgress.tag));
  }
  function markUpdate(workInProgress) {
    workInProgress.flags |= 4;
  }
  function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
    if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4)) workInProgress.flags &= -16777217;else if (workInProgress.flags |= 16777216, !preloadResource(resource)) {
      resource = suspenseHandlerStackCursor.current;
      if (null !== resource && ((workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary)) throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
      workInProgress.flags |= 8192;
    }
  }
  function scheduleRetryEffect(workInProgress, retryQueue) {
    null !== retryQueue && (workInProgress.flags |= 4);
    workInProgress.flags & 16384 && (retryQueue = 22 !== workInProgress.tag ? claimNextRetryLane() : 536870912, workInProgress.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
  }
  function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
    if (!isHydrating) switch (renderState.tailMode) {
      case "hidden":
        hasRenderedATailFallback = renderState.tail;
        for (var lastTailNode = null; null !== hasRenderedATailFallback;) null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
        null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
        break;
      case "collapsed":
        lastTailNode = renderState.tail;
        for (var lastTailNode$113 = null; null !== lastTailNode;) null !== lastTailNode.alternate && (lastTailNode$113 = lastTailNode), lastTailNode = lastTailNode.sibling;
        null === lastTailNode$113 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$113.sibling = null;
    }
  }
  function bubbleProperties(completedWork) {
    var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child,
      newChildLanes = 0,
      subtreeFlags = 0;
    if (didBailout) for (var child$114 = completedWork.child; null !== child$114;) newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags & 65011712, subtreeFlags |= child$114.flags & 65011712, child$114.return = completedWork, child$114 = child$114.sibling;else for (child$114 = completedWork.child; null !== child$114;) newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags, subtreeFlags |= child$114.flags, child$114.return = completedWork, child$114 = child$114.sibling;
    completedWork.subtreeFlags |= subtreeFlags;
    completedWork.childLanes = newChildLanes;
    return didBailout;
  }
  function completeWork(current, workInProgress, renderLanes) {
    var newProps = workInProgress.pendingProps;
    popTreeContext(workInProgress);
    switch (workInProgress.tag) {
      case 31:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return bubbleProperties(workInProgress), null;
      case 1:
        return bubbleProperties(workInProgress), null;
      case 3:
        renderLanes = workInProgress.stateNode;
        newProps = null;
        null !== current && (newProps = current.memoizedState.cache);
        workInProgress.memoizedState.cache !== newProps && (workInProgress.flags |= 2048);
        popProvider(CacheContext);
        popHostContainer();
        renderLanes.pendingContext && (renderLanes.context = renderLanes.pendingContext, renderLanes.pendingContext = null);
        if (null === current || null === current.child) popHydrationState(workInProgress) ? markUpdate(workInProgress) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress.flags & 256) || (workInProgress.flags |= 1024, upgradeHydrationErrorsToRecoverable());
        bubbleProperties(workInProgress);
        return null;
      case 26:
        return renderLanes = workInProgress.memoizedState, null === current ? (markUpdate(workInProgress), null !== renderLanes ? (bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217)) : renderLanes ? renderLanes !== current.memoizedState ? (markUpdate(workInProgress), bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217) : (current.memoizedProps !== newProps && markUpdate(workInProgress), bubbleProperties(workInProgress), workInProgress.flags &= -16777217), null;
      case 27:
        popHostContext(workInProgress);
        renderLanes = rootInstanceStackCursor.current;
        var type = workInProgress.type;
        if (null !== current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);else {
          if (!newProps) {
            if (null === workInProgress.stateNode) throw Error(formatProdErrorMessage(166));
            bubbleProperties(workInProgress);
            return null;
          }
          current = contextStackCursor.current;
          popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress, current) : (current = resolveSingletonInstance(type, newProps, renderLanes), workInProgress.stateNode = current, markUpdate(workInProgress));
        }
        bubbleProperties(workInProgress);
        return null;
      case 5:
        popHostContext(workInProgress);
        renderLanes = workInProgress.type;
        if (null !== current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);else {
          if (!newProps) {
            if (null === workInProgress.stateNode) throw Error(formatProdErrorMessage(166));
            bubbleProperties(workInProgress);
            return null;
          }
          current = contextStackCursor.current;
          if (popHydrationState(workInProgress)) prepareToHydrateHostInstance(workInProgress, current);else {
            type = getOwnerDocumentFromRootContainer(rootInstanceStackCursor.current);
            switch (current) {
              case 1:
                current = type.createElementNS("http://www.w3.org/2000/svg", renderLanes);
                break;
              case 2:
                current = type.createElementNS("http://www.w3.org/1998/Math/MathML", renderLanes);
                break;
              default:
                switch (renderLanes) {
                  case "svg":
                    current = type.createElementNS("http://www.w3.org/2000/svg", renderLanes);
                    break;
                  case "math":
                    current = type.createElementNS("http://www.w3.org/1998/Math/MathML", renderLanes);
                    break;
                  case "script":
                    current = type.createElement("div");
                    current.innerHTML = "<script>\x3c/script>";
                    current = current.removeChild(current.firstChild);
                    break;
                  case "select":
                    current = "string" === typeof newProps.is ? type.createElement("select", {
                      is: newProps.is
                    }) : type.createElement("select");
                    newProps.multiple ? current.multiple = true : newProps.size && (current.size = newProps.size);
                    break;
                  default:
                    current = "string" === typeof newProps.is ? type.createElement(renderLanes, {
                      is: newProps.is
                    }) : type.createElement(renderLanes);
                }
            }
            current[internalInstanceKey] = workInProgress;
            current[internalPropsKey] = newProps;
            a: for (type = workInProgress.child; null !== type;) {
              if (5 === type.tag || 6 === type.tag) current.appendChild(type.stateNode);else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {
                type.child.return = type;
                type = type.child;
                continue;
              }
              if (type === workInProgress) break a;
              for (; null === type.sibling;) {
                if (null === type.return || type.return === workInProgress) break a;
                type = type.return;
              }
              type.sibling.return = type.return;
              type = type.sibling;
            }
            workInProgress.stateNode = current;
            a: switch (setInitialProperties(current, renderLanes, newProps), renderLanes) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                current = !!newProps.autoFocus;
                break a;
              case "img":
                current = true;
                break a;
              default:
                current = false;
            }
            current && markUpdate(workInProgress);
          }
        }
        bubbleProperties(workInProgress);
        workInProgress.flags &= -16777217;
        return null;
      case 6:
        if (current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);else {
          if ("string" !== typeof newProps && null === workInProgress.stateNode) throw Error(formatProdErrorMessage(166));
          current = rootInstanceStackCursor.current;
          if (popHydrationState(workInProgress)) {
            current = workInProgress.stateNode;
            renderLanes = workInProgress.memoizedProps;
            newProps = null;
            type = hydrationParentFiber;
            if (null !== type) switch (type.tag) {
              case 27:
              case 5:
                newProps = type.memoizedProps;
            }
            current[internalInstanceKey] = workInProgress;
            current = current.nodeValue === renderLanes || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes) ? true : false;
            current || throwOnHydrationMismatch(workInProgress);
          } else current = getOwnerDocumentFromRootContainer(current).createTextNode(newProps), current[internalInstanceKey] = workInProgress, workInProgress.stateNode = current;
        }
        bubbleProperties(workInProgress);
        return null;
      case 13:
        newProps = workInProgress.memoizedState;
        if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
          type = popHydrationState(workInProgress);
          if (null !== newProps && null !== newProps.dehydrated) {
            if (null === current) {
              if (!type) throw Error(formatProdErrorMessage(318));
              type = workInProgress.memoizedState;
              type = null !== type ? type.dehydrated : null;
              if (!type) throw Error(formatProdErrorMessage(317));
              type[internalInstanceKey] = workInProgress;
            } else resetHydrationState(), 0 === (workInProgress.flags & 128) && (workInProgress.memoizedState = null), workInProgress.flags |= 4;
            bubbleProperties(workInProgress);
            type = false;
          } else type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
          if (!type) {
            if (workInProgress.flags & 256) return popSuspenseHandler(workInProgress), workInProgress;
            popSuspenseHandler(workInProgress);
            return null;
          }
        }
        popSuspenseHandler(workInProgress);
        if (0 !== (workInProgress.flags & 128)) return workInProgress.lanes = renderLanes, workInProgress;
        renderLanes = null !== newProps;
        current = null !== current && null !== current.memoizedState;
        if (renderLanes) {
          newProps = workInProgress.child;
          type = null;
          null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool);
          var cache$127 = null;
          null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (cache$127 = newProps.memoizedState.cachePool.pool);
          cache$127 !== type && (newProps.flags |= 2048);
        }
        renderLanes !== current && renderLanes && (workInProgress.child.flags |= 8192);
        scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
        bubbleProperties(workInProgress);
        return null;
      case 4:
        return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress.stateNode.containerInfo), bubbleProperties(workInProgress), null;
      case 10:
        return popProvider(workInProgress.type), bubbleProperties(workInProgress), null;
      case 19:
        pop(suspenseStackCursor);
        type = workInProgress.memoizedState;
        if (null === type) return bubbleProperties(workInProgress), null;
        newProps = 0 !== (workInProgress.flags & 128);
        cache$127 = type.rendering;
        if (null === cache$127) {
          if (newProps) cutOffTailIfNeeded(type, false);else {
            if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128)) for (current = workInProgress.child; null !== current;) {
              cache$127 = findFirstSuspended(current);
              if (null !== cache$127) {
                workInProgress.flags |= 128;
                cutOffTailIfNeeded(type, false);
                current = cache$127.updateQueue;
                workInProgress.updateQueue = current;
                scheduleRetryEffect(workInProgress, current);
                workInProgress.subtreeFlags = 0;
                current = renderLanes;
                for (renderLanes = workInProgress.child; null !== renderLanes;) resetWorkInProgress(renderLanes, current), renderLanes = renderLanes.sibling;
                push(suspenseStackCursor, suspenseStackCursor.current & 1 | 2);
                return workInProgress.child;
              }
              current = current.sibling;
            }
            null !== type.tail && now() > workInProgressRootRenderTargetTime && (workInProgress.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress.lanes = 4194304);
          }
        } else {
          if (!newProps) if (current = findFirstSuspended(cache$127), null !== current) {
            if (workInProgress.flags |= 128, newProps = true, current = current.updateQueue, workInProgress.updateQueue = current, scheduleRetryEffect(workInProgress, current), cutOffTailIfNeeded(type, true), null === type.tail && "hidden" === type.tailMode && !cache$127.alternate && !isHydrating) return bubbleProperties(workInProgress), null;
          } else 2 * now() - type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes && (workInProgress.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress.lanes = 4194304);
          type.isBackwards ? (cache$127.sibling = workInProgress.child, workInProgress.child = cache$127) : (current = type.last, null !== current ? current.sibling = cache$127 : workInProgress.child = cache$127, type.last = cache$127);
        }
        if (null !== type.tail) return workInProgress = type.tail, type.rendering = workInProgress, type.tail = workInProgress.sibling, type.renderingStartTime = now(), workInProgress.sibling = null, current = suspenseStackCursor.current, push(suspenseStackCursor, newProps ? current & 1 | 2 : current & 1), workInProgress;
        bubbleProperties(workInProgress);
        return null;
      case 22:
      case 23:
        return popSuspenseHandler(workInProgress), popHiddenContext(), newProps = null !== workInProgress.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress.flags |= 8192) : newProps && (workInProgress.flags |= 8192), newProps ? 0 !== (renderLanes & 536870912) && 0 === (workInProgress.flags & 128) && (bubbleProperties(workInProgress), workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192)) : bubbleProperties(workInProgress), renderLanes = workInProgress.updateQueue, null !== renderLanes && scheduleRetryEffect(workInProgress, renderLanes.retryQueue), renderLanes = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress.memoizedState && null !== workInProgress.memoizedState.cachePool && (newProps = workInProgress.memoizedState.cachePool.pool), newProps !== renderLanes && (workInProgress.flags |= 2048), null !== current && pop(resumedCache), null;
      case 24:
        return renderLanes = null, null !== current && (renderLanes = current.memoizedState.cache), workInProgress.memoizedState.cache !== renderLanes && (workInProgress.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(formatProdErrorMessage(156, workInProgress.tag));
  }
  function unwindWork(current, workInProgress) {
    popTreeContext(workInProgress);
    switch (workInProgress.tag) {
      case 1:
        return current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;
      case 3:
        return popProvider(CacheContext), popHostContainer(), current = workInProgress.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;
      case 26:
      case 27:
      case 5:
        return popHostContext(workInProgress), null;
      case 13:
        popSuspenseHandler(workInProgress);
        current = workInProgress.memoizedState;
        if (null !== current && null !== current.dehydrated) {
          if (null === workInProgress.alternate) throw Error(formatProdErrorMessage(340));
          resetHydrationState();
        }
        current = workInProgress.flags;
        return current & 65536 ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;
      case 19:
        return pop(suspenseStackCursor), null;
      case 4:
        return popHostContainer(), null;
      case 10:
        return popProvider(workInProgress.type), null;
      case 22:
      case 23:
        return popSuspenseHandler(workInProgress), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;
      case 24:
        return popProvider(CacheContext), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function unwindInterruptedWork(current, interruptedWork) {
    popTreeContext(interruptedWork);
    switch (interruptedWork.tag) {
      case 3:
        popProvider(CacheContext);
        popHostContainer();
        break;
      case 26:
      case 27:
      case 5:
        popHostContext(interruptedWork);
        break;
      case 4:
        popHostContainer();
        break;
      case 13:
        popSuspenseHandler(interruptedWork);
        break;
      case 19:
        pop(suspenseStackCursor);
        break;
      case 10:
        popProvider(interruptedWork.type);
        break;
      case 22:
      case 23:
        popSuspenseHandler(interruptedWork);
        popHiddenContext();
        null !== current && pop(resumedCache);
        break;
      case 24:
        popProvider(CacheContext);
    }
  }
  function commitHookEffectListMount(flags, finishedWork) {
    try {
      var updateQueue = finishedWork.updateQueue,
        lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
      if (null !== lastEffect) {
        var firstEffect = lastEffect.next;
        updateQueue = firstEffect;
        do {
          if ((updateQueue.tag & flags) === flags) {
            lastEffect = undefined;
            var create = updateQueue.create,
              inst = updateQueue.inst;
            lastEffect = create();
            inst.destroy = lastEffect;
          }
          updateQueue = updateQueue.next;
        } while (updateQueue !== firstEffect);
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
    try {
      var updateQueue = finishedWork.updateQueue,
        lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
      if (null !== lastEffect) {
        var firstEffect = lastEffect.next;
        updateQueue = firstEffect;
        do {
          if ((updateQueue.tag & flags) === flags) {
            var inst = updateQueue.inst,
              destroy = inst.destroy;
            if (undefined !== destroy) {
              inst.destroy = undefined;
              lastEffect = finishedWork;
              var nearestMountedAncestor = nearestMountedAncestor$jscomp$0,
                destroy_ = destroy;
              try {
                destroy_();
              } catch (error) {
                captureCommitPhaseError(lastEffect, nearestMountedAncestor, error);
              }
            }
          }
          updateQueue = updateQueue.next;
        } while (updateQueue !== firstEffect);
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function commitClassCallbacks(finishedWork) {
    var updateQueue = finishedWork.updateQueue;
    if (null !== updateQueue) {
      var instance = finishedWork.stateNode;
      try {
        commitCallbacks(updateQueue, instance);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
  }
  function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
    instance.props = resolveClassComponentProps(current.type, current.memoizedProps);
    instance.state = current.memoizedState;
    try {
      instance.componentWillUnmount();
    } catch (error) {
      captureCommitPhaseError(current, nearestMountedAncestor, error);
    }
  }
  function safelyAttachRef(current, nearestMountedAncestor) {
    try {
      var ref = current.ref;
      if (null !== ref) {
        switch (current.tag) {
          case 26:
          case 27:
          case 5:
            var instanceToUse = current.stateNode;
            break;
          case 30:
            instanceToUse = current.stateNode;
            break;
          default:
            instanceToUse = current.stateNode;
        }
        "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
      }
    } catch (error) {
      captureCommitPhaseError(current, nearestMountedAncestor, error);
    }
  }
  function safelyDetachRef(current, nearestMountedAncestor) {
    var ref = current.ref,
      refCleanup = current.refCleanup;
    if (null !== ref) if ("function" === typeof refCleanup) try {
      refCleanup();
    } catch (error) {
      captureCommitPhaseError(current, nearestMountedAncestor, error);
    } finally {
      current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
    } else if ("function" === typeof ref) try {
      ref(null);
    } catch (error$143) {
      captureCommitPhaseError(current, nearestMountedAncestor, error$143);
    } else ref.current = null;
  }
  function commitHostMount(finishedWork) {
    var type = finishedWork.type,
      props = finishedWork.memoizedProps,
      instance = finishedWork.stateNode;
    try {
      a: switch (type) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          props.autoFocus && instance.focus();
          break a;
        case "img":
          props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function commitHostUpdate(finishedWork, newProps, oldProps) {
    try {
      var domElement = finishedWork.stateNode;
      updateProperties(domElement, finishedWork.type, oldProps, newProps);
      domElement[internalPropsKey] = newProps;
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function isHostParent(fiber) {
    return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
  }
  function getHostSibling(fiber) {
    a: for (;;) {
      for (; null === fiber.sibling;) {
        if (null === fiber.return || isHostParent(fiber.return)) return null;
        fiber = fiber.return;
      }
      fiber.sibling.return = fiber.return;
      for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;) {
        if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
        if (fiber.flags & 2) continue a;
        if (null === fiber.child || 4 === fiber.tag) continue a;else fiber.child.return = fiber, fiber = fiber.child;
      }
      if (!(fiber.flags & 2)) return fiber.stateNode;
    }
  }
  function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
    var tag = node.tag;
    if (5 === tag || 6 === tag) node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && undefined !== parent || null !== before.onclick || (before.onclick = noop$1));else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node)) for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node;) insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
  }
  function insertOrAppendPlacementNode(node, before, parent) {
    var tag = node.tag;
    if (5 === tag || 6 === tag) node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node)) for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node;) insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
  }
  function commitHostSingletonAcquisition(finishedWork) {
    var singleton = finishedWork.stateNode,
      props = finishedWork.memoizedProps;
    try {
      for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length;) singleton.removeAttributeNode(attributes[0]);
      setInitialProperties(singleton, type, props);
      singleton[internalInstanceKey] = finishedWork;
      singleton[internalPropsKey] = props;
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  var offscreenSubtreeIsHidden = false,
    offscreenSubtreeWasHidden = false,
    needsFormReset = false,
    PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
    nextEffect = null;
  function commitBeforeMutationEffects(root, firstChild) {
    root = root.containerInfo;
    eventsEnabled = _enabled;
    root = getActiveElementDeep(root);
    if (hasSelectionCapabilities(root)) {
      if ("selectionStart" in root) var JSCompiler_temp = {
        start: root.selectionStart,
        end: root.selectionEnd
      };else a: {
        JSCompiler_temp = (JSCompiler_temp = root.ownerDocument) && JSCompiler_temp.defaultView || window;
        var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
        if (selection && 0 !== selection.rangeCount) {
          JSCompiler_temp = selection.anchorNode;
          var anchorOffset = selection.anchorOffset,
            focusNode = selection.focusNode;
          selection = selection.focusOffset;
          try {
            JSCompiler_temp.nodeType, focusNode.nodeType;
          } catch (e$20) {
            JSCompiler_temp = null;
            break a;
          }
          var length = 0,
            start = -1,
            end = -1,
            indexWithinAnchor = 0,
            indexWithinFocus = 0,
            node = root,
            parentNode = null;
          b: for (;;) {
            for (var next;;) {
              node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
              node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
              3 === node.nodeType && (length += node.nodeValue.length);
              if (null === (next = node.firstChild)) break;
              parentNode = node;
              node = next;
            }
            for (;;) {
              if (node === root) break b;
              parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
              parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
              if (null !== (next = node.nextSibling)) break;
              node = parentNode;
              parentNode = node.parentNode;
            }
            node = next;
          }
          JSCompiler_temp = -1 === start || -1 === end ? null : {
            start: start,
            end: end
          };
        } else JSCompiler_temp = null;
      }
      JSCompiler_temp = JSCompiler_temp || {
        start: 0,
        end: 0
      };
    } else JSCompiler_temp = null;
    selectionInformation = {
      focusedElem: root,
      selectionRange: JSCompiler_temp
    };
    _enabled = false;
    for (nextEffect = firstChild; null !== nextEffect;) if (firstChild = nextEffect, root = firstChild.child, 0 !== (firstChild.subtreeFlags & 1024) && null !== root) root.return = firstChild, nextEffect = root;else for (; null !== nextEffect;) {
      firstChild = nextEffect;
      focusNode = firstChild.alternate;
      root = firstChild.flags;
      switch (firstChild.tag) {
        case 0:
          break;
        case 11:
        case 15:
          break;
        case 1:
          if (0 !== (root & 1024) && null !== focusNode) {
            root = undefined;
            JSCompiler_temp = firstChild;
            anchorOffset = focusNode.memoizedProps;
            focusNode = focusNode.memoizedState;
            selection = JSCompiler_temp.stateNode;
            try {
              var resolvedPrevProps = resolveClassComponentProps(JSCompiler_temp.type, anchorOffset, JSCompiler_temp.elementType === JSCompiler_temp.type);
              root = selection.getSnapshotBeforeUpdate(resolvedPrevProps, focusNode);
              selection.__reactInternalSnapshotBeforeUpdate = root;
            } catch (error) {
              captureCommitPhaseError(JSCompiler_temp, JSCompiler_temp.return, error);
            }
          }
          break;
        case 3:
          if (0 !== (root & 1024)) if (root = firstChild.stateNode.containerInfo, JSCompiler_temp = root.nodeType, 9 === JSCompiler_temp) clearContainerSparingly(root);else if (1 === JSCompiler_temp) switch (root.nodeName) {
            case "HEAD":
            case "HTML":
            case "BODY":
              clearContainerSparingly(root);
              break;
            default:
              root.textContent = "";
          }
          break;
        case 5:
        case 26:
        case 27:
        case 6:
        case 4:
        case 17:
          break;
        default:
          if (0 !== (root & 1024)) throw Error(formatProdErrorMessage(163));
      }
      root = firstChild.sibling;
      if (null !== root) {
        root.return = firstChild.return;
        nextEffect = root;
        break;
      }
      nextEffect = firstChild.return;
    }
  }
  function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
    var flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        flags & 4 && commitHookEffectListMount(5, finishedWork);
        break;
      case 1:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        if (flags & 4) if (finishedRoot = finishedWork.stateNode, null === current) try {
          finishedRoot.componentDidMount();
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        } else {
          var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);
          current = current.memoizedState;
          try {
            finishedRoot.componentDidUpdate(prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate);
          } catch (error$142) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error$142);
          }
        }
        flags & 64 && commitClassCallbacks(finishedWork);
        flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 3:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
          current = null;
          if (null !== finishedWork.child) switch (finishedWork.child.tag) {
            case 27:
            case 5:
              current = finishedWork.child.stateNode;
              break;
            case 1:
              current = finishedWork.child.stateNode;
          }
          try {
            commitCallbacks(finishedRoot, current);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        break;
      case 27:
        null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
      case 26:
      case 5:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        null === current && flags & 4 && commitHostMount(finishedWork);
        flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 12:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        break;
      case 13:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
        flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(null, finishedWork), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
        break;
      case 22:
        flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
        if (!flags) {
          current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
          prevProps = offscreenSubtreeIsHidden;
          var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = flags;
          (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, 0 !== (finishedWork.subtreeFlags & 8772)) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          offscreenSubtreeIsHidden = prevProps;
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
        }
        break;
      case 30:
        break;
      default:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
    }
  }
  function detachFiberAfterEffects(fiber) {
    var alternate = fiber.alternate;
    null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
    fiber.child = null;
    fiber.deletions = null;
    fiber.sibling = null;
    5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
    fiber.stateNode = null;
    fiber.return = null;
    fiber.dependencies = null;
    fiber.memoizedProps = null;
    fiber.memoizedState = null;
    fiber.pendingProps = null;
    fiber.stateNode = null;
    fiber.updateQueue = null;
  }
  var hostParent = null,
    hostParentIsContainer = false;
  function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
    for (parent = parent.child; null !== parent;) commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
  }
  function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
    if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount) try {
      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
    } catch (err) {}
    switch (deletedFiber.tag) {
      case 26:
        offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
        deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
        break;
      case 27:
        offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        var prevHostParent = hostParent,
          prevHostParentIsContainer = hostParentIsContainer;
        isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
        releaseSingletonInstance(deletedFiber.stateNode);
        hostParent = prevHostParent;
        hostParentIsContainer = prevHostParentIsContainer;
        break;
      case 5:
        offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
      case 6:
        prevHostParent = hostParent;
        prevHostParentIsContainer = hostParentIsContainer;
        hostParent = null;
        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
        hostParent = prevHostParent;
        hostParentIsContainer = prevHostParentIsContainer;
        if (null !== hostParent) if (hostParentIsContainer) try {
          (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
        } catch (error) {
          captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
        } else try {
          hostParent.removeChild(deletedFiber.stateNode);
        } catch (error) {
          captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
        }
        break;
      case 18:
        null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearSuspenseBoundary(9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot, deletedFiber.stateNode), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
        break;
      case 4:
        prevHostParent = hostParent;
        prevHostParentIsContainer = hostParentIsContainer;
        hostParent = deletedFiber.stateNode.containerInfo;
        hostParentIsContainer = true;
        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
        hostParent = prevHostParent;
        hostParentIsContainer = prevHostParentIsContainer;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        offscreenSubtreeWasHidden || commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
        offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
        break;
      case 1:
        offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));
        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
        break;
      case 21:
        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
        break;
      case 22:
        offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
        offscreenSubtreeWasHidden = prevHostParent;
        break;
      default:
        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
    }
  }
  function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
    if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot)))) try {
      retryIfBlockedOn(finishedRoot);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function getRetryCache(finishedWork) {
    switch (finishedWork.tag) {
      case 13:
      case 19:
        var retryCache = finishedWork.stateNode;
        null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
        return retryCache;
      case 22:
        return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
      default:
        throw Error(formatProdErrorMessage(435, finishedWork.tag));
    }
  }
  function attachSuspenseRetryListeners(finishedWork, wakeables) {
    var retryCache = getRetryCache(finishedWork);
    wakeables.forEach(function (wakeable) {
      var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
      retryCache.has(wakeable) || (retryCache.add(wakeable), wakeable.then(retry, retry));
    });
  }
  function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
    var deletions = parentFiber.deletions;
    if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
      var childToDelete = deletions[i],
        root = root$jscomp$0,
        returnFiber = parentFiber,
        parent = returnFiber;
      a: for (; null !== parent;) {
        switch (parent.tag) {
          case 27:
            if (isSingletonScope(parent.type)) {
              hostParent = parent.stateNode;
              hostParentIsContainer = false;
              break a;
            }
            break;
          case 5:
            hostParent = parent.stateNode;
            hostParentIsContainer = false;
            break a;
          case 3:
          case 4:
            hostParent = parent.stateNode.containerInfo;
            hostParentIsContainer = true;
            break a;
        }
        parent = parent.return;
      }
      if (null === hostParent) throw Error(formatProdErrorMessage(160));
      commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
      hostParent = null;
      hostParentIsContainer = false;
      root = childToDelete.alternate;
      null !== root && (root.return = null);
      childToDelete.return = null;
    }
    if (parentFiber.subtreeFlags & 13878) for (parentFiber = parentFiber.child; null !== parentFiber;) commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
  }
  var currentHoistableRoot = null;
  function commitMutationEffectsOnFiber(finishedWork, root) {
    var current = finishedWork.alternate,
      flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
        break;
      case 1:
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
        flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
        break;
      case 26:
        var hoistableRoot = currentHoistableRoot;
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
        if (flags & 4) {
          var currentResource = null !== current ? current.memoizedState : null;
          flags = finishedWork.memoizedState;
          if (null === current) {
            if (null === flags) {
              if (null === finishedWork.stateNode) {
                a: {
                  flags = finishedWork.type;
                  current = finishedWork.memoizedProps;
                  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                  b: switch (flags) {
                    case "title":
                      currentResource = hoistableRoot.getElementsByTagName("title")[0];
                      if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop")) currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(currentResource, hoistableRoot.querySelector("head > title"));
                      setInitialProperties(currentResource, flags, current);
                      currentResource[internalInstanceKey] = finishedWork;
                      markNodeAsHoistable(currentResource);
                      flags = currentResource;
                      break a;
                    case "link":
                      var maybeNodes = getHydratableHoistableCache("link", "href", hoistableRoot).get(flags + (current.href || ""));
                      if (maybeNodes) for (var i = 0; i < maybeNodes.length; i++) if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                        maybeNodes.splice(i, 1);
                        break b;
                      }
                      currentResource = hoistableRoot.createElement(flags);
                      setInitialProperties(currentResource, flags, current);
                      hoistableRoot.head.appendChild(currentResource);
                      break;
                    case "meta":
                      if (maybeNodes = getHydratableHoistableCache("meta", "content", hoistableRoot).get(flags + (current.content || ""))) for (i = 0; i < maybeNodes.length; i++) if (currentResource = maybeNodes[i], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                        maybeNodes.splice(i, 1);
                        break b;
                      }
                      currentResource = hoistableRoot.createElement(flags);
                      setInitialProperties(currentResource, flags, current);
                      hoistableRoot.head.appendChild(currentResource);
                      break;
                    default:
                      throw Error(formatProdErrorMessage(468, flags));
                  }
                  currentResource[internalInstanceKey] = finishedWork;
                  markNodeAsHoistable(currentResource);
                  flags = currentResource;
                }
                finishedWork.stateNode = flags;
              } else mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode);
            } else finishedWork.stateNode = acquireResource(hoistableRoot, flags, finishedWork.memoizedProps);
          } else currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, flags, finishedWork.memoizedProps)) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);
        }
        break;
      case 27:
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
        null !== current && flags & 4 && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);
        break;
      case 5:
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
        if (finishedWork.flags & 32) {
          hoistableRoot = finishedWork.stateNode;
          try {
            setTextContent(hoistableRoot, "");
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(finishedWork, hoistableRoot, null !== current ? current.memoizedProps : hoistableRoot));
        flags & 1024 && (needsFormReset = true);
        break;
      case 6:
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        if (flags & 4) {
          if (null === finishedWork.stateNode) throw Error(formatProdErrorMessage(162));
          flags = finishedWork.memoizedProps;
          current = finishedWork.stateNode;
          try {
            current.nodeValue = flags;
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        break;
      case 3:
        tagCaches = null;
        hoistableRoot = currentHoistableRoot;
        currentHoistableRoot = getHoistableRoot(root.containerInfo);
        recursivelyTraverseMutationEffects(root, finishedWork);
        currentHoistableRoot = hoistableRoot;
        commitReconciliationEffects(finishedWork);
        if (flags & 4 && null !== current && current.memoizedState.isDehydrated) try {
          retryIfBlockedOn(root.containerInfo);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
        break;
      case 4:
        flags = currentHoistableRoot;
        currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo);
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        currentHoistableRoot = flags;
        break;
      case 12:
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        break;
      case 13:
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
        flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
        break;
      case 22:
        hoistableRoot = null !== finishedWork.memoizedState;
        var wasHidden = null !== current && null !== current.memoizedState,
          prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
          prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
        recursivelyTraverseMutationEffects(root, finishedWork);
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
        commitReconciliationEffects(finishedWork);
        if (flags & 8192) a: for (root = finishedWork.stateNode, root._visibility = hoistableRoot ? root._visibility & -2 : root._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root = finishedWork;;) {
          if (5 === root.tag || 26 === root.tag) {
            if (null === current) {
              wasHidden = current = root;
              try {
                if (currentResource = wasHidden.stateNode, hoistableRoot) maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";else {
                  i = wasHidden.stateNode;
                  var styleProp = wasHidden.memoizedProps.style,
                    display = undefined !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                  i.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                }
              } catch (error) {
                captureCommitPhaseError(wasHidden, wasHidden.return, error);
              }
            }
          } else if (6 === root.tag) {
            if (null === current) {
              wasHidden = root;
              try {
                wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
              } catch (error) {
                captureCommitPhaseError(wasHidden, wasHidden.return, error);
              }
            }
          } else if ((22 !== root.tag && 23 !== root.tag || null === root.memoizedState || root === finishedWork) && null !== root.child) {
            root.child.return = root;
            root = root.child;
            continue;
          }
          if (root === finishedWork) break a;
          for (; null === root.sibling;) {
            if (null === root.return || root.return === finishedWork) break a;
            current === root && (current = null);
            root = root.return;
          }
          current === root && (current = null);
          root.sibling.return = root.return;
          root = root.sibling;
        }
        flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
        break;
      case 19:
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);
    }
  }
  function commitReconciliationEffects(finishedWork) {
    var flags = finishedWork.flags;
    if (flags & 2) {
      try {
        for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber;) {
          if (isHostParent(parentFiber)) {
            hostParentFiber = parentFiber;
            break;
          }
          parentFiber = parentFiber.return;
        }
        if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
        switch (hostParentFiber.tag) {
          case 27:
            var parent = hostParentFiber.stateNode,
              before = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, before, parent);
            break;
          case 5:
            var parent$144 = hostParentFiber.stateNode;
            hostParentFiber.flags & 32 && (setTextContent(parent$144, ""), hostParentFiber.flags &= -33);
            var before$145 = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, before$145, parent$144);
            break;
          case 3:
          case 4:
            var parent$146 = hostParentFiber.stateNode.containerInfo,
              before$147 = getHostSibling(finishedWork);
            insertOrAppendPlacementNodeIntoContainer(finishedWork, before$147, parent$146);
            break;
          default:
            throw Error(formatProdErrorMessage(161));
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
      finishedWork.flags &= -3;
    }
    flags & 4096 && (finishedWork.flags &= -4097);
  }
  function recursivelyResetForms(parentFiber) {
    if (parentFiber.subtreeFlags & 1024) for (parentFiber = parentFiber.child; null !== parentFiber;) {
      var fiber = parentFiber;
      recursivelyResetForms(fiber);
      5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
      parentFiber = parentFiber.sibling;
    }
  }
  function recursivelyTraverseLayoutEffects(root, parentFiber) {
    if (parentFiber.subtreeFlags & 8772) for (parentFiber = parentFiber.child; null !== parentFiber;) commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
  }
  function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
    for (parentFiber = parentFiber.child; null !== parentFiber;) {
      var finishedWork = parentFiber;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 1:
          safelyDetachRef(finishedWork, finishedWork.return);
          var instance = finishedWork.stateNode;
          "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 27:
          releaseSingletonInstance(finishedWork.stateNode);
        case 26:
        case 5:
          safelyDetachRef(finishedWork, finishedWork.return);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 22:
          null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 30:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        default:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
      }
      parentFiber = parentFiber.sibling;
    }
  }
  function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
    includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
    for (parentFiber = parentFiber.child; null !== parentFiber;) {
      var current = parentFiber.alternate,
        finishedRoot = finishedRoot$jscomp$0,
        finishedWork = parentFiber,
        flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          commitHookEffectListMount(4, finishedWork);
          break;
        case 1:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          current = finishedWork;
          finishedRoot = current.stateNode;
          if ("function" === typeof finishedRoot.componentDidMount) try {
            finishedRoot.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(current, current.return, error);
          }
          current = finishedWork;
          finishedRoot = current.updateQueue;
          if (null !== finishedRoot) {
            var instance = current.stateNode;
            try {
              var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
              if (null !== hiddenCallbacks) for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++) callCallback(hiddenCallbacks[finishedRoot], instance);
            } catch (error) {
              captureCommitPhaseError(current, current.return, error);
            }
          }
          includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 27:
          commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          break;
        case 13:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 22:
          null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 30:
          break;
        default:
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
      }
      parentFiber = parentFiber.sibling;
    }
  }
  function commitOffscreenPassiveMountEffects(current, finishedWork) {
    var previousCache = null;
    null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
    current = null;
    null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
    current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
  }
  function commitCachePassiveMountEffect(current, finishedWork) {
    current = null;
    null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
    finishedWork = finishedWork.memoizedState.cache;
    finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
  }
  function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {
    if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) commitPassiveMountOnFiber(root, parentFiber, committedLanes, committedTransitions), parentFiber = parentFiber.sibling;
  }
  function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
    var flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
        flags & 2048 && commitHookEffectListMount(9, finishedWork);
        break;
      case 1:
        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
        break;
      case 3:
        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
        flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
        break;
      case 12:
        if (flags & 2048) {
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
          finishedRoot = finishedWork.stateNode;
          try {
            var _finishedWork$memoize2 = finishedWork.memoizedProps,
              id = _finishedWork$memoize2.id,
              onPostCommit = _finishedWork$memoize2.onPostCommit;
            "function" === typeof onPostCommit && onPostCommit(id, null === finishedWork.alternate ? "mount" : "update", finishedRoot.passiveEffectDuration, -0);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        } else recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
        break;
      case 13:
        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
        break;
      case 23:
        break;
      case 22:
        _finishedWork$memoize2 = finishedWork.stateNode;
        id = finishedWork.alternate;
        null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, 0 !== (finishedWork.subtreeFlags & 10256)));
        flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
        break;
      case 24:
        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
        flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
        break;
      default:
        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
    }
  }
  function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
    includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
    for (parentFiber = parentFiber.child; null !== parentFiber;) {
      var finishedRoot = finishedRoot$jscomp$0,
        finishedWork = parentFiber,
        committedLanes = committedLanes$jscomp$0,
        committedTransitions = committedTransitions$jscomp$0,
        flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
          commitHookEffectListMount(8, finishedWork);
          break;
        case 23:
          break;
        case 22:
          var instance = finishedWork.stateNode;
          null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects));
          includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
          break;
        case 24:
          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
          includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
      }
      parentFiber = parentFiber.sibling;
    }
  }
  function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
    if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) {
      var finishedRoot = finishedRoot$jscomp$0,
        finishedWork = parentFiber,
        flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 22:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
          break;
        case 24:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
      }
      parentFiber = parentFiber.sibling;
    }
  }
  var suspenseyCommitFlag = 8192;
  function recursivelyAccumulateSuspenseyCommit(parentFiber) {
    if (parentFiber.subtreeFlags & suspenseyCommitFlag) for (parentFiber = parentFiber.child; null !== parentFiber;) accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
  }
  function accumulateSuspenseyCommitOnFiber(fiber) {
    switch (fiber.tag) {
      case 26:
        recursivelyAccumulateSuspenseyCommit(fiber);
        fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps);
        break;
      case 5:
        recursivelyAccumulateSuspenseyCommit(fiber);
        break;
      case 3:
      case 4:
        var previousHoistableRoot = currentHoistableRoot;
        currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
        recursivelyAccumulateSuspenseyCommit(fiber);
        currentHoistableRoot = previousHoistableRoot;
        break;
      case 22:
        null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
        break;
      default:
        recursivelyAccumulateSuspenseyCommit(fiber);
    }
  }
  function detachAlternateSiblings(parentFiber) {
    var previousFiber = parentFiber.alternate;
    if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
      previousFiber.child = null;
      do previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber; while (null !== parentFiber);
    }
  }
  function recursivelyTraversePassiveUnmountEffects(parentFiber) {
    var deletions = parentFiber.deletions;
    if (0 !== (parentFiber.flags & 16)) {
      if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
        var childToDelete = deletions[i];
        nextEffect = childToDelete;
        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
      }
      detachAlternateSiblings(parentFiber);
    }
    if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
  }
  function commitPassiveUnmountOnFiber(finishedWork) {
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraversePassiveUnmountEffects(finishedWork);
        finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
        break;
      case 3:
        recursivelyTraversePassiveUnmountEffects(finishedWork);
        break;
      case 12:
        recursivelyTraversePassiveUnmountEffects(finishedWork);
        break;
      case 22:
        var instance = finishedWork.stateNode;
        null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
        break;
      default:
        recursivelyTraversePassiveUnmountEffects(finishedWork);
    }
  }
  function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
    var deletions = parentFiber.deletions;
    if (0 !== (parentFiber.flags & 16)) {
      if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
        var childToDelete = deletions[i];
        nextEffect = childToDelete;
        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
      }
      detachAlternateSiblings(parentFiber);
    }
    for (parentFiber = parentFiber.child; null !== parentFiber;) {
      deletions = parentFiber;
      switch (deletions.tag) {
        case 0:
        case 11:
        case 15:
          commitHookEffectListUnmount(8, deletions, deletions.return);
          recursivelyTraverseDisconnectPassiveEffects(deletions);
          break;
        case 22:
          i = deletions.stateNode;
          i._visibility & 2 && (i._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
          break;
        default:
          recursivelyTraverseDisconnectPassiveEffects(deletions);
      }
      parentFiber = parentFiber.sibling;
    }
  }
  function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
    for (; null !== nextEffect;) {
      var fiber = nextEffect;
      switch (fiber.tag) {
        case 0:
        case 11:
        case 15:
          commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
          break;
        case 23:
        case 22:
          if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
            var cache = fiber.memoizedState.cachePool.pool;
            null != cache && cache.refCount++;
          }
          break;
        case 24:
          releaseCache(fiber.memoizedState.cache);
      }
      cache = fiber.child;
      if (null !== cache) cache.return = fiber, nextEffect = cache;else a: for (fiber = deletedSubtreeRoot; null !== nextEffect;) {
        cache = nextEffect;
        var sibling = cache.sibling,
          returnFiber = cache.return;
        detachFiberAfterEffects(cache);
        if (cache === fiber) {
          nextEffect = null;
          break a;
        }
        if (null !== sibling) {
          sibling.return = returnFiber;
          nextEffect = sibling;
          break a;
        }
        nextEffect = returnFiber;
      }
    }
  }
  var DefaultAsyncDispatcher = {
      getCacheForType: function (resourceType) {
        var cache = readContext(CacheContext),
          cacheForType = cache.data.get(resourceType);
        undefined === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
        return cacheForType;
      }
    },
    PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
    executionContext = 0,
    workInProgressRoot = null,
    workInProgress = null,
    workInProgressRootRenderLanes = 0,
    workInProgressSuspendedReason = 0,
    workInProgressThrownValue = null,
    workInProgressRootDidSkipSuspendedSiblings = false,
    workInProgressRootIsPrerendering = false,
    workInProgressRootDidAttachPingListener = false,
    entangledRenderLanes = 0,
    workInProgressRootExitStatus = 0,
    workInProgressRootSkippedLanes = 0,
    workInProgressRootInterleavedUpdatedLanes = 0,
    workInProgressRootPingedLanes = 0,
    workInProgressDeferredLane = 0,
    workInProgressSuspendedRetryLanes = 0,
    workInProgressRootConcurrentErrors = null,
    workInProgressRootRecoverableErrors = null,
    workInProgressRootDidIncludeRecursiveRenderUpdate = false,
    globalMostRecentFallbackTime = 0,
    workInProgressRootRenderTargetTime = Infinity,
    workInProgressTransitions = null,
    legacyErrorBoundariesThatAlreadyFailed = null,
    pendingEffectsStatus = 0,
    pendingEffectsRoot = null,
    pendingFinishedWork = null,
    pendingEffectsLanes = 0,
    pendingEffectsRemainingLanes = 0,
    pendingPassiveTransitions = null,
    pendingRecoverableErrors = null,
    nestedUpdateCount = 0,
    rootWithNestedUpdates = null;
  function requestUpdateLane() {
    if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes) return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
    if (null !== ReactSharedInternals.T) {
      var actionScopeLane = currentEntangledLane;
      return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
    }
    return resolveUpdatePriority();
  }
  function requestDeferredLane() {
    0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
    var suspenseHandler = suspenseHandlerStackCursor.current;
    null !== suspenseHandler && (suspenseHandler.flags |= 32);
    return workInProgressDeferredLane;
  }
  function scheduleUpdateOnFiber(root, fiber, lane) {
    if (root === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root.cancelPendingCommit) prepareFreshStack(root, 0), markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, false);
    markRootUpdated$1(root, lane);
    if (0 === (executionContext & 2) || root !== workInProgressRoot) root === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, false)), ensureRootIsScheduled(root);
  }
  function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
    if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
    var shouldTimeSlice = !forceSync && 0 === (lanes & 124) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes),
      exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true),
      renderWasConcurrent = shouldTimeSlice;
    do {
      if (0 === exitStatus) {
        workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
        break;
      } else {
        forceSync = root$jscomp$0.current.alternate;
        if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
          exitStatus = renderRootSync(root$jscomp$0, lanes, false);
          renderWasConcurrent = false;
          continue;
        }
        if (2 === exitStatus) {
          renderWasConcurrent = lanes;
          if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent) var JSCompiler_inline_result = 0;else JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
          if (0 !== JSCompiler_inline_result) {
            lanes = JSCompiler_inline_result;
            a: {
              var root = root$jscomp$0;
              exitStatus = workInProgressRootConcurrentErrors;
              var wasRootDehydrated = root.current.memoizedState.isDehydrated;
              wasRootDehydrated && (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);
              JSCompiler_inline_result = renderRootSync(root, JSCompiler_inline_result, false);
              if (2 !== JSCompiler_inline_result) {
                if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                  root.errorRecoveryDisabledLanes |= renderWasConcurrent;
                  workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                  exitStatus = 4;
                  break a;
                }
                renderWasConcurrent = workInProgressRootRecoverableErrors;
                workInProgressRootRecoverableErrors = exitStatus;
                null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, renderWasConcurrent));
              }
              exitStatus = JSCompiler_inline_result;
            }
            renderWasConcurrent = false;
            if (2 !== exitStatus) continue;
          }
        }
        if (1 === exitStatus) {
          prepareFreshStack(root$jscomp$0, 0);
          markRootSuspended(root$jscomp$0, lanes, 0, true);
          break;
        }
        a: {
          shouldTimeSlice = root$jscomp$0;
          renderWasConcurrent = exitStatus;
          switch (renderWasConcurrent) {
            case 0:
            case 1:
              throw Error(formatProdErrorMessage(345));
            case 4:
              if ((lanes & 4194048) !== lanes) break;
            case 6:
              markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
              break a;
            case 2:
              workInProgressRootRecoverableErrors = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(formatProdErrorMessage(329));
          }
          if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
            markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
            if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
            shouldTimeSlice.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, renderWasConcurrent, 2, -0, 0), exitStatus);
            break a;
          }
          commitRootWhenReady(shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, renderWasConcurrent, 0, -0, 0);
        }
      }
      break;
    } while (1);
    ensureRootIsScheduled(root$jscomp$0);
  }
  function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
    root.timeoutHandle = -1;
    suspendedCommitReason = finishedWork.subtreeFlags;
    if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) if (suspendedState = {
      stylesheets: null,
      count: 0,
      unsuspend: noop
    }, accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), null !== suspendedCommitReason) {
      root.cancelPendingCommit = suspendedCommitReason(commitRoot.bind(null, root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, exitStatus, 1, completedRenderStartTime, completedRenderEndTime));
      markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
      return;
    }
    commitRoot(root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);
  }
  function isRenderConsistentWithExternalStores(finishedWork) {
    for (var node = finishedWork;;) {
      var tag = node.tag;
      if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag))) for (var i = 0; i < tag.length; i++) {
        var check = tag[i],
          getSnapshot = check.getSnapshot;
        check = check.value;
        try {
          if (!objectIs(getSnapshot(), check)) return false;
        } catch (error) {
          return false;
        }
      }
      tag = node.child;
      if (node.subtreeFlags & 16384 && null !== tag) tag.return = node, node = tag;else {
        if (node === finishedWork) break;
        for (; null === node.sibling;) {
          if (null === node.return || node.return === finishedWork) return true;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
    }
    return true;
  }
  function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {
    suspendedLanes &= ~workInProgressRootPingedLanes;
    suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
    root.suspendedLanes |= suspendedLanes;
    root.pingedLanes &= ~suspendedLanes;
    didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
    didAttemptEntireTree = root.expirationTimes;
    for (var lanes = suspendedLanes; 0 < lanes;) {
      var index$4 = 31 - clz32(lanes),
        lane = 1 << index$4;
      didAttemptEntireTree[index$4] = -1;
      lanes &= ~lane;
    }
    0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
  }
  function flushSyncWork$1() {
    return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
  }
  function resetWorkInProgressStack() {
    if (null !== workInProgress) {
      if (0 === workInProgressSuspendedReason) var interruptedWork = workInProgress.return;else interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState = null, thenableIndexCounter = 0, interruptedWork = workInProgress;
      for (; null !== interruptedWork;) unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
      workInProgress = null;
    }
  }
  function prepareFreshStack(root, lanes) {
    var timeoutHandle = root.timeoutHandle;
    -1 !== timeoutHandle && (root.timeoutHandle = -1, cancelTimeout(timeoutHandle));
    timeoutHandle = root.cancelPendingCommit;
    null !== timeoutHandle && (root.cancelPendingCommit = null, timeoutHandle());
    resetWorkInProgressStack();
    workInProgressRoot = root;
    workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
    workInProgressRootRenderLanes = lanes;
    workInProgressSuspendedReason = 0;
    workInProgressThrownValue = null;
    workInProgressRootDidSkipSuspendedSiblings = false;
    workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
    workInProgressRootDidAttachPingListener = false;
    workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
    workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
    workInProgressRootDidIncludeRecursiveRenderUpdate = false;
    0 !== (lanes & 8) && (lanes |= lanes & 32);
    var allEntangledLanes = root.entangledLanes;
    if (0 !== allEntangledLanes) for (root = root.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes;) {
      var index$2 = 31 - clz32(allEntangledLanes),
        lane = 1 << index$2;
      lanes |= root[index$2];
      allEntangledLanes &= ~lane;
    }
    entangledRenderLanes = lanes;
    finishQueueingConcurrentUpdates();
    return timeoutHandle;
  }
  function handleThrow(root, thrownValue) {
    currentlyRenderingFiber = null;
    ReactSharedInternals.H = ContextOnlyDispatcher;
    thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
    workInProgressThrownValue = thrownValue;
    null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current)));
  }
  function pushDispatcher() {
    var prevDispatcher = ReactSharedInternals.H;
    ReactSharedInternals.H = ContextOnlyDispatcher;
    return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
  }
  function pushAsyncDispatcher() {
    var prevAsyncDispatcher = ReactSharedInternals.A;
    ReactSharedInternals.A = DefaultAsyncDispatcher;
    return prevAsyncDispatcher;
  }
  function renderDidSuspendDelayIfPossible() {
    workInProgressRootExitStatus = 4;
    workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
    0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, false);
  }
  function renderRootSync(root, lanes, shouldYieldForPrerendering) {
    var prevExecutionContext = executionContext;
    executionContext |= 2;
    var prevDispatcher = pushDispatcher(),
      prevAsyncDispatcher = pushAsyncDispatcher();
    if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) workInProgressTransitions = null, prepareFreshStack(root, lanes);
    lanes = false;
    var exitStatus = workInProgressRootExitStatus;
    a: do try {
      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
        var unitOfWork = workInProgress,
          thrownValue = workInProgressThrownValue;
        switch (workInProgressSuspendedReason) {
          case 8:
            resetWorkInProgressStack();
            exitStatus = 6;
            break a;
          case 3:
          case 2:
          case 9:
          case 6:
            null === suspenseHandlerStackCursor.current && (lanes = true);
            var reason = workInProgressSuspendedReason;
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
            if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
              exitStatus = 0;
              break a;
            }
            break;
          default:
            reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
        }
      }
      workLoopSync();
      exitStatus = workInProgressRootExitStatus;
      break;
    } catch (thrownValue$167) {
      handleThrow(root, thrownValue$167);
    } while (1);
    lanes && root.shellSuspendCounter++;
    lastContextDependency = currentlyRenderingFiber$1 = null;
    executionContext = prevExecutionContext;
    ReactSharedInternals.H = prevDispatcher;
    ReactSharedInternals.A = prevAsyncDispatcher;
    null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
    return exitStatus;
  }
  function workLoopSync() {
    for (; null !== workInProgress;) performUnitOfWork(workInProgress);
  }
  function renderRootConcurrent(root, lanes) {
    var prevExecutionContext = executionContext;
    executionContext |= 2;
    var prevDispatcher = pushDispatcher(),
      prevAsyncDispatcher = pushAsyncDispatcher();
    workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
    a: do try {
      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
        lanes = workInProgress;
        var thrownValue = workInProgressThrownValue;
        b: switch (workInProgressSuspendedReason) {
          case 1:
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);
            break;
          case 2:
          case 9:
            if (isThenableResolved(thrownValue)) {
              workInProgressSuspendedReason = 0;
              workInProgressThrownValue = null;
              replaySuspendedUnitOfWork(lanes);
              break;
            }
            lanes = function () {
              2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root || (workInProgressSuspendedReason = 7);
              ensureRootIsScheduled(root);
            };
            thrownValue.then(lanes, lanes);
            break a;
          case 3:
            workInProgressSuspendedReason = 7;
            break a;
          case 4:
            workInProgressSuspendedReason = 5;
            break a;
          case 7:
            isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));
            break;
          case 5:
            var resource = null;
            switch (workInProgress.tag) {
              case 26:
                resource = workInProgress.memoizedState;
              case 5:
              case 27:
                var hostFiber = workInProgress;
                if (resource ? preloadResource(resource) : 1) {
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  var sibling = hostFiber.sibling;
                  if (null !== sibling) workInProgress = sibling;else {
                    var returnFiber = hostFiber.return;
                    null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                  }
                  break b;
                }
            }
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);
            break;
          case 6:
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);
            break;
          case 8:
            resetWorkInProgressStack();
            workInProgressRootExitStatus = 6;
            break a;
          default:
            throw Error(formatProdErrorMessage(462));
        }
      }
      workLoopConcurrentByScheduler();
      break;
    } catch (thrownValue$169) {
      handleThrow(root, thrownValue$169);
    } while (1);
    lastContextDependency = currentlyRenderingFiber$1 = null;
    ReactSharedInternals.H = prevDispatcher;
    ReactSharedInternals.A = prevAsyncDispatcher;
    executionContext = prevExecutionContext;
    if (null !== workInProgress) return 0;
    workInProgressRoot = null;
    workInProgressRootRenderLanes = 0;
    finishQueueingConcurrentUpdates();
    return workInProgressRootExitStatus;
  }
  function workLoopConcurrentByScheduler() {
    for (; null !== workInProgress && !shouldYield();) performUnitOfWork(workInProgress);
  }
  function performUnitOfWork(unitOfWork) {
    var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
    unitOfWork.memoizedProps = unitOfWork.pendingProps;
    null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
  }
  function replaySuspendedUnitOfWork(unitOfWork) {
    var next = unitOfWork;
    var current = next.alternate;
    switch (next.tag) {
      case 15:
      case 0:
        next = replayFunctionComponent(current, next, next.pendingProps, next.type, undefined, workInProgressRootRenderLanes);
        break;
      case 11:
        next = replayFunctionComponent(current, next, next.pendingProps, next.type.render, next.ref, workInProgressRootRenderLanes);
        break;
      case 5:
        resetHooksOnUnwind(next);
      default:
        unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
    }
    unitOfWork.memoizedProps = unitOfWork.pendingProps;
    null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
  }
  function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {
    lastContextDependency = currentlyRenderingFiber$1 = null;
    resetHooksOnUnwind(unitOfWork);
    thenableState = null;
    thenableIndexCounter = 0;
    var returnFiber = unitOfWork.return;
    try {
      if (throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {
        workInProgressRootExitStatus = 1;
        logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
        workInProgress = null;
        return;
      }
    } catch (error) {
      if (null !== returnFiber) throw workInProgress = returnFiber, error;
      workInProgressRootExitStatus = 1;
      logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
      workInProgress = null;
      return;
    }
    if (unitOfWork.flags & 32768) {
      if (isHydrating || 1 === suspendedReason) root = true;else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912)) root = false;else if (workInProgressRootDidSkipSuspendedSiblings = root = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason) suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
      unwindUnitOfWork(unitOfWork, root);
    } else completeUnitOfWork(unitOfWork);
  }
  function completeUnitOfWork(unitOfWork) {
    var completedWork = unitOfWork;
    do {
      if (0 !== (completedWork.flags & 32768)) {
        unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);
        return;
      }
      unitOfWork = completedWork.return;
      var next = completeWork(completedWork.alternate, completedWork, entangledRenderLanes);
      if (null !== next) {
        workInProgress = next;
        return;
      }
      completedWork = completedWork.sibling;
      if (null !== completedWork) {
        workInProgress = completedWork;
        return;
      }
      workInProgress = completedWork = unitOfWork;
    } while (null !== completedWork);
    0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
  }
  function unwindUnitOfWork(unitOfWork, skipSiblings) {
    do {
      var next = unwindWork(unitOfWork.alternate, unitOfWork);
      if (null !== next) {
        next.flags &= 32767;
        workInProgress = next;
        return;
      }
      next = unitOfWork.return;
      null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
      if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
        workInProgress = unitOfWork;
        return;
      }
      workInProgress = unitOfWork = next;
    } while (null !== unitOfWork);
    workInProgressRootExitStatus = 6;
    workInProgress = null;
  }
  function commitRoot(root, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
    root.cancelPendingCommit = null;
    do flushPendingEffects(); while (0 !== pendingEffectsStatus);
    if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
    if (null !== finishedWork) {
      if (finishedWork === root.current) throw Error(formatProdErrorMessage(177));
      didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
      didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
      markRootFinished(root, lanes, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes);
      root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
      pendingFinishedWork = finishedWork;
      pendingEffectsRoot = root;
      pendingEffectsLanes = lanes;
      pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
      pendingPassiveTransitions = transitions;
      pendingRecoverableErrors = recoverableErrors;
      0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root.callbackNode = null, root.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function () {
        flushPassiveEffects(true);
        return null;
      })) : (root.callbackNode = null, root.callbackPriority = 0);
      recoverableErrors = 0 !== (finishedWork.flags & 13878);
      if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
        recoverableErrors = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        transitions = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 2;
        spawnedLane = executionContext;
        executionContext |= 4;
        try {
          commitBeforeMutationEffects(root, finishedWork, lanes);
        } finally {
          executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
        }
      }
      pendingEffectsStatus = 1;
      flushMutationEffects();
      flushLayoutEffects();
      flushSpawnedWork();
    }
  }
  function flushMutationEffects() {
    if (1 === pendingEffectsStatus) {
      pendingEffectsStatus = 0;
      var root = pendingEffectsRoot,
        finishedWork = pendingFinishedWork,
        rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
      if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
        rootMutationHasEffect = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 2;
        var prevExecutionContext = executionContext;
        executionContext |= 4;
        try {
          commitMutationEffectsOnFiber(finishedWork, root);
          var priorSelectionInformation = selectionInformation,
            curFocusedElem = getActiveElementDeep(root.containerInfo),
            priorFocusedElem = priorSelectionInformation.focusedElem,
            priorSelectionRange = priorSelectionInformation.selectionRange;
          if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(priorFocusedElem.ownerDocument.documentElement, priorFocusedElem)) {
            if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
              var start = priorSelectionRange.start,
                end = priorSelectionRange.end;
              undefined === end && (end = start);
              if ("selectionStart" in priorFocusedElem) priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(end, priorFocusedElem.value.length);else {
                var doc = priorFocusedElem.ownerDocument || document,
                  win = doc && doc.defaultView || window;
                if (win.getSelection) {
                  var selection = win.getSelection(),
                    length = priorFocusedElem.textContent.length,
                    start$jscomp$0 = Math.min(priorSelectionRange.start, length),
                    end$jscomp$0 = undefined === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                  !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                  var startMarker = getNodeForCharacterOffset(priorFocusedElem, start$jscomp$0),
                    endMarker = getNodeForCharacterOffset(priorFocusedElem, end$jscomp$0);
                  if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                    var range = doc.createRange();
                    range.setStart(startMarker.node, startMarker.offset);
                    selection.removeAllRanges();
                    start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                  }
                }
              }
            }
            doc = [];
            for (selection = priorFocusedElem; selection = selection.parentNode;) 1 === selection.nodeType && doc.push({
              element: selection,
              left: selection.scrollLeft,
              top: selection.scrollTop
            });
            "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
            for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
              var info = doc[priorFocusedElem];
              info.element.scrollLeft = info.left;
              info.element.scrollTop = info.top;
            }
          }
          _enabled = !!eventsEnabled;
          selectionInformation = eventsEnabled = null;
        } finally {
          executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
        }
      }
      root.current = finishedWork;
      pendingEffectsStatus = 2;
    }
  }
  function flushLayoutEffects() {
    if (2 === pendingEffectsStatus) {
      pendingEffectsStatus = 0;
      var root = pendingEffectsRoot,
        finishedWork = pendingFinishedWork,
        rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
      if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
        rootHasLayoutEffect = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 2;
        var prevExecutionContext = executionContext;
        executionContext |= 4;
        try {
          commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
        } finally {
          executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
        }
      }
      pendingEffectsStatus = 3;
    }
  }
  function flushSpawnedWork() {
    if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
      pendingEffectsStatus = 0;
      requestPaint();
      var root = pendingEffectsRoot,
        finishedWork = pendingFinishedWork,
        lanes = pendingEffectsLanes,
        recoverableErrors = pendingRecoverableErrors;
      0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root, root.pendingLanes));
      var remainingLanes = root.pendingLanes;
      0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
      lanesToEventPriority(lanes);
      finishedWork = finishedWork.stateNode;
      if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot) try {
        injectedHook.onCommitFiberRoot(rendererID, finishedWork, undefined, 128 === (finishedWork.current.flags & 128));
      } catch (err) {}
      if (null !== recoverableErrors) {
        finishedWork = ReactSharedInternals.T;
        remainingLanes = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 2;
        ReactSharedInternals.T = null;
        try {
          for (var onRecoverableError = root.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
            var recoverableError = recoverableErrors[i];
            onRecoverableError(recoverableError.value, {
              componentStack: recoverableError.stack
            });
          }
        } finally {
          ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
        }
      }
      0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
      ensureRootIsScheduled(root);
      remainingLanes = root.pendingLanes;
      0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42) ? root === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root) : nestedUpdateCount = 0;
      flushSyncWorkAcrossRoots_impl(0, false);
    }
  }
  function releaseRootPooledCache(root, remainingLanes) {
    0 === (root.pooledCacheLanes &= remainingLanes) && (remainingLanes = root.pooledCache, null != remainingLanes && (root.pooledCache = null, releaseCache(remainingLanes)));
  }
  function flushPendingEffects(wasDelayedCommit) {
    flushMutationEffects();
    flushLayoutEffects();
    flushSpawnedWork();
    return flushPassiveEffects(wasDelayedCommit);
  }
  function flushPassiveEffects() {
    if (5 !== pendingEffectsStatus) return false;
    var root = pendingEffectsRoot,
      remainingLanes = pendingEffectsRemainingLanes;
    pendingEffectsRemainingLanes = 0;
    var renderPriority = lanesToEventPriority(pendingEffectsLanes),
      prevTransition = ReactSharedInternals.T,
      previousPriority = ReactDOMSharedInternals.p;
    try {
      ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
      ReactSharedInternals.T = null;
      renderPriority = pendingPassiveTransitions;
      pendingPassiveTransitions = null;
      var root$jscomp$0 = pendingEffectsRoot,
        lanes = pendingEffectsLanes;
      pendingEffectsStatus = 0;
      pendingFinishedWork = pendingEffectsRoot = null;
      pendingEffectsLanes = 0;
      if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
      var prevExecutionContext = executionContext;
      executionContext |= 4;
      commitPassiveUnmountOnFiber(root$jscomp$0.current);
      commitPassiveMountOnFiber(root$jscomp$0, root$jscomp$0.current, lanes, renderPriority);
      executionContext = prevExecutionContext;
      flushSyncWorkAcrossRoots_impl(0, false);
      if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot) try {
        injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
      } catch (err) {}
      return true;
    } finally {
      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root, remainingLanes);
    }
  }
  function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
    sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
    sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
    rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
    null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
  }
  function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
    if (3 === sourceFiber.tag) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);else for (; null !== nearestMountedAncestor;) {
      if (3 === nearestMountedAncestor.tag) {
        captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);
        break;
      } else if (1 === nearestMountedAncestor.tag) {
        var instance = nearestMountedAncestor.stateNode;
        if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
          error = createClassErrorUpdate(2);
          instance = enqueueUpdate(nearestMountedAncestor, error, 2);
          null !== instance && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
          break;
        }
      }
      nearestMountedAncestor = nearestMountedAncestor.return;
    }
  }
  function attachPingListener(root, wakeable, lanes) {
    var pingCache = root.pingCache;
    if (null === pingCache) {
      pingCache = root.pingCache = new PossiblyWeakMap();
      var threadIDs = new Set();
      pingCache.set(wakeable, threadIDs);
    } else threadIDs = pingCache.get(wakeable), undefined === threadIDs && (threadIDs = new Set(), pingCache.set(wakeable, threadIDs));
    threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root = pingSuspendedRoot.bind(null, root, wakeable, lanes), wakeable.then(root, root));
  }
  function pingSuspendedRoot(root, wakeable, pingedLanes) {
    var pingCache = root.pingCache;
    null !== pingCache && pingCache.delete(wakeable);
    root.pingedLanes |= root.suspendedLanes & pingedLanes;
    root.warmLanes &= ~pingedLanes;
    workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
    ensureRootIsScheduled(root);
  }
  function retryTimedOutBoundary(boundaryFiber, retryLane) {
    0 === retryLane && (retryLane = claimNextRetryLane());
    boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
    null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
  }
  function retryDehydratedSuspenseBoundary(boundaryFiber) {
    var suspenseState = boundaryFiber.memoizedState,
      retryLane = 0;
    null !== suspenseState && (retryLane = suspenseState.retryLane);
    retryTimedOutBoundary(boundaryFiber, retryLane);
  }
  function resolveRetryWakeable(boundaryFiber, wakeable) {
    var retryLane = 0;
    switch (boundaryFiber.tag) {
      case 13:
        var retryCache = boundaryFiber.stateNode;
        var suspenseState = boundaryFiber.memoizedState;
        null !== suspenseState && (retryLane = suspenseState.retryLane);
        break;
      case 19:
        retryCache = boundaryFiber.stateNode;
        break;
      case 22:
        retryCache = boundaryFiber.stateNode._retryCache;
        break;
      default:
        throw Error(formatProdErrorMessage(314));
    }
    null !== retryCache && retryCache.delete(wakeable);
    retryTimedOutBoundary(boundaryFiber, retryLane);
  }
  function scheduleCallback$1(priorityLevel, callback) {
    return scheduleCallback$3(priorityLevel, callback);
  }
  var firstScheduledRoot = null,
    lastScheduledRoot = null,
    didScheduleMicrotask = false,
    mightHavePendingSyncWork = false,
    isFlushingWork = false,
    currentEventTransitionLane = 0;
  function ensureRootIsScheduled(root) {
    root !== lastScheduledRoot && null === root.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root : lastScheduledRoot = lastScheduledRoot.next = root);
    mightHavePendingSyncWork = true;
    didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
  }
  function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
    if (!isFlushingWork && mightHavePendingSyncWork) {
      isFlushingWork = true;
      do {
        var didPerformSomeWork = false;
        for (var root$174 = firstScheduledRoot; null !== root$174;) {
          if (!onlyLegacy) if (0 !== syncTransitionLanes) {
            var pendingLanes = root$174.pendingLanes;
            if (0 === pendingLanes) var JSCompiler_inline_result = 0;else {
              var suspendedLanes = root$174.suspendedLanes,
                pingedLanes = root$174.pingedLanes;
              JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
              JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
              JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
            }
            0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
          } else JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(root$174, root$174 === workInProgressRoot ? JSCompiler_inline_result : 0, null !== root$174.cancelPendingCommit || -1 !== root$174.timeoutHandle), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$174, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
          root$174 = root$174.next;
        }
      } while (didPerformSomeWork);
      isFlushingWork = false;
    }
  }
  function processRootScheduleInImmediateTask() {
    processRootScheduleInMicrotask();
  }
  function processRootScheduleInMicrotask() {
    mightHavePendingSyncWork = didScheduleMicrotask = false;
    var syncTransitionLanes = 0;
    0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
    for (var currentTime = now(), prev = null, root = firstScheduledRoot; null !== root;) {
      var next = root.next,
        nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
      if (0 === nextLanes) root.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);else if (prev = root, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3)) mightHavePendingSyncWork = true;
      root = next;
    }
    flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
  }
  function scheduleTaskForRootDuringMicrotask(root, currentTime) {
    for (var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = root.pendingLanes & -62914561; 0 < lanes;) {
      var index$3 = 31 - clz32(lanes),
        lane = 1 << index$3,
        expirationTime = expirationTimes[index$3];
      if (-1 === expirationTime) {
        if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) expirationTimes[index$3] = computeExpirationTime(lane, currentTime);
      } else expirationTime <= currentTime && (root.expiredLanes |= lane);
      lanes &= ~lane;
    }
    currentTime = workInProgressRoot;
    suspendedLanes = workInProgressRootRenderLanes;
    suspendedLanes = getNextLanes(root, root === currentTime ? suspendedLanes : 0, null !== root.cancelPendingCommit || -1 !== root.timeoutHandle);
    pingedLanes = root.callbackNode;
    if (0 === suspendedLanes || root === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root.cancelPendingCommit) return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root.callbackNode = null, root.callbackPriority = 0;
    if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root, suspendedLanes)) {
      currentTime = suspendedLanes & -suspendedLanes;
      if (currentTime === root.callbackPriority) return currentTime;
      null !== pingedLanes && cancelCallback$1(pingedLanes);
      switch (lanesToEventPriority(suspendedLanes)) {
        case 2:
        case 8:
          suspendedLanes = UserBlockingPriority;
          break;
        case 32:
          suspendedLanes = NormalPriority$1;
          break;
        case 268435456:
          suspendedLanes = IdlePriority;
          break;
        default:
          suspendedLanes = NormalPriority$1;
      }
      pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
      suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
      root.callbackPriority = currentTime;
      root.callbackNode = suspendedLanes;
      return currentTime;
    }
    null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
    root.callbackPriority = 2;
    root.callbackNode = null;
    return 2;
  }
  function performWorkOnRootViaSchedulerTask(root, didTimeout) {
    if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus) return root.callbackNode = null, root.callbackPriority = 0, null;
    var originalCallbackNode = root.callbackNode;
    if (flushPendingEffects(true) && root.callbackNode !== originalCallbackNode) return null;
    var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
    workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0, null !== root.cancelPendingCommit || -1 !== root.timeoutHandle);
    if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
    performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
    scheduleTaskForRootDuringMicrotask(root, now());
    return null != root.callbackNode && root.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root) : null;
  }
  function performSyncWorkOnRoot(root, lanes) {
    if (flushPendingEffects()) return null;
    performWorkOnRoot(root, lanes, true);
  }
  function scheduleImmediateRootScheduleTask() {
    scheduleMicrotask(function () {
      0 !== (executionContext & 6) ? scheduleCallback$3(ImmediatePriority, processRootScheduleInImmediateTask) : processRootScheduleInMicrotask();
    });
  }
  function requestTransitionLane() {
    0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
    return currentEventTransitionLane;
  }
  function coerceFormActionProp(actionProp) {
    return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
  }
  function createFormDataWithSubmitter(form, submitter) {
    var temp = submitter.ownerDocument.createElement("input");
    temp.name = submitter.name;
    temp.value = submitter.value;
    form.id && temp.setAttribute("form", form.id);
    submitter.parentNode.insertBefore(temp, submitter);
    form = new FormData(form);
    temp.parentNode.removeChild(temp);
    return form;
  }
  function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
    if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
      var action = coerceFormActionProp((nativeEventTarget[internalPropsKey] || null).action),
        submitter = nativeEvent.submitter;
      submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
      var event = new SyntheticEvent("action", "action", null, nativeEvent, nativeEventTarget);
      dispatchQueue.push({
        event: event,
        listeners: [{
          instance: null,
          listener: function () {
            if (nativeEvent.defaultPrevented) {
              if (0 !== currentEventTransitionLane) {
                var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                startHostTransition(maybeTargetInst, {
                  pending: true,
                  data: formData,
                  method: nativeEventTarget.method,
                  action: action
                }, null, formData);
              }
            } else "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(maybeTargetInst, {
              pending: true,
              data: formData,
              method: nativeEventTarget.method,
              action: action
            }, action, formData));
          },
          currentTarget: nativeEventTarget
        }]
      });
    }
  }
  for (var i$jscomp$inline_1528 = 0; i$jscomp$inline_1528 < simpleEventPluginEvents.length; i$jscomp$inline_1528++) {
    var eventName$jscomp$inline_1529 = simpleEventPluginEvents[i$jscomp$inline_1528],
      domEventName$jscomp$inline_1530 = eventName$jscomp$inline_1529.toLowerCase(),
      capitalizedEvent$jscomp$inline_1531 = eventName$jscomp$inline_1529[0].toUpperCase() + eventName$jscomp$inline_1529.slice(1);
    registerSimpleEvent(domEventName$jscomp$inline_1530, "on" + capitalizedEvent$jscomp$inline_1531);
  }
  registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
  registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
  registerSimpleEvent(ANIMATION_START, "onAnimationStart");
  registerSimpleEvent("dblclick", "onDoubleClick");
  registerSimpleEvent("focusin", "onFocus");
  registerSimpleEvent("focusout", "onBlur");
  registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
  registerSimpleEvent(TRANSITION_START, "onTransitionStart");
  registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
  registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
  registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
  registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
  registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
  registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
  registerTwoPhaseEvent("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  registerTwoPhaseEvent("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  registerTwoPhaseEvent("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  registerTwoPhaseEvent("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  registerTwoPhaseEvent("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
    nonDelegatedEvents = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes));
  function processDispatchQueue(dispatchQueue, eventSystemFlags) {
    eventSystemFlags = 0 !== (eventSystemFlags & 4);
    for (var i = 0; i < dispatchQueue.length; i++) {
      var _dispatchQueue$i = dispatchQueue[i],
        event = _dispatchQueue$i.event;
      _dispatchQueue$i = _dispatchQueue$i.listeners;
      a: {
        var previousInstance = undefined;
        if (eventSystemFlags) for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
          var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
            instance = _dispatchListeners$i.instance,
            currentTarget = _dispatchListeners$i.currentTarget;
          _dispatchListeners$i = _dispatchListeners$i.listener;
          if (instance !== previousInstance && event.isPropagationStopped()) break a;
          previousInstance = _dispatchListeners$i;
          event.currentTarget = currentTarget;
          try {
            previousInstance(event);
          } catch (error) {
            reportGlobalError(error);
          }
          event.currentTarget = null;
          previousInstance = instance;
        } else for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
          _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
          instance = _dispatchListeners$i.instance;
          currentTarget = _dispatchListeners$i.currentTarget;
          _dispatchListeners$i = _dispatchListeners$i.listener;
          if (instance !== previousInstance && event.isPropagationStopped()) break a;
          previousInstance = _dispatchListeners$i;
          event.currentTarget = currentTarget;
          try {
            previousInstance(event);
          } catch (error) {
            reportGlobalError(error);
          }
          event.currentTarget = null;
          previousInstance = instance;
        }
      }
    }
  }
  function listenToNonDelegatedEvent(domEventName, targetElement) {
    var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
    undefined === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = new Set());
    var listenerSetKey = domEventName + "__bubble";
    JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
  }
  function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
    var eventSystemFlags = 0;
    isCapturePhaseListener && (eventSystemFlags |= 4);
    addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
  }
  var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
  function listenToAllSupportedEvents(rootContainerElement) {
    if (!rootContainerElement[listeningMarker]) {
      rootContainerElement[listeningMarker] = true;
      allNativeEvents.forEach(function (domEventName) {
        "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
      });
      var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
      null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
    }
  }
  function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
    switch (getEventPriority(domEventName)) {
      case 2:
        var listenerWrapper = dispatchDiscreteEvent;
        break;
      case 8:
        listenerWrapper = dispatchContinuousEvent;
        break;
      default:
        listenerWrapper = dispatchEvent;
    }
    eventSystemFlags = listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
    listenerWrapper = undefined;
    !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
    isCapturePhaseListener ? undefined !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
      capture: true,
      passive: listenerWrapper
    }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : undefined !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
      passive: listenerWrapper
    }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
  }
  function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
    var ancestorInst = targetInst$jscomp$0;
    if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0) a: for (;;) {
      if (null === targetInst$jscomp$0) return;
      var nodeTag = targetInst$jscomp$0.tag;
      if (3 === nodeTag || 4 === nodeTag) {
        var container = targetInst$jscomp$0.stateNode.containerInfo;
        if (container === targetContainer) break;
        if (4 === nodeTag) for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag;) {
          var grandTag = nodeTag.tag;
          if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer) return;
          nodeTag = nodeTag.return;
        }
        for (; null !== container;) {
          nodeTag = getClosestInstanceFromNode(container);
          if (null === nodeTag) return;
          grandTag = nodeTag.tag;
          if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
            targetInst$jscomp$0 = ancestorInst = nodeTag;
            continue a;
          }
          container = container.parentNode;
        }
      }
      targetInst$jscomp$0 = targetInst$jscomp$0.return;
    }
    batchedUpdates$1(function () {
      var targetInst = ancestorInst,
        nativeEventTarget = getEventTarget(nativeEvent),
        dispatchQueue = [];
      a: {
        var reactName = topLevelEventsToReactNames.get(domEventName);
        if (undefined !== reactName) {
          var SyntheticEventCtor = SyntheticEvent,
            reactEventType = domEventName;
          switch (domEventName) {
            case "keypress":
              if (0 === getEventCharCode(nativeEvent)) break a;
            case "keydown":
            case "keyup":
              SyntheticEventCtor = SyntheticKeyboardEvent;
              break;
            case "focusin":
              reactEventType = "focus";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "focusout":
              reactEventType = "blur";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "beforeblur":
            case "afterblur":
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "click":
              if (2 === nativeEvent.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              SyntheticEventCtor = SyntheticMouseEvent;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              SyntheticEventCtor = SyntheticDragEvent;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              SyntheticEventCtor = SyntheticTouchEvent;
              break;
            case ANIMATION_END:
            case ANIMATION_ITERATION:
            case ANIMATION_START:
              SyntheticEventCtor = SyntheticAnimationEvent;
              break;
            case TRANSITION_END:
              SyntheticEventCtor = SyntheticTransitionEvent;
              break;
            case "scroll":
            case "scrollend":
              SyntheticEventCtor = SyntheticUIEvent;
              break;
            case "wheel":
              SyntheticEventCtor = SyntheticWheelEvent;
              break;
            case "copy":
            case "cut":
            case "paste":
              SyntheticEventCtor = SyntheticClipboardEvent;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              SyntheticEventCtor = SyntheticPointerEvent;
              break;
            case "toggle":
            case "beforetoggle":
              SyntheticEventCtor = SyntheticToggleEvent;
          }
          var inCapturePhase = 0 !== (eventSystemFlags & 4),
            accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName),
            reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
          inCapturePhase = [];
          for (var instance = targetInst, lastHostComponent; null !== instance;) {
            var _instance = instance;
            lastHostComponent = _instance.stateNode;
            _instance = _instance.tag;
            5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(createDispatchListener(instance, _instance, lastHostComponent)));
            if (accumulateTargetOnly) break;
            instance = instance.return;
          }
          0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget), dispatchQueue.push({
            event: reactName,
            listeners: inCapturePhase
          }));
        }
      }
      if (0 === (eventSystemFlags & 7)) {
        a: {
          reactName = "mouseover" === domEventName || "pointerover" === domEventName;
          SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
          if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey])) break a;
          if (SyntheticEventCtor || reactName) {
            reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
            if (SyntheticEventCtor) {
              if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase)) reactEventType = null;
            } else SyntheticEventCtor = null, reactEventType = targetInst;
            if (SyntheticEventCtor !== reactEventType) {
              inCapturePhase = SyntheticMouseEvent;
              _instance = "onMouseLeave";
              reactEventName = "onMouseEnter";
              instance = "mouse";
              if ("pointerout" === domEventName || "pointerover" === domEventName) inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
              accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
              lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
              reactName = new inCapturePhase(_instance, instance + "leave", SyntheticEventCtor, nativeEvent, nativeEventTarget);
              reactName.target = accumulateTargetOnly;
              reactName.relatedTarget = lastHostComponent;
              _instance = null;
              getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(reactEventName, instance + "enter", reactEventType, nativeEvent, nativeEventTarget), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
              accumulateTargetOnly = _instance;
              if (SyntheticEventCtor && reactEventType) b: {
                inCapturePhase = SyntheticEventCtor;
                reactEventName = reactEventType;
                instance = 0;
                for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent)) instance++;
                lastHostComponent = 0;
                for (_instance = reactEventName; _instance; _instance = getParent(_instance)) lastHostComponent++;
                for (; 0 < instance - lastHostComponent;) inCapturePhase = getParent(inCapturePhase), instance--;
                for (; 0 < lastHostComponent - instance;) reactEventName = getParent(reactEventName), lastHostComponent--;
                for (; instance--;) {
                  if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate) break b;
                  inCapturePhase = getParent(inCapturePhase);
                  reactEventName = getParent(reactEventName);
                }
                inCapturePhase = null;
              } else inCapturePhase = null;
              null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(dispatchQueue, reactName, SyntheticEventCtor, inCapturePhase, false);
              null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(dispatchQueue, accumulateTargetOnly, reactEventType, inCapturePhase, true);
            }
          }
        }
        a: {
          reactName = targetInst ? getNodeFromInstance(targetInst) : window;
          SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
          if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type) var getTargetInstFunc = getTargetInstForChangeEvent;else if (isTextInputElement(reactName)) {
            if (isInputEventSupported) getTargetInstFunc = getTargetInstForInputOrChangeEvent;else {
              getTargetInstFunc = getTargetInstForInputEventPolyfill;
              var handleEventFunc = handleEventsForInputEventPolyfill;
            }
          } else SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
          if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
            createAndAccumulateChangeEvent(dispatchQueue, getTargetInstFunc, nativeEvent, nativeEventTarget);
            break a;
          }
          handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
          "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
        }
        handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
        switch (domEventName) {
          case "focusin":
            if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable) activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
            break;
          case "focusout":
            lastSelection = activeElementInst = activeElement = null;
            break;
          case "mousedown":
            mouseDown = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            mouseDown = false;
            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            break;
          case "selectionchange":
            if (skipSelectionChangeEvent) break;
          case "keydown":
          case "keyup":
            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
        }
        var fallbackData;
        if (canUseCompositionEvent) b: {
          switch (domEventName) {
            case "compositionstart":
              var eventType = "onCompositionStart";
              break b;
            case "compositionend":
              eventType = "onCompositionEnd";
              break b;
            case "compositionupdate":
              eventType = "onCompositionUpdate";
              break b;
          }
          eventType = undefined;
        } else isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
        eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget), dispatchQueue.push({
          event: eventType,
          listeners: handleEventFunc
        }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
        if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent)) eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget), dispatchQueue.push({
          event: handleEventFunc,
          listeners: eventType
        }), handleEventFunc.data = fallbackData);
        extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
      }
      processDispatchQueue(dispatchQueue, eventSystemFlags);
    });
  }
  function createDispatchListener(instance, listener, currentTarget) {
    return {
      instance: instance,
      listener: listener,
      currentTarget: currentTarget
    };
  }
  function accumulateTwoPhaseListeners(targetFiber, reactName) {
    for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber;) {
      var _instance2 = targetFiber,
        stateNode = _instance2.stateNode;
      _instance2 = _instance2.tag;
      5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(createDispatchListener(targetFiber, _instance2, stateNode)), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(createDispatchListener(targetFiber, _instance2, stateNode)));
      if (3 === targetFiber.tag) return listeners;
      targetFiber = targetFiber.return;
    }
    return [];
  }
  function getParent(inst) {
    if (null === inst) return null;
    do inst = inst.return; while (inst && 5 !== inst.tag && 27 !== inst.tag);
    return inst ? inst : null;
  }
  function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
    for (var registrationName = event._reactName, listeners = []; null !== target && target !== common;) {
      var _instance3 = target,
        alternate = _instance3.alternate,
        stateNode = _instance3.stateNode;
      _instance3 = _instance3.tag;
      if (null !== alternate && alternate === common) break;
      5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(createDispatchListener(target, stateNode, alternate))) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(createDispatchListener(target, stateNode, alternate))));
      target = target.return;
    }
    0 !== listeners.length && dispatchQueue.push({
      event: event,
      listeners: listeners
    });
  }
  var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
    NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
  function normalizeMarkupForTextOrAttribute(markup) {
    return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
  }
  function checkForUnmatchedText(serverText, clientText) {
    clientText = normalizeMarkupForTextOrAttribute(clientText);
    return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
  }
  function noop$1() {}
  function setProp(domElement, tag, key, value, props, prevValue) {
    switch (key) {
      case "children":
        "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
        break;
      case "className":
        setValueForKnownAttribute(domElement, "class", value);
        break;
      case "tabIndex":
        setValueForKnownAttribute(domElement, "tabindex", value);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        setValueForKnownAttribute(domElement, key, value);
        break;
      case "style":
        setValueForStyles(domElement, value, prevValue);
        break;
      case "data":
        if ("object" !== tag) {
          setValueForKnownAttribute(domElement, "data", value);
          break;
        }
      case "src":
      case "href":
        if ("" === value && ("a" !== tag || "href" !== key)) {
          domElement.removeAttribute(key);
          break;
        }
        if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
          domElement.removeAttribute(key);
          break;
        }
        value = sanitizeURL("" + value);
        domElement.setAttribute(key, value);
        break;
      case "action":
      case "formAction":
        if ("function" === typeof value) {
          domElement.setAttribute(key, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
          break;
        } else "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(domElement, tag, "formEncType", props.formEncType, props, null), setProp(domElement, tag, "formMethod", props.formMethod, props, null), setProp(domElement, tag, "formTarget", props.formTarget, props, null)) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
        if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
          domElement.removeAttribute(key);
          break;
        }
        value = sanitizeURL("" + value);
        domElement.setAttribute(key, value);
        break;
      case "onClick":
        null != value && (domElement.onclick = noop$1);
        break;
      case "onScroll":
        null != value && listenToNonDelegatedEvent("scroll", domElement);
        break;
      case "onScrollEnd":
        null != value && listenToNonDelegatedEvent("scrollend", domElement);
        break;
      case "dangerouslySetInnerHTML":
        if (null != value) {
          if ("object" !== typeof value || !("__html" in value)) throw Error(formatProdErrorMessage(61));
          key = value.__html;
          if (null != key) {
            if (null != props.children) throw Error(formatProdErrorMessage(60));
            domElement.innerHTML = key;
          }
        }
        break;
      case "multiple":
        domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
        break;
      case "muted":
        domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
          domElement.removeAttribute("xlink:href");
          break;
        }
        key = sanitizeURL("" + value);
        domElement.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", key);
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
        break;
      case "capture":
      case "download":
        true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
        break;
      case "rowSpan":
      case "start":
        null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
        break;
      case "popover":
        listenToNonDelegatedEvent("beforetoggle", domElement);
        listenToNonDelegatedEvent("toggle", domElement);
        setValueForAttribute(domElement, "popover", value);
        break;
      case "xlinkActuate":
        setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:actuate", value);
        break;
      case "xlinkArcrole":
        setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:arcrole", value);
        break;
      case "xlinkRole":
        setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:role", value);
        break;
      case "xlinkShow":
        setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:show", value);
        break;
      case "xlinkTitle":
        setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:title", value);
        break;
      case "xlinkType":
        setValueForNamespacedAttribute(domElement, "http://www.w3.org/1999/xlink", "xlink:type", value);
        break;
      case "xmlBase":
        setValueForNamespacedAttribute(domElement, "http://www.w3.org/XML/1998/namespace", "xml:base", value);
        break;
      case "xmlLang":
        setValueForNamespacedAttribute(domElement, "http://www.w3.org/XML/1998/namespace", "xml:lang", value);
        break;
      case "xmlSpace":
        setValueForNamespacedAttribute(domElement, "http://www.w3.org/XML/1998/namespace", "xml:space", value);
        break;
      case "is":
        setValueForAttribute(domElement, "is", value);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1]) key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
    }
  }
  function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
    switch (key) {
      case "style":
        setValueForStyles(domElement, value, prevValue);
        break;
      case "dangerouslySetInnerHTML":
        if (null != value) {
          if ("object" !== typeof value || !("__html" in value)) throw Error(formatProdErrorMessage(61));
          key = value.__html;
          if (null != key) {
            if (null != props.children) throw Error(formatProdErrorMessage(60));
            domElement.innerHTML = key;
          }
        }
        break;
      case "children":
        "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
        break;
      case "onScroll":
        null != value && listenToNonDelegatedEvent("scroll", domElement);
        break;
      case "onScrollEnd":
        null != value && listenToNonDelegatedEvent("scrollend", domElement);
        break;
      case "onClick":
        null != value && (domElement.onclick = noop$1);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!registrationNameDependencies.hasOwnProperty(key)) a: {
          if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : undefined), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
            "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
            domElement.addEventListener(tag, value, props);
            break a;
          }
          key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
        }
    }
  }
  function setInitialProperties(domElement, tag, props) {
    switch (tag) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        listenToNonDelegatedEvent("error", domElement);
        listenToNonDelegatedEvent("load", domElement);
        var hasSrc = false,
          hasSrcSet = false,
          propKey;
        for (propKey in props) if (props.hasOwnProperty(propKey)) {
          var propValue = props[propKey];
          if (null != propValue) switch (propKey) {
            case "src":
              hasSrc = true;
              break;
            case "srcSet":
              hasSrcSet = true;
              break;
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(formatProdErrorMessage(137, tag));
            default:
              setProp(domElement, tag, propKey, propValue, props, null);
          }
        }
        hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
        hasSrc && setProp(domElement, tag, "src", props.src, props, null);
        return;
      case "input":
        listenToNonDelegatedEvent("invalid", domElement);
        var defaultValue = propKey = propValue = hasSrcSet = null,
          checked = null,
          defaultChecked = null;
        for (hasSrc in props) if (props.hasOwnProperty(hasSrc)) {
          var propValue$188 = props[hasSrc];
          if (null != propValue$188) switch (hasSrc) {
            case "name":
              hasSrcSet = propValue$188;
              break;
            case "type":
              propValue = propValue$188;
              break;
            case "checked":
              checked = propValue$188;
              break;
            case "defaultChecked":
              defaultChecked = propValue$188;
              break;
            case "value":
              propKey = propValue$188;
              break;
            case "defaultValue":
              defaultValue = propValue$188;
              break;
            case "children":
            case "dangerouslySetInnerHTML":
              if (null != propValue$188) throw Error(formatProdErrorMessage(137, tag));
              break;
            default:
              setProp(domElement, tag, hasSrc, propValue$188, props, null);
          }
        }
        initInput(domElement, propKey, defaultValue, checked, defaultChecked, propValue, hasSrcSet, false);
        track(domElement);
        return;
      case "select":
        listenToNonDelegatedEvent("invalid", domElement);
        hasSrc = propValue = propKey = null;
        for (hasSrcSet in props) if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue)) switch (hasSrcSet) {
          case "value":
            propKey = defaultValue;
            break;
          case "defaultValue":
            propValue = defaultValue;
            break;
          case "multiple":
            hasSrc = defaultValue;
          default:
            setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
        }
        tag = propKey;
        props = propValue;
        domElement.multiple = !!hasSrc;
        null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
        return;
      case "textarea":
        listenToNonDelegatedEvent("invalid", domElement);
        propKey = hasSrcSet = hasSrc = null;
        for (propValue in props) if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue)) switch (propValue) {
          case "value":
            hasSrc = defaultValue;
            break;
          case "defaultValue":
            hasSrcSet = defaultValue;
            break;
          case "children":
            propKey = defaultValue;
            break;
          case "dangerouslySetInnerHTML":
            if (null != defaultValue) throw Error(formatProdErrorMessage(91));
            break;
          default:
            setProp(domElement, tag, propValue, defaultValue, props, null);
        }
        initTextarea(domElement, hasSrc, hasSrcSet, propKey);
        track(domElement);
        return;
      case "option":
        for (checked in props) if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc)) switch (checked) {
          case "selected":
            domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
            break;
          default:
            setProp(domElement, tag, checked, hasSrc, props, null);
        }
        return;
      case "dialog":
        listenToNonDelegatedEvent("beforetoggle", domElement);
        listenToNonDelegatedEvent("toggle", domElement);
        listenToNonDelegatedEvent("cancel", domElement);
        listenToNonDelegatedEvent("close", domElement);
        break;
      case "iframe":
      case "object":
        listenToNonDelegatedEvent("load", domElement);
        break;
      case "video":
      case "audio":
        for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++) listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
        break;
      case "image":
        listenToNonDelegatedEvent("error", domElement);
        listenToNonDelegatedEvent("load", domElement);
        break;
      case "details":
        listenToNonDelegatedEvent("toggle", domElement);
        break;
      case "embed":
      case "source":
      case "link":
        listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (defaultChecked in props) if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc)) switch (defaultChecked) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(formatProdErrorMessage(137, tag));
          default:
            setProp(domElement, tag, defaultChecked, hasSrc, props, null);
        }
        return;
      default:
        if (isCustomElement(tag)) {
          for (propValue$188 in props) props.hasOwnProperty(propValue$188) && (hasSrc = props[propValue$188], undefined !== hasSrc && setPropOnCustomElement(domElement, tag, propValue$188, hasSrc, props, undefined));
          return;
        }
    }
    for (defaultValue in props) props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
  }
  function updateProperties(domElement, tag, lastProps, nextProps) {
    switch (tag) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var name = null,
          type = null,
          value = null,
          defaultValue = null,
          lastDefaultValue = null,
          checked = null,
          defaultChecked = null;
        for (propKey in lastProps) {
          var lastProp = lastProps[propKey];
          if (lastProps.hasOwnProperty(propKey) && null != lastProp) switch (propKey) {
            case "checked":
              break;
            case "value":
              break;
            case "defaultValue":
              lastDefaultValue = lastProp;
            default:
              nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
          }
        }
        for (var propKey$205 in nextProps) {
          var propKey = nextProps[propKey$205];
          lastProp = lastProps[propKey$205];
          if (nextProps.hasOwnProperty(propKey$205) && (null != propKey || null != lastProp)) switch (propKey$205) {
            case "type":
              type = propKey;
              break;
            case "name":
              name = propKey;
              break;
            case "checked":
              checked = propKey;
              break;
            case "defaultChecked":
              defaultChecked = propKey;
              break;
            case "value":
              value = propKey;
              break;
            case "defaultValue":
              defaultValue = propKey;
              break;
            case "children":
            case "dangerouslySetInnerHTML":
              if (null != propKey) throw Error(formatProdErrorMessage(137, tag));
              break;
            default:
              propKey !== lastProp && setProp(domElement, tag, propKey$205, propKey, nextProps, lastProp);
          }
        }
        updateInput(domElement, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name);
        return;
      case "select":
        propKey = value = defaultValue = propKey$205 = null;
        for (type in lastProps) if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue) switch (type) {
          case "value":
            break;
          case "multiple":
            propKey = lastDefaultValue;
          default:
            nextProps.hasOwnProperty(type) || setProp(domElement, tag, type, null, nextProps, lastDefaultValue);
        }
        for (name in nextProps) if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue)) switch (name) {
          case "value":
            propKey$205 = type;
            break;
          case "defaultValue":
            defaultValue = type;
            break;
          case "multiple":
            value = type;
          default:
            type !== lastDefaultValue && setProp(domElement, tag, name, type, nextProps, lastDefaultValue);
        }
        tag = defaultValue;
        lastProps = value;
        nextProps = propKey;
        null != propKey$205 ? updateOptions(domElement, !!lastProps, propKey$205, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
        return;
      case "textarea":
        propKey = propKey$205 = null;
        for (defaultValue in lastProps) if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue)) switch (defaultValue) {
          case "value":
            break;
          case "children":
            break;
          default:
            setProp(domElement, tag, defaultValue, null, nextProps, name);
        }
        for (value in nextProps) if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type)) switch (value) {
          case "value":
            propKey$205 = name;
            break;
          case "defaultValue":
            propKey = name;
            break;
          case "children":
            break;
          case "dangerouslySetInnerHTML":
            if (null != name) throw Error(formatProdErrorMessage(91));
            break;
          default:
            name !== type && setProp(domElement, tag, value, name, nextProps, type);
        }
        updateTextarea(domElement, propKey$205, propKey);
        return;
      case "option":
        for (var propKey$221 in lastProps) if (propKey$205 = lastProps[propKey$221], lastProps.hasOwnProperty(propKey$221) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$221)) switch (propKey$221) {
          case "selected":
            domElement.selected = false;
            break;
          default:
            setProp(domElement, tag, propKey$221, null, nextProps, propKey$205);
        }
        for (lastDefaultValue in nextProps) if (propKey$205 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$205 !== propKey && (null != propKey$205 || null != propKey)) switch (lastDefaultValue) {
          case "selected":
            domElement.selected = propKey$205 && "function" !== typeof propKey$205 && "symbol" !== typeof propKey$205;
            break;
          default:
            setProp(domElement, tag, lastDefaultValue, propKey$205, nextProps, propKey);
        }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var propKey$226 in lastProps) propKey$205 = lastProps[propKey$226], lastProps.hasOwnProperty(propKey$226) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$226) && setProp(domElement, tag, propKey$226, null, nextProps, propKey$205);
        for (checked in nextProps) if (propKey$205 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$205 !== propKey && (null != propKey$205 || null != propKey)) switch (checked) {
          case "children":
          case "dangerouslySetInnerHTML":
            if (null != propKey$205) throw Error(formatProdErrorMessage(137, tag));
            break;
          default:
            setProp(domElement, tag, checked, propKey$205, nextProps, propKey);
        }
        return;
      default:
        if (isCustomElement(tag)) {
          for (var propKey$231 in lastProps) propKey$205 = lastProps[propKey$231], lastProps.hasOwnProperty(propKey$231) && undefined !== propKey$205 && !nextProps.hasOwnProperty(propKey$231) && setPropOnCustomElement(domElement, tag, propKey$231, undefined, nextProps, propKey$205);
          for (defaultChecked in nextProps) propKey$205 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$205 === propKey || undefined === propKey$205 && undefined === propKey || setPropOnCustomElement(domElement, tag, defaultChecked, propKey$205, nextProps, propKey);
          return;
        }
    }
    for (var propKey$236 in lastProps) propKey$205 = lastProps[propKey$236], lastProps.hasOwnProperty(propKey$236) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$236) && setProp(domElement, tag, propKey$236, null, nextProps, propKey$205);
    for (lastProp in nextProps) propKey$205 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$205 === propKey || null == propKey$205 && null == propKey || setProp(domElement, tag, lastProp, propKey$205, nextProps, propKey);
  }
  var eventsEnabled = null,
    selectionInformation = null;
  function getOwnerDocumentFromRootContainer(rootContainerElement) {
    return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
  }
  function getOwnHostContext(namespaceURI) {
    switch (namespaceURI) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function getChildHostContextProd(parentNamespace, type) {
    if (0 === parentNamespace) switch (type) {
      case "svg":
        return 1;
      case "math":
        return 2;
      default:
        return 0;
    }
    return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
  }
  function shouldSetTextContent(type, props) {
    return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
  }
  var currentPopstateTransitionEvent = null;
  function shouldAttemptEagerTransition() {
    var event = window.event;
    if (event && "popstate" === event.type) {
      if (event === currentPopstateTransitionEvent) return false;
      currentPopstateTransitionEvent = event;
      return true;
    }
    currentPopstateTransitionEvent = null;
    return false;
  }
  var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : undefined,
    cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : undefined,
    localPromise = "function" === typeof Promise ? Promise : undefined,
    scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function (callback) {
      return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
    } : scheduleTimeout;
  function handleErrorInNextTick(error) {
    setTimeout(function () {
      throw error;
    });
  }
  function isSingletonScope(type) {
    return "head" === type;
  }
  function clearSuspenseBoundary(parentInstance, suspenseInstance) {
    var node = suspenseInstance,
      possiblePreambleContribution = 0,
      depth = 0;
    do {
      var nextNode = node.nextSibling;
      parentInstance.removeChild(node);
      if (nextNode && 8 === nextNode.nodeType) {
        if (node = nextNode.data, "/$" === node) {
          if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {
            node = possiblePreambleContribution;
            var ownerDocument = parentInstance.ownerDocument;
            node & 1 && releaseSingletonInstance(ownerDocument.documentElement);
            node & 2 && releaseSingletonInstance(ownerDocument.body);
            if (node & 4) for (node = ownerDocument.head, releaseSingletonInstance(node), ownerDocument = node.firstChild; ownerDocument;) {
              var nextNode$jscomp$0 = ownerDocument.nextSibling,
                nodeName = ownerDocument.nodeName;
              ownerDocument[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === ownerDocument.rel.toLowerCase() || node.removeChild(ownerDocument);
              ownerDocument = nextNode$jscomp$0;
            }
          }
          if (0 === depth) {
            parentInstance.removeChild(nextNode);
            retryIfBlockedOn(suspenseInstance);
            return;
          }
          depth--;
        } else "$" === node || "$?" === node || "$!" === node ? depth++ : possiblePreambleContribution = node.charCodeAt(0) - 48;
      } else possiblePreambleContribution = 0;
      node = nextNode;
    } while (node);
    retryIfBlockedOn(suspenseInstance);
  }
  function clearContainerSparingly(container) {
    var nextNode = container.firstChild;
    nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
    for (; nextNode;) {
      var node = nextNode;
      nextNode = nextNode.nextSibling;
      switch (node.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          clearContainerSparingly(node);
          detachDeletedInstance(node);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if ("stylesheet" === node.rel.toLowerCase()) continue;
      }
      container.removeChild(node);
    }
  }
  function canHydrateInstance(instance, type, props, inRootOrSingleton) {
    for (; 1 === instance.nodeType;) {
      var anyProps = props;
      if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
        if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type)) break;
      } else if (!inRootOrSingleton) {
        if ("input" === type && "hidden" === instance.type) {
          var name = null == anyProps.name ? null : "" + anyProps.name;
          if ("hidden" === anyProps.type && instance.getAttribute("name") === name) return instance;
        } else return instance;
      } else if (!instance[internalHoistableMarker]) switch (type) {
        case "meta":
          if (!instance.hasAttribute("itemprop")) break;
          return instance;
        case "link":
          name = instance.getAttribute("rel");
          if ("stylesheet" === name && instance.hasAttribute("data-precedence")) break;else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title)) break;
          return instance;
        case "style":
          if (instance.hasAttribute("data-precedence")) break;
          return instance;
        case "script":
          name = instance.getAttribute("src");
          if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop")) break;
          return instance;
        default:
          return instance;
      }
      instance = getNextHydratable(instance.nextSibling);
      if (null === instance) break;
    }
    return null;
  }
  function canHydrateTextInstance(instance, text, inRootOrSingleton) {
    if ("" === text) return null;
    for (; 3 !== instance.nodeType;) {
      if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton) return null;
      instance = getNextHydratable(instance.nextSibling);
      if (null === instance) return null;
    }
    return instance;
  }
  function isSuspenseInstanceFallback(instance) {
    return "$!" === instance.data || "$?" === instance.data && "complete" === instance.ownerDocument.readyState;
  }
  function registerSuspenseInstanceRetry(instance, callback) {
    var ownerDocument = instance.ownerDocument;
    if ("$?" !== instance.data || "complete" === ownerDocument.readyState) callback();else {
      var listener = function () {
        callback();
        ownerDocument.removeEventListener("DOMContentLoaded", listener);
      };
      ownerDocument.addEventListener("DOMContentLoaded", listener);
      instance._reactRetry = listener;
    }
  }
  function getNextHydratable(node) {
    for (; null != node; node = node.nextSibling) {
      var nodeType = node.nodeType;
      if (1 === nodeType || 3 === nodeType) break;
      if (8 === nodeType) {
        nodeType = node.data;
        if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "F!" === nodeType || "F" === nodeType) break;
        if ("/$" === nodeType) return null;
      }
    }
    return node;
  }
  var previousHydratableOnEnteringScopedSingleton = null;
  function getParentSuspenseInstance(targetInstance) {
    targetInstance = targetInstance.previousSibling;
    for (var depth = 0; targetInstance;) {
      if (8 === targetInstance.nodeType) {
        var data = targetInstance.data;
        if ("$" === data || "$!" === data || "$?" === data) {
          if (0 === depth) return targetInstance;
          depth--;
        } else "/$" === data && depth++;
      }
      targetInstance = targetInstance.previousSibling;
    }
    return null;
  }
  function resolveSingletonInstance(type, props, rootContainerInstance) {
    props = getOwnerDocumentFromRootContainer(rootContainerInstance);
    switch (type) {
      case "html":
        type = props.documentElement;
        if (!type) throw Error(formatProdErrorMessage(452));
        return type;
      case "head":
        type = props.head;
        if (!type) throw Error(formatProdErrorMessage(453));
        return type;
      case "body":
        type = props.body;
        if (!type) throw Error(formatProdErrorMessage(454));
        return type;
      default:
        throw Error(formatProdErrorMessage(451));
    }
  }
  function releaseSingletonInstance(instance) {
    for (var attributes = instance.attributes; attributes.length;) instance.removeAttributeNode(attributes[0]);
    detachDeletedInstance(instance);
  }
  var preloadPropsMap = new Map(),
    preconnectsSet = new Set();
  function getHoistableRoot(container) {
    return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
  }
  var previousDispatcher = ReactDOMSharedInternals.d;
  ReactDOMSharedInternals.d = {
    f: flushSyncWork,
    r: requestFormReset,
    D: prefetchDNS,
    C: preconnect,
    L: preload,
    m: preloadModule,
    X: preinitScript,
    S: preinitStyle,
    M: preinitModuleScript
  };
  function flushSyncWork() {
    var previousWasRendering = previousDispatcher.f(),
      wasRendering = flushSyncWork$1();
    return previousWasRendering || wasRendering;
  }
  function requestFormReset(form) {
    var formInst = getInstanceFromNode(form);
    null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
  }
  var globalDocument = "undefined" === typeof document ? null : document;
  function preconnectAs(rel, href, crossOrigin) {
    var ownerDocument = globalDocument;
    if (ownerDocument && "string" === typeof href && href) {
      var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
      limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
      "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
      preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = {
        rel: rel,
        crossOrigin: crossOrigin,
        href: href
      }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
    }
  }
  function prefetchDNS(href) {
    previousDispatcher.D(href);
    preconnectAs("dns-prefetch", href, null);
  }
  function preconnect(href, crossOrigin) {
    previousDispatcher.C(href, crossOrigin);
    preconnectAs("preconnect", href, crossOrigin);
  }
  function preload(href, as, options) {
    previousDispatcher.L(href, as, options);
    var ownerDocument = globalDocument;
    if (ownerDocument && href && as) {
      var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
      "image" === as ? options && options.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSrcSet) + '"]', "string" === typeof options.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSizes) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
      var key = preloadSelector;
      switch (as) {
        case "style":
          key = getStyleKey(href);
          break;
        case "script":
          key = getScriptKey(href);
      }
      preloadPropsMap.has(key) || (href = assign({
        rel: "preload",
        href: "image" === as && options && options.imageSrcSet ? undefined : href,
        as: as
      }, options), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
    }
  }
  function preloadModule(href, options) {
    previousDispatcher.m(href, options);
    var ownerDocument = globalDocument;
    if (ownerDocument && href) {
      var as = options && "string" === typeof options.as ? options.as : "script",
        preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]',
        key = preloadSelector;
      switch (as) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          key = getScriptKey(href);
      }
      if (!preloadPropsMap.has(key) && (href = assign({
        rel: "modulepreload",
        href: href
      }, options), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
        switch (as) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (ownerDocument.querySelector(getScriptSelectorFromKey(key))) return;
        }
        as = ownerDocument.createElement("link");
        setInitialProperties(as, "link", href);
        markNodeAsHoistable(as);
        ownerDocument.head.appendChild(as);
      }
    }
  }
  function preinitStyle(href, precedence, options) {
    previousDispatcher.S(href, precedence, options);
    var ownerDocument = globalDocument;
    if (ownerDocument && href) {
      var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,
        key = getStyleKey(href);
      precedence = precedence || "default";
      var resource = styles.get(key);
      if (!resource) {
        var state = {
          loading: 0,
          preload: null
        };
        if (resource = ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) state.loading = 5;else {
          href = assign({
            rel: "stylesheet",
            href: href,
            "data-precedence": precedence
          }, options);
          (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);
          var link = resource = ownerDocument.createElement("link");
          markNodeAsHoistable(link);
          setInitialProperties(link, "link", href);
          link._p = new Promise(function (resolve, reject) {
            link.onload = resolve;
            link.onerror = reject;
          });
          link.addEventListener("load", function () {
            state.loading |= 1;
          });
          link.addEventListener("error", function () {
            state.loading |= 2;
          });
          state.loading |= 4;
          insertStylesheet(resource, precedence, ownerDocument);
        }
        resource = {
          type: "stylesheet",
          instance: resource,
          count: 1,
          state: state
        };
        styles.set(key, resource);
      }
    }
  }
  function preinitScript(src, options) {
    previousDispatcher.X(src, options);
    var ownerDocument = globalDocument;
    if (ownerDocument && src) {
      var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
        key = getScriptKey(src),
        resource = scripts.get(key);
      resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({
        src: src,
        async: true
      }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
        type: "script",
        instance: resource,
        count: 1,
        state: null
      }, scripts.set(key, resource));
    }
  }
  function preinitModuleScript(src, options) {
    previousDispatcher.M(src, options);
    var ownerDocument = globalDocument;
    if (ownerDocument && src) {
      var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
        key = getScriptKey(src),
        resource = scripts.get(key);
      resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({
        src: src,
        async: true,
        type: "module"
      }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
        type: "script",
        instance: resource,
        count: 1,
        state: null
      }, scripts.set(key, resource));
    }
  }
  function getResource(type, currentProps, pendingProps, currentResource) {
    var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
    if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
    switch (type) {
      case "meta":
      case "title":
        return null;
      case "style":
        return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(JSCompiler_inline_result).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, pendingProps.set(currentProps, currentResource)), currentResource) : {
          type: "void",
          instance: null,
          count: 0,
          state: null
        };
      case "link":
        if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
          type = getStyleKey(pendingProps.href);
          var styles$244 = getResourcesFromRoot(JSCompiler_inline_result).hoistableStyles,
            resource$245 = styles$244.get(type);
          resource$245 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$245 = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: {
              loading: 0,
              preload: null
            }
          }, styles$244.set(type, resource$245), (styles$244 = JSCompiler_inline_result.querySelector(getStylesheetSelectorFromKey(type))) && !styles$244._p && (resource$245.instance = styles$244, resource$245.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
            rel: "preload",
            as: "style",
            href: pendingProps.href,
            crossOrigin: pendingProps.crossOrigin,
            integrity: pendingProps.integrity,
            media: pendingProps.media,
            hrefLang: pendingProps.hrefLang,
            referrerPolicy: pendingProps.referrerPolicy
          }, preloadPropsMap.set(type, pendingProps), styles$244 || preloadStylesheet(JSCompiler_inline_result, type, pendingProps, resource$245.state)));
          if (currentProps && null === currentResource) throw Error(formatProdErrorMessage(528, ""));
          return resource$245;
        }
        if (currentProps && null !== currentResource) throw Error(formatProdErrorMessage(529, ""));
        return null;
      case "script":
        return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(JSCompiler_inline_result).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, pendingProps.set(currentProps, currentResource)), currentResource) : {
          type: "void",
          instance: null,
          count: 0,
          state: null
        };
      default:
        throw Error(formatProdErrorMessage(444, type));
    }
  }
  function getStyleKey(href) {
    return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
  }
  function getStylesheetSelectorFromKey(key) {
    return 'link[rel="stylesheet"][' + key + "]";
  }
  function stylesheetPropsFromRawProps(rawProps) {
    return assign({}, rawProps, {
      "data-precedence": rawProps.precedence,
      precedence: null
    });
  }
  function preloadStylesheet(ownerDocument, key, preloadProps, state) {
    ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function () {
      return state.loading |= 1;
    }), key.addEventListener("error", function () {
      return state.loading |= 2;
    }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
  }
  function getScriptKey(src) {
    return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
  }
  function getScriptSelectorFromKey(key) {
    return "script[async]" + key;
  }
  function acquireResource(hoistableRoot, resource, props) {
    resource.count++;
    if (null === resource.instance) switch (resource.type) {
      case "style":
        var instance = hoistableRoot.querySelector('style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]');
        if (instance) return resource.instance = instance, markNodeAsHoistable(instance), instance;
        var styleProps = assign({}, props, {
          "data-href": props.href,
          "data-precedence": props.precedence,
          href: null,
          precedence: null
        });
        instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
        markNodeAsHoistable(instance);
        setInitialProperties(instance, "style", styleProps);
        insertStylesheet(instance, props.precedence, hoistableRoot);
        return resource.instance = instance;
      case "stylesheet":
        styleProps = getStyleKey(props.href);
        var instance$250 = hoistableRoot.querySelector(getStylesheetSelectorFromKey(styleProps));
        if (instance$250) return resource.state.loading |= 4, resource.instance = instance$250, markNodeAsHoistable(instance$250), instance$250;
        instance = stylesheetPropsFromRawProps(props);
        (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
        instance$250 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
        markNodeAsHoistable(instance$250);
        var linkInstance = instance$250;
        linkInstance._p = new Promise(function (resolve, reject) {
          linkInstance.onload = resolve;
          linkInstance.onerror = reject;
        });
        setInitialProperties(instance$250, "link", instance);
        resource.state.loading |= 4;
        insertStylesheet(instance$250, props.precedence, hoistableRoot);
        return resource.instance = instance$250;
      case "script":
        instance$250 = getScriptKey(props.src);
        if (styleProps = hoistableRoot.querySelector(getScriptSelectorFromKey(instance$250))) return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
        instance = props;
        if (styleProps = preloadPropsMap.get(instance$250)) instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        styleProps = hoistableRoot.createElement("script");
        markNodeAsHoistable(styleProps);
        setInitialProperties(styleProps, "link", instance);
        hoistableRoot.head.appendChild(styleProps);
        return resource.instance = styleProps;
      case "void":
        return null;
      default:
        throw Error(formatProdErrorMessage(443, resource.type));
    } else "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
    return resource.instance;
  }
  function insertStylesheet(instance, precedence, root) {
    for (var nodes = root.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (node.dataset.precedence === precedence) prior = node;else if (prior !== last) break;
    }
    prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root.nodeType ? root.head : root, precedence.insertBefore(instance, precedence.firstChild));
  }
  function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
    null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
    null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
    null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
  }
  function adoptPreloadPropsForScript(scriptProps, preloadProps) {
    null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
    null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
    null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
  }
  var tagCaches = null;
  function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
    if (null === tagCaches) {
      var cache = new Map();
      var caches = tagCaches = new Map();
      caches.set(ownerDocument, cache);
    } else caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = new Map(), caches.set(ownerDocument, cache));
    if (cache.has(type)) return cache;
    cache.set(type, null);
    ownerDocument = ownerDocument.getElementsByTagName(type);
    for (caches = 0; caches < ownerDocument.length; caches++) {
      var node = ownerDocument[caches];
      if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
        var nodeKey = node.getAttribute(keyAttribute) || "";
        nodeKey = type + nodeKey;
        var existing = cache.get(nodeKey);
        existing ? existing.push(node) : cache.set(nodeKey, [node]);
      }
    }
    return cache;
  }
  function mountHoistable(hoistableRoot, type, instance) {
    hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
    hoistableRoot.head.insertBefore(instance, "title" === type ? hoistableRoot.querySelector("head > title") : null);
  }
  function isHostHoistableType(type, props, hostContext) {
    if (1 === hostContext || null != props.itemProp) return false;
    switch (type) {
      case "meta":
      case "title":
        return true;
      case "style":
        if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href) break;
        return true;
      case "link":
        if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError) break;
        switch (props.rel) {
          case "stylesheet":
            return type = props.disabled, "string" === typeof props.precedence && null == type;
          default:
            return true;
        }
      case "script":
        if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src) return true;
    }
    return false;
  }
  function preloadResource(resource) {
    return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
  }
  var suspendedState = null;
  function noop() {}
  function suspendResource(hoistableRoot, resource, props) {
    if (null === suspendedState) throw Error(formatProdErrorMessage(475));
    var state = suspendedState;
    if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
      if (null === resource.instance) {
        var key = getStyleKey(props.href),
          instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(key));
        if (instance) {
          hoistableRoot = instance._p;
          null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
          resource.state.loading |= 4;
          resource.instance = instance;
          markNodeAsHoistable(instance);
          return;
        }
        instance = hoistableRoot.ownerDocument || hoistableRoot;
        props = stylesheetPropsFromRawProps(props);
        (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
        instance = instance.createElement("link");
        markNodeAsHoistable(instance);
        var linkInstance = instance;
        linkInstance._p = new Promise(function (resolve, reject) {
          linkInstance.onload = resolve;
          linkInstance.onerror = reject;
        });
        setInitialProperties(instance, "link", props);
        resource.instance = instance;
      }
      null === state.stylesheets && (state.stylesheets = new Map());
      state.stylesheets.set(resource, hoistableRoot);
      (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
    }
  }
  function waitForCommitToBeReady() {
    if (null === suspendedState) throw Error(formatProdErrorMessage(475));
    var state = suspendedState;
    state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
    return 0 < state.count ? function (commit) {
      var stylesheetTimer = setTimeout(function () {
        state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
        if (state.unsuspend) {
          var unsuspend = state.unsuspend;
          state.unsuspend = null;
          unsuspend();
        }
      }, 6e4);
      state.unsuspend = commit;
      return function () {
        state.unsuspend = null;
        clearTimeout(stylesheetTimer);
      };
    } : null;
  }
  function onUnsuspend() {
    this.count--;
    if (0 === this.count) if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);else if (this.unsuspend) {
      var unsuspend = this.unsuspend;
      this.unsuspend = null;
      unsuspend();
    }
  }
  var precedencesByRoot = null;
  function insertSuspendedStylesheets(state, resources) {
    state.stylesheets = null;
    null !== state.unsuspend && (state.count++, precedencesByRoot = new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
  }
  function insertStylesheetIntoRoot(root, resource) {
    if (!(resource.state.loading & 4)) {
      var precedences = precedencesByRoot.get(root);
      if (precedences) var last = precedences.get(null);else {
        precedences = new Map();
        precedencesByRoot.set(root, precedences);
        for (var nodes = root.querySelectorAll("link[data-precedence],style[data-precedence]"), i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media")) precedences.set(node.dataset.precedence, node), last = node;
        }
        last && precedences.set(null, last);
      }
      nodes = resource.instance;
      node = nodes.getAttribute("data-precedence");
      i = precedences.get(node) || last;
      i === last && precedences.set(null, nodes);
      precedences.set(node, nodes);
      this.count++;
      last = onUnsuspend.bind(this);
      nodes.addEventListener("load", last);
      nodes.addEventListener("error", last);
      i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root = 9 === root.nodeType ? root.head : root, root.insertBefore(nodes, root.firstChild));
      resource.state.loading |= 4;
    }
  }
  var HostTransitionContext = {
    $$typeof: REACT_CONTEXT_TYPE,
    Provider: null,
    Consumer: null,
    _currentValue: sharedNotPendingObject,
    _currentValue2: sharedNotPendingObject,
    _threadCount: 0
  };
  function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
    this.tag = 1;
    this.containerInfo = containerInfo;
    this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
    this.callbackPriority = 0;
    this.expirationTimes = createLaneMap(-1);
    this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = createLaneMap(0);
    this.hiddenUpdates = createLaneMap(null);
    this.identifierPrefix = identifierPrefix;
    this.onUncaughtError = onUncaughtError;
    this.onCaughtError = onCaughtError;
    this.onRecoverableError = onRecoverableError;
    this.pooledCache = null;
    this.pooledCacheLanes = 0;
    this.formState = formState;
    this.incompleteTransitions = new Map();
  }
  function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
    containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState);
    tag = 1;
    true === isStrictMode && (tag |= 24);
    isStrictMode = createFiberImplClass(3, null, null, tag);
    containerInfo.current = isStrictMode;
    isStrictMode.stateNode = containerInfo;
    tag = createCache();
    tag.refCount++;
    containerInfo.pooledCache = tag;
    tag.refCount++;
    isStrictMode.memoizedState = {
      element: initialChildren,
      isDehydrated: hydrate,
      cache: tag
    };
    initializeUpdateQueue(isStrictMode);
    return containerInfo;
  }
  function getContextForSubtree(parentComponent) {
    if (!parentComponent) return emptyContextObject;
    parentComponent = emptyContextObject;
    return parentComponent;
  }
  function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
    parentComponent = getContextForSubtree(parentComponent);
    null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
    container = createUpdate(lane);
    container.payload = {
      element: element
    };
    callback = undefined === callback ? null : callback;
    null !== callback && (container.callback = callback);
    element = enqueueUpdate(rootFiber, container, lane);
    null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
  }
  function markRetryLaneImpl(fiber, retryLane) {
    fiber = fiber.memoizedState;
    if (null !== fiber && null !== fiber.dehydrated) {
      var a = fiber.retryLane;
      fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
    }
  }
  function markRetryLaneIfNotHydrated(fiber, retryLane) {
    markRetryLaneImpl(fiber, retryLane);
    (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
  }
  function attemptContinuousHydration(fiber) {
    if (13 === fiber.tag) {
      var root = enqueueConcurrentRenderForLane(fiber, 67108864);
      null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
      markRetryLaneIfNotHydrated(fiber, 67108864);
    }
  }
  var _enabled = true;
  function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
    var prevTransition = ReactSharedInternals.T;
    ReactSharedInternals.T = null;
    var previousPriority = ReactDOMSharedInternals.p;
    try {
      ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
    } finally {
      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
    }
  }
  function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
    var prevTransition = ReactSharedInternals.T;
    ReactSharedInternals.T = null;
    var previousPriority = ReactDOMSharedInternals.p;
    try {
      ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
    } finally {
      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
    }
  }
  function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
    if (_enabled) {
      var blockedOn = findInstanceBlockingEvent(nativeEvent);
      if (null === blockedOn) dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer), clearIfContinuousEvent(domEventName, nativeEvent);else if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) nativeEvent.stopPropagation();else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
        for (; null !== blockedOn;) {
          var fiber = getInstanceFromNode(blockedOn);
          if (null !== fiber) switch (fiber.tag) {
            case 3:
              fiber = fiber.stateNode;
              if (fiber.current.memoizedState.isDehydrated) {
                var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                if (0 !== lanes) {
                  var root = fiber;
                  root.pendingLanes |= 2;
                  for (root.entangledLanes |= 2; lanes;) {
                    var lane = 1 << 31 - clz32(lanes);
                    root.entanglements[1] |= lane;
                    lanes &= ~lane;
                  }
                  ensureRootIsScheduled(fiber);
                  0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0, false));
                }
              }
              break;
            case 13:
              root = enqueueConcurrentRenderForLane(fiber, 2), null !== root && scheduleUpdateOnFiber(root, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
          }
          fiber = findInstanceBlockingEvent(nativeEvent);
          null === fiber && dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
          if (fiber === blockedOn) break;
          blockedOn = fiber;
        }
        null !== blockedOn && nativeEvent.stopPropagation();
      } else dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
    }
  }
  function findInstanceBlockingEvent(nativeEvent) {
    nativeEvent = getEventTarget(nativeEvent);
    return findInstanceBlockingTarget(nativeEvent);
  }
  var return_targetInst = null;
  function findInstanceBlockingTarget(targetNode) {
    return_targetInst = null;
    targetNode = getClosestInstanceFromNode(targetNode);
    if (null !== targetNode) {
      var nearestMounted = getNearestMountedFiber(targetNode);
      if (null === nearestMounted) targetNode = null;else {
        var tag = nearestMounted.tag;
        if (13 === tag) {
          targetNode = getSuspenseInstanceFromFiber(nearestMounted);
          if (null !== targetNode) return targetNode;
          targetNode = null;
        } else if (3 === tag) {
          if (nearestMounted.stateNode.current.memoizedState.isDehydrated) return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
          targetNode = null;
        } else nearestMounted !== targetNode && (targetNode = null);
      }
    }
    return_targetInst = targetNode;
    return null;
  }
  function getEventPriority(domEventName) {
    switch (domEventName) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (getCurrentPriorityLevel()) {
          case ImmediatePriority:
            return 2;
          case UserBlockingPriority:
            return 8;
          case NormalPriority$1:
          case LowPriority:
            return 32;
          case IdlePriority:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var hasScheduledReplayAttempt = false,
    queuedFocus = null,
    queuedDrag = null,
    queuedMouse = null,
    queuedPointers = new Map(),
    queuedPointerCaptures = new Map(),
    queuedExplicitHydrationTargets = [],
    discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
  function clearIfContinuousEvent(domEventName, nativeEvent) {
    switch (domEventName) {
      case "focusin":
      case "focusout":
        queuedFocus = null;
        break;
      case "dragenter":
      case "dragleave":
        queuedDrag = null;
        break;
      case "mouseover":
      case "mouseout":
        queuedMouse = null;
        break;
      case "pointerover":
      case "pointerout":
        queuedPointers.delete(nativeEvent.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        queuedPointerCaptures.delete(nativeEvent.pointerId);
    }
  }
  function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
    if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent) return existingQueuedEvent = {
      blockedOn: blockedOn,
      domEventName: domEventName,
      eventSystemFlags: eventSystemFlags,
      nativeEvent: nativeEvent,
      targetContainers: [targetContainer]
    }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
    existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
    blockedOn = existingQueuedEvent.targetContainers;
    null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
    return existingQueuedEvent;
  }
  function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
    switch (domEventName) {
      case "focusin":
        return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), true;
      case "dragenter":
        return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), true;
      case "mouseover":
        return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), true;
      case "pointerover":
        var pointerId = nativeEvent.pointerId;
        queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent));
        return true;
      case "gotpointercapture":
        return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)), true;
    }
    return false;
  }
  function attemptExplicitHydrationTarget(queuedTarget) {
    var targetInst = getClosestInstanceFromNode(queuedTarget.target);
    if (null !== targetInst) {
      var nearestMounted = getNearestMountedFiber(targetInst);
      if (null !== nearestMounted) if (targetInst = nearestMounted.tag, 13 === targetInst) {
        if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
          queuedTarget.blockedOn = targetInst;
          runWithPriority(queuedTarget.priority, function () {
            if (13 === nearestMounted.tag) {
              var lane = requestUpdateLane();
              lane = getBumpedLaneForHydrationByLane(lane);
              var root = enqueueConcurrentRenderForLane(nearestMounted, lane);
              null !== root && scheduleUpdateOnFiber(root, nearestMounted, lane);
              markRetryLaneIfNotHydrated(nearestMounted, lane);
            }
          });
          return;
        }
      } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
        queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
        return;
      }
    }
    queuedTarget.blockedOn = null;
  }
  function attemptReplayContinuousQueuedEvent(queuedEvent) {
    if (null !== queuedEvent.blockedOn) return false;
    for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length;) {
      var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
      if (null === nextBlockedOn) {
        nextBlockedOn = queuedEvent.nativeEvent;
        var nativeEventClone = new nextBlockedOn.constructor(nextBlockedOn.type, nextBlockedOn);
        currentReplayingEvent = nativeEventClone;
        nextBlockedOn.target.dispatchEvent(nativeEventClone);
        currentReplayingEvent = null;
      } else return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
      targetContainers.shift();
    }
    return true;
  }
  function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
    attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
  }
  function replayUnblockedEvents() {
    hasScheduledReplayAttempt = false;
    null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
    null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
    null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
    queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
    queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
  }
  function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
    queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents)));
  }
  var lastScheduledReplayQueue = null;
  function scheduleReplayQueueIfNeeded(formReplayingQueue) {
    lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, function () {
      lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
      for (var i = 0; i < formReplayingQueue.length; i += 3) {
        var form = formReplayingQueue[i],
          submitterOrAction = formReplayingQueue[i + 1],
          formData = formReplayingQueue[i + 2];
        if ("function" !== typeof submitterOrAction) if (null === findInstanceBlockingTarget(submitterOrAction || form)) continue;else break;
        var formInst = getInstanceFromNode(form);
        null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, startHostTransition(formInst, {
          pending: true,
          data: formData,
          method: form.method,
          action: submitterOrAction
        }, submitterOrAction, formData));
      }
    }));
  }
  function retryIfBlockedOn(unblocked) {
    function unblock(queuedEvent) {
      return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
    }
    null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
    null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
    null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
    queuedPointers.forEach(unblock);
    queuedPointerCaptures.forEach(unblock);
    for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
      var queuedTarget = queuedExplicitHydrationTargets[i];
      queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
    }
    for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn);) attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
    i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
    if (null != i) for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
      var form = i[queuedTarget],
        submitterOrAction = i[queuedTarget + 1],
        formProps = form[internalPropsKey] || null;
      if ("function" === typeof submitterOrAction) formProps || scheduleReplayQueueIfNeeded(i);else if (formProps) {
        var action = null;
        if (submitterOrAction && submitterOrAction.hasAttribute("formAction")) {
          if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null) action = formProps.formAction;else {
            if (null !== findInstanceBlockingTarget(form)) continue;
          }
        } else action = formProps.action;
        "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
        scheduleReplayQueueIfNeeded(i);
      }
    }
  }
  function ReactDOMRoot(internalRoot) {
    this._internalRoot = internalRoot;
  }
  ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function (children) {
    var root = this._internalRoot;
    if (null === root) throw Error(formatProdErrorMessage(409));
    var current = root.current,
      lane = requestUpdateLane();
    updateContainerImpl(current, lane, children, root, null, null);
  };
  ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function () {
    var root = this._internalRoot;
    if (null !== root) {
      this._internalRoot = null;
      var container = root.containerInfo;
      updateContainerImpl(root.current, 2, null, root, null, null);
      flushSyncWork$1();
      container[internalContainerInstanceKey] = null;
    }
  };
  function ReactDOMHydrationRoot(internalRoot) {
    this._internalRoot = internalRoot;
  }
  ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {
    if (target) {
      var updatePriority = resolveUpdatePriority();
      target = {
        blockedOn: null,
        target: target,
        priority: updatePriority
      };
      for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++);
      queuedExplicitHydrationTargets.splice(i, 0, target);
      0 === i && attemptExplicitHydrationTarget(target);
    }
  };
  var isomorphicReactPackageVersion$jscomp$inline_1785 = React.version;
  if ("19.1.0" !== isomorphicReactPackageVersion$jscomp$inline_1785) throw Error(formatProdErrorMessage(527, isomorphicReactPackageVersion$jscomp$inline_1785, "19.1.0"));
  ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
    var fiber = componentOrElement._reactInternals;
    if (undefined === fiber) {
      if ("function" === typeof componentOrElement.render) throw Error(formatProdErrorMessage(188));
      componentOrElement = Object.keys(componentOrElement).join(",");
      throw Error(formatProdErrorMessage(268, componentOrElement));
    }
    componentOrElement = findCurrentFiberUsingSlowPath(fiber);
    componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
    componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
    return componentOrElement;
  };
  var internals$jscomp$inline_2256 = {
    bundleType: 0,
    version: "19.1.0",
    rendererPackageName: "react-dom",
    currentDispatcherRef: ReactSharedInternals,
    reconcilerVersion: "19.1.0"
  };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var hook$jscomp$inline_2257 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!hook$jscomp$inline_2257.isDisabled && hook$jscomp$inline_2257.supportsFiber) try {
      rendererID = hook$jscomp$inline_2257.inject(internals$jscomp$inline_2256), injectedHook = hook$jscomp$inline_2257;
    } catch (err) {}
  }
  exports.createRoot = function (container, options) {
    if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
    var isStrictMode = false,
      identifierPrefix = "",
      onUncaughtError = defaultOnUncaughtError,
      onCaughtError = defaultOnCaughtError,
      onRecoverableError = defaultOnRecoverableError,
      transitionCallbacks = null;
    null !== options && undefined !== options && (true === options.unstable_strictMode && (isStrictMode = true), undefined !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), undefined !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), undefined !== options.onCaughtError && (onCaughtError = options.onCaughtError), undefined !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), undefined !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks));
    options = createFiberRoot(container, 1, false, null, null, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, null);
    container[internalContainerInstanceKey] = options.current;
    listenToAllSupportedEvents(container);
    return new ReactDOMRoot(options);
  };
  exports.hydrateRoot = function (container, initialChildren, options) {
    if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
    var isStrictMode = false,
      identifierPrefix = "",
      onUncaughtError = defaultOnUncaughtError,
      onCaughtError = defaultOnCaughtError,
      onRecoverableError = defaultOnRecoverableError,
      transitionCallbacks = null,
      formState = null;
    null !== options && undefined !== options && (true === options.unstable_strictMode && (isStrictMode = true), undefined !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), undefined !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), undefined !== options.onCaughtError && (onCaughtError = options.onCaughtError), undefined !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), undefined !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks), undefined !== options.formState && (formState = options.formState));
    initialChildren = createFiberRoot(container, 1, true, initialChildren, null != options ? options : null, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState);
    initialChildren.context = getContextForSubtree(null);
    options = initialChildren.current;
    isStrictMode = requestUpdateLane();
    isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
    identifierPrefix = createUpdate(isStrictMode);
    identifierPrefix.callback = null;
    enqueueUpdate(options, identifierPrefix, isStrictMode);
    options = isStrictMode;
    initialChildren.current.lanes = options;
    markRootUpdated$1(initialChildren, options);
    ensureRootIsScheduled(initialChildren);
    container[internalContainerInstanceKey] = initialChildren.current;
    listenToAllSupportedEvents(container);
    return new ReactDOMHydrationRoot(initialChildren);
  };
  exports.version = "19.1.0";
},32,[33,35,37]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  {
    module.exports = require(_dependencyMap[0]);
  }
},33,[34]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * scheduler.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  "use strict";

  function push(heap, node) {
    var index = heap.length;
    heap.push(node);
    a: for (; 0 < index;) {
      var parentIndex = index - 1 >>> 1,
        parent = heap[parentIndex];
      if (0 < compare(parent, node)) heap[parentIndex] = node, heap[index] = parent, index = parentIndex;else break a;
    }
  }
  function peek(heap) {
    return 0 === heap.length ? null : heap[0];
  }
  function pop(heap) {
    if (0 === heap.length) return null;
    var first = heap[0],
      last = heap.pop();
    if (last !== first) {
      heap[0] = last;
      a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength;) {
        var leftIndex = 2 * (index + 1) - 1,
          left = heap[leftIndex],
          rightIndex = leftIndex + 1,
          right = heap[rightIndex];
        if (0 > compare(left, last)) rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);else if (rightIndex < length && 0 > compare(right, last)) heap[index] = right, heap[rightIndex] = last, index = rightIndex;else break a;
      }
    }
    return first;
  }
  function compare(a, b) {
    var diff = a.sortIndex - b.sortIndex;
    return 0 !== diff ? diff : a.id - b.id;
  }
  exports.unstable_now = undefined;
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var localPerformance = performance;
    exports.unstable_now = function () {
      return localPerformance.now();
    };
  } else {
    var localDate = Date,
      initialTime = localDate.now();
    exports.unstable_now = function () {
      return localDate.now() - initialTime;
    };
  }
  var taskQueue = [],
    timerQueue = [],
    taskIdCounter = 1,
    currentTask = null,
    currentPriorityLevel = 3,
    isPerformingWork = false,
    isHostCallbackScheduled = false,
    isHostTimeoutScheduled = false,
    needsPaint = false,
    localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
    localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null,
    localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
  function advanceTimers(currentTime) {
    for (var timer = peek(timerQueue); null !== timer;) {
      if (null === timer.callback) pop(timerQueue);else if (timer.startTime <= currentTime) pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);else break;
      timer = peek(timerQueue);
    }
  }
  function handleTimeout(currentTime) {
    isHostTimeoutScheduled = false;
    advanceTimers(currentTime);
    if (!isHostCallbackScheduled) if (null !== peek(taskQueue)) isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());else {
      var firstTimer = peek(timerQueue);
      null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }
  }
  var isMessageLoopRunning = false,
    taskTimeoutID = -1,
    frameInterval = 5,
    startTime = -1;
  function shouldYieldToHost() {
    return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
  }
  function performWorkUntilDeadline() {
    needsPaint = false;
    if (isMessageLoopRunning) {
      var currentTime = exports.unstable_now();
      startTime = currentTime;
      var hasMoreWork = true;
      try {
        a: {
          isHostCallbackScheduled = false;
          isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
          isPerformingWork = true;
          var previousPriorityLevel = currentPriorityLevel;
          try {
            b: {
              advanceTimers(currentTime);
              for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost());) {
                var callback = currentTask.callback;
                if ("function" === typeof callback) {
                  currentTask.callback = null;
                  currentPriorityLevel = currentTask.priorityLevel;
                  var continuationCallback = callback(currentTask.expirationTime <= currentTime);
                  currentTime = exports.unstable_now();
                  if ("function" === typeof continuationCallback) {
                    currentTask.callback = continuationCallback;
                    advanceTimers(currentTime);
                    hasMoreWork = true;
                    break b;
                  }
                  currentTask === peek(taskQueue) && pop(taskQueue);
                  advanceTimers(currentTime);
                } else pop(taskQueue);
                currentTask = peek(taskQueue);
              }
              if (null !== currentTask) hasMoreWork = true;else {
                var firstTimer = peek(timerQueue);
                null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                hasMoreWork = false;
              }
            }
            break a;
          } finally {
            currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
          }
          hasMoreWork = undefined;
        }
      } finally {
        hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
      }
    }
  }
  var schedulePerformWorkUntilDeadline;
  if ("function" === typeof localSetImmediate) schedulePerformWorkUntilDeadline = function () {
    localSetImmediate(performWorkUntilDeadline);
  };else if ("undefined" !== typeof MessageChannel) {
    var channel = new MessageChannel(),
      port = channel.port2;
    channel.port1.onmessage = performWorkUntilDeadline;
    schedulePerformWorkUntilDeadline = function () {
      port.postMessage(null);
    };
  } else schedulePerformWorkUntilDeadline = function () {
    localSetTimeout(performWorkUntilDeadline, 0);
  };
  function requestHostTimeout(callback, ms) {
    taskTimeoutID = localSetTimeout(function () {
      callback(exports.unstable_now());
    }, ms);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function (task) {
    task.callback = null;
  };
  exports.unstable_forceFrameRate = function (fps) {
    0 > fps || 125 < fps ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function () {
    return currentPriorityLevel;
  };
  exports.unstable_next = function (eventHandler) {
    switch (currentPriorityLevel) {
      case 1:
      case 2:
      case 3:
        var priorityLevel = 3;
        break;
      default:
        priorityLevel = currentPriorityLevel;
    }
    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = priorityLevel;
    try {
      return eventHandler();
    } finally {
      currentPriorityLevel = previousPriorityLevel;
    }
  };
  exports.unstable_requestPaint = function () {
    needsPaint = true;
  };
  exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
    switch (priorityLevel) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        priorityLevel = 3;
    }
    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = priorityLevel;
    try {
      return eventHandler();
    } finally {
      currentPriorityLevel = previousPriorityLevel;
    }
  };
  exports.unstable_scheduleCallback = function (priorityLevel, callback, options) {
    var currentTime = exports.unstable_now();
    "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
    switch (priorityLevel) {
      case 1:
        var timeout = -1;
        break;
      case 2:
        timeout = 250;
        break;
      case 5:
        timeout = 1073741823;
        break;
      case 4:
        timeout = 1e4;
        break;
      default:
        timeout = 5e3;
    }
    timeout = options + timeout;
    priorityLevel = {
      id: taskIdCounter++,
      callback: callback,
      priorityLevel: priorityLevel,
      startTime: options,
      expirationTime: timeout,
      sortIndex: -1
    };
    options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
    return priorityLevel;
  };
  exports.unstable_shouldYield = shouldYieldToHost;
  exports.unstable_wrapCallback = function (callback) {
    var parentPriorityLevel = currentPriorityLevel;
    return function () {
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = parentPriorityLevel;
      try {
        return callback.apply(this, arguments);
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
  };
},34,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  {
    module.exports = require(_dependencyMap[0]);
  }
},35,[36]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * react.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  "use strict";

  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
    REACT_PORTAL_TYPE = Symbol.for("react.portal"),
    REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
    REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
    REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
    REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
    REACT_CONTEXT_TYPE = Symbol.for("react.context"),
    REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
    REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
    REACT_MEMO_TYPE = Symbol.for("react.memo"),
    REACT_LAZY_TYPE = Symbol.for("react.lazy"),
    MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
  function getIteratorFn(maybeIterable) {
    if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
    maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
    return "function" === typeof maybeIterable ? maybeIterable : null;
  }
  var ReactNoopUpdateQueue = {
      isMounted: function () {
        return false;
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {}
    },
    assign = Object.assign,
    emptyObject = {};
  function Component(props, context, updater) {
    this.props = props;
    this.context = context;
    this.refs = emptyObject;
    this.updater = updater || ReactNoopUpdateQueue;
  }
  Component.prototype.isReactComponent = {};
  Component.prototype.setState = function (partialState, callback) {
    if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, partialState, callback, "setState");
  };
  Component.prototype.forceUpdate = function (callback) {
    this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
  };
  function ComponentDummy() {}
  ComponentDummy.prototype = Component.prototype;
  function PureComponent(props, context, updater) {
    this.props = props;
    this.context = context;
    this.refs = emptyObject;
    this.updater = updater || ReactNoopUpdateQueue;
  }
  var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
  pureComponentPrototype.constructor = PureComponent;
  assign(pureComponentPrototype, Component.prototype);
  pureComponentPrototype.isPureReactComponent = true;
  var isArrayImpl = Array.isArray,
    ReactSharedInternals = {
      H: null,
      A: null,
      T: null,
      S: null,
      V: null
    },
    hasOwnProperty = Object.prototype.hasOwnProperty;
  function ReactElement(type, key, self, source, owner, props) {
    self = props.ref;
    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type: type,
      key: key,
      ref: undefined !== self ? self : null,
      props: props
    };
  }
  function cloneAndReplaceKey(oldElement, newKey) {
    return ReactElement(oldElement.type, newKey, undefined, undefined, undefined, oldElement.props);
  }
  function isValidElement(object) {
    return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
  }
  function escape(key) {
    var escaperLookup = {
      "=": "=0",
      ":": "=2"
    };
    return "$" + key.replace(/[=:]/g, function (match) {
      return escaperLookup[match];
    });
  }
  var userProvidedKeyEscapeRegex = /\/+/g;
  function getElementKey(element, index) {
    return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
  }
  function noop$1() {}
  function resolveThenable(thenable) {
    switch (thenable.status) {
      case "fulfilled":
        return thenable.value;
      case "rejected":
        throw thenable.reason;
      default:
        switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(function (fulfilledValue) {
          "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
        }, function (error) {
          "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
        })), thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
        }
    }
    throw thenable;
  }
  function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
    var type = typeof children;
    if ("undefined" === type || "boolean" === type) children = null;
    var invokeCallback = false;
    if (null === children) invokeCallback = true;else switch (type) {
      case "bigint":
      case "string":
      case "number":
        invokeCallback = true;
        break;
      case "object":
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
            break;
          case REACT_LAZY_TYPE:
            return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback);
        }
    }
    if (invokeCallback) return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function (c) {
      return c;
    })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(callback, escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + invokeCallback)), array.push(callback)), 1;
    invokeCallback = 0;
    var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
    if (isArrayImpl(children)) for (var i = 0; i < children.length; i++) nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);else if (i = getIteratorFn(children), "function" === typeof i) for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done;) nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);else if ("object" === type) {
      if ("function" === typeof children.then) return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
      array = String(children);
      throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead.");
    }
    return invokeCallback;
  }
  function mapChildren(children, func, context) {
    if (null == children) return children;
    var result = [],
      count = 0;
    mapIntoArray(children, result, "", "", function (child) {
      return func.call(context, child, count++);
    });
    return result;
  }
  function lazyInitializer(payload) {
    if (-1 === payload._status) {
      var ctor = payload._result;
      ctor = ctor();
      ctor.then(function (moduleObject) {
        if (0 === payload._status || -1 === payload._status) payload._status = 1, payload._result = moduleObject;
      }, function (error) {
        if (0 === payload._status || -1 === payload._status) payload._status = 2, payload._result = error;
      });
      -1 === payload._status && (payload._status = 0, payload._result = ctor);
    }
    if (1 === payload._status) return payload._result.default;
    throw payload._result;
  }
  var reportGlobalError = "function" === typeof reportError ? reportError : function (error) {
    if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
      var event = new window.ErrorEvent("error", {
        bubbles: true,
        cancelable: true,
        message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
        error: error
      });
      if (!window.dispatchEvent(event)) return;
    } else if ("object" === typeof process && "function" === typeof process.emit) {
      process.emit("uncaughtException", error);
      return;
    }
    console.error(error);
  };
  function noop() {}
  exports.Children = {
    map: mapChildren,
    forEach: function (children, forEachFunc, forEachContext) {
      mapChildren(children, function () {
        forEachFunc.apply(this, arguments);
      }, forEachContext);
    },
    count: function (children) {
      var n = 0;
      mapChildren(children, function () {
        n++;
      });
      return n;
    },
    toArray: function (children) {
      return mapChildren(children, function (child) {
        return child;
      }) || [];
    },
    only: function (children) {
      if (!isValidElement(children)) throw Error("React.Children.only expected to receive a single React element child.");
      return children;
    }
  };
  exports.Component = Component;
  exports.Fragment = REACT_FRAGMENT_TYPE;
  exports.Profiler = REACT_PROFILER_TYPE;
  exports.PureComponent = PureComponent;
  exports.StrictMode = REACT_STRICT_MODE_TYPE;
  exports.Suspense = REACT_SUSPENSE_TYPE;
  exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
  exports.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function (size) {
      return ReactSharedInternals.H.useMemoCache(size);
    }
  };
  exports.cache = function (fn) {
    return function () {
      return fn.apply(null, arguments);
    };
  };
  exports.cloneElement = function (element, config, children) {
    if (null === element || undefined === element) throw Error("The argument must be a React element, but you passed " + element + ".");
    var props = assign({}, element.props),
      key = element.key,
      owner = undefined;
    if (null != config) for (propName in undefined !== config.ref && (owner = undefined), undefined !== config.key && (key = "" + config.key), config) !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && undefined === config.ref || (props[propName] = config[propName]);
    var propName = arguments.length - 2;
    if (1 === propName) props.children = children;else if (1 < propName) {
      for (var childArray = Array(propName), i = 0; i < propName; i++) childArray[i] = arguments[i + 2];
      props.children = childArray;
    }
    return ReactElement(element.type, key, undefined, undefined, owner, props);
  };
  exports.createContext = function (defaultValue) {
    defaultValue = {
      $$typeof: REACT_CONTEXT_TYPE,
      _currentValue: defaultValue,
      _currentValue2: defaultValue,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    };
    defaultValue.Provider = defaultValue;
    defaultValue.Consumer = {
      $$typeof: REACT_CONSUMER_TYPE,
      _context: defaultValue
    };
    return defaultValue;
  };
  exports.createElement = function (type, config, children) {
    var propName,
      props = {},
      key = null;
    if (null != config) for (propName in undefined !== config.key && (key = "" + config.key), config) hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
    var childrenLength = arguments.length - 2;
    if (1 === childrenLength) props.children = children;else if (1 < childrenLength) {
      for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++) childArray[i] = arguments[i + 2];
      props.children = childArray;
    }
    if (type && type.defaultProps) for (propName in childrenLength = type.defaultProps, childrenLength) undefined === props[propName] && (props[propName] = childrenLength[propName]);
    return ReactElement(type, key, undefined, undefined, null, props);
  };
  exports.createRef = function () {
    return {
      current: null
    };
  };
  exports.forwardRef = function (render) {
    return {
      $$typeof: REACT_FORWARD_REF_TYPE,
      render: render
    };
  };
  exports.isValidElement = isValidElement;
  exports.lazy = function (ctor) {
    return {
      $$typeof: REACT_LAZY_TYPE,
      _payload: {
        _status: -1,
        _result: ctor
      },
      _init: lazyInitializer
    };
  };
  exports.memo = function (type, compare) {
    return {
      $$typeof: REACT_MEMO_TYPE,
      type: type,
      compare: undefined === compare ? null : compare
    };
  };
  exports.startTransition = function (scope) {
    var prevTransition = ReactSharedInternals.T,
      currentTransition = {};
    ReactSharedInternals.T = currentTransition;
    try {
      var returnValue = scope(),
        onStartTransitionFinish = ReactSharedInternals.S;
      null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
      "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
    } catch (error) {
      reportGlobalError(error);
    } finally {
      ReactSharedInternals.T = prevTransition;
    }
  };
  exports.unstable_useCacheRefresh = function () {
    return ReactSharedInternals.H.useCacheRefresh();
  };
  exports.use = function (usable) {
    return ReactSharedInternals.H.use(usable);
  };
  exports.useActionState = function (action, initialState, permalink) {
    return ReactSharedInternals.H.useActionState(action, initialState, permalink);
  };
  exports.useCallback = function (callback, deps) {
    return ReactSharedInternals.H.useCallback(callback, deps);
  };
  exports.useContext = function (Context) {
    return ReactSharedInternals.H.useContext(Context);
  };
  exports.useDebugValue = function () {};
  exports.useDeferredValue = function (value, initialValue) {
    return ReactSharedInternals.H.useDeferredValue(value, initialValue);
  };
  exports.useEffect = function (create, createDeps, update) {
    var dispatcher = ReactSharedInternals.H;
    if ("function" === typeof update) throw Error("useEffect CRUD overload is not enabled in this build of React.");
    return dispatcher.useEffect(create, createDeps);
  };
  exports.useId = function () {
    return ReactSharedInternals.H.useId();
  };
  exports.useImperativeHandle = function (ref, create, deps) {
    return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
  };
  exports.useInsertionEffect = function (create, deps) {
    return ReactSharedInternals.H.useInsertionEffect(create, deps);
  };
  exports.useLayoutEffect = function (create, deps) {
    return ReactSharedInternals.H.useLayoutEffect(create, deps);
  };
  exports.useMemo = function (create, deps) {
    return ReactSharedInternals.H.useMemo(create, deps);
  };
  exports.useOptimistic = function (passthrough, reducer) {
    return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
  };
  exports.useReducer = function (reducer, initialArg, init) {
    return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
  };
  exports.useRef = function (initialValue) {
    return ReactSharedInternals.H.useRef(initialValue);
  };
  exports.useState = function (initialState) {
    return ReactSharedInternals.H.useState(initialState);
  };
  exports.useSyncExternalStore = function (subscribe, getSnapshot, getServerSnapshot) {
    return ReactSharedInternals.H.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
  };
  exports.useTransition = function () {
    return ReactSharedInternals.H.useTransition();
  };
  exports.version = "19.1.0";
},36,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function checkDCE() {
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
      return;
    }
    try {
      // Verify that the code above has been dead code eliminated (DCE'd).
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      // DevTools shouldn't crash React, no matter what.
      // We should still report in case we break this code.
      console.error(err);
    }
  }
  {
    // DCE check should happen before ReactDOM bundle executes so that
    // DevTools can report bad minification during injection.
    checkDCE();
    module.exports = require(_dependencyMap[0]);
  }
},37,[38]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * react-dom.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  "use strict";

  var React = require(_dependencyMap[0]);
  function formatProdErrorMessage(code) {
    var url = "https://react.dev/errors/" + code;
    if (1 < arguments.length) {
      url += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var i = 2; i < arguments.length; i++) url += "&args[]=" + encodeURIComponent(arguments[i]);
    }
    return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function noop() {}
  var Internals = {
      d: {
        f: noop,
        r: function () {
          throw Error(formatProdErrorMessage(522));
        },
        D: noop,
        C: noop,
        L: noop,
        m: noop,
        X: noop,
        S: noop,
        M: noop
      },
      p: 0,
      findDOMNode: null
    },
    REACT_PORTAL_TYPE = Symbol.for("react.portal");
  function createPortal$1(children, containerInfo, implementation) {
    var key = 3 < arguments.length && undefined !== arguments[3] ? arguments[3] : null;
    return {
      $$typeof: REACT_PORTAL_TYPE,
      key: null == key ? null : "" + key,
      children: children,
      containerInfo: containerInfo,
      implementation: implementation
    };
  }
  var ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function getCrossOriginStringAs(as, input) {
    if ("font" === as) return "";
    if ("string" === typeof input) return "use-credentials" === input ? input : "";
  }
  exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
  exports.createPortal = function (children, container) {
    var key = 2 < arguments.length && undefined !== arguments[2] ? arguments[2] : null;
    if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType) throw Error(formatProdErrorMessage(299));
    return createPortal$1(children, container, null, key);
  };
  exports.flushSync = function (fn) {
    var previousTransition = ReactSharedInternals.T,
      previousUpdatePriority = Internals.p;
    try {
      if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
    } finally {
      ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
    }
  };
  exports.preconnect = function (href, options) {
    "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : undefined) : options = null, Internals.d.C(href, options));
  };
  exports.prefetchDNS = function (href) {
    "string" === typeof href && Internals.d.D(href);
  };
  exports.preinit = function (href, options) {
    if ("string" === typeof href && options && "string" === typeof options.as) {
      var as = options.as,
        crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),
        integrity = "string" === typeof options.integrity ? options.integrity : undefined,
        fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : undefined;
      "style" === as ? Internals.d.S(href, "string" === typeof options.precedence ? options.precedence : undefined, {
        crossOrigin: crossOrigin,
        integrity: integrity,
        fetchPriority: fetchPriority
      }) : "script" === as && Internals.d.X(href, {
        crossOrigin: crossOrigin,
        integrity: integrity,
        fetchPriority: fetchPriority,
        nonce: "string" === typeof options.nonce ? options.nonce : undefined
      });
    }
  };
  exports.preinitModule = function (href, options) {
    if ("string" === typeof href) if ("object" === typeof options && null !== options) {
      if (null == options.as || "script" === options.as) {
        var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
        Internals.d.M(href, {
          crossOrigin: crossOrigin,
          integrity: "string" === typeof options.integrity ? options.integrity : undefined,
          nonce: "string" === typeof options.nonce ? options.nonce : undefined
        });
      }
    } else null == options && Internals.d.M(href);
  };
  exports.preload = function (href, options) {
    if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
      var as = options.as,
        crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
      Internals.d.L(href, as, {
        crossOrigin: crossOrigin,
        integrity: "string" === typeof options.integrity ? options.integrity : undefined,
        nonce: "string" === typeof options.nonce ? options.nonce : undefined,
        type: "string" === typeof options.type ? options.type : undefined,
        fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : undefined,
        referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : undefined,
        imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : undefined,
        imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : undefined,
        media: "string" === typeof options.media ? options.media : undefined
      });
    }
  };
  exports.preloadModule = function (href, options) {
    if ("string" === typeof href) if (options) {
      var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
      Internals.d.m(href, {
        as: "string" === typeof options.as && "script" !== options.as ? options.as : undefined,
        crossOrigin: crossOrigin,
        integrity: "string" === typeof options.integrity ? options.integrity : undefined
      });
    } else Internals.d.m(href);
  };
  exports.requestFormReset = function (form) {
    Internals.d.r(form);
  };
  exports.unstable_batchedUpdates = function (fn, a) {
    return fn(a);
  };
  exports.useFormState = function (action, initialState, permalink) {
    return ReactSharedInternals.H.useFormState(action, initialState, permalink);
  };
  exports.useFormStatus = function () {
    return ReactSharedInternals.H.useHostTransitionStatus();
  };
  exports.version = "19.1.0";
},38,[35]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.createSheet = createSheet;
  var _modulesCanUseDom = require(_dependencyMap[0]);
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  var _createCSSStyleSheet = require(_dependencyMap[1]);
  var createCSSStyleSheet = _interopDefault(_createCSSStyleSheet);
  var _createOrderedCSSStyleSheet = require(_dependencyMap[2]);
  var createOrderedCSSStyleSheet = _interopDefault(_createOrderedCSSStyleSheet);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var defaultId = 'react-native-stylesheet';
  var roots = new WeakMap();
  var sheets = [];
  var initialRules = [
  // minimal top-level reset
  'html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:rgba(0,0,0,0);}', 'body{margin:0;}',
  // minimal form pseudo-element reset
  'button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0;}', 'input::-webkit-search-cancel-button,input::-webkit-search-decoration,input::-webkit-search-results-button,input::-webkit-search-results-decoration{display:none;}'];
  function createSheet(root, id) {
    if (id === undefined) {
      id = defaultId;
    }
    var sheet;
    if (canUseDOM.default) {
      var rootNode = root != null ? root.getRootNode() : document;
      // Create the initial style sheet
      if (sheets.length === 0) {
        sheet = (0, createOrderedCSSStyleSheet.default)((0, createCSSStyleSheet.default)(id));
        initialRules.forEach(rule => {
          sheet.insert(rule, 0);
        });
        roots.set(rootNode, sheets.length);
        sheets.push(sheet);
      } else {
        var index = roots.get(rootNode);
        if (index == null) {
          var initialSheet = sheets[0];
          // If we're creating a new sheet, populate it with existing styles
          var textContent = initialSheet != null ? initialSheet.getTextContent() : '';
          // Cast rootNode to 'any' because Flow types for getRootNode are wrong
          sheet = (0, createOrderedCSSStyleSheet.default)((0, createCSSStyleSheet.default)(id, rootNode, textContent));
          roots.set(rootNode, sheets.length);
          sheets.push(sheet);
        } else {
          sheet = sheets[index];
        }
      }
    } else {
      // Create the initial style sheet
      if (sheets.length === 0) {
        sheet = (0, createOrderedCSSStyleSheet.default)((0, createCSSStyleSheet.default)(id));
        initialRules.forEach(rule => {
          sheet.insert(rule, 0);
        });
        sheets.push(sheet);
      } else {
        sheet = sheets[0];
      }
    }
    return {
      getTextContent() {
        return sheet.getTextContent();
      },
      id,
      insert(cssText, groupValue) {
        sheets.forEach(s => {
          s.insert(cssText, groupValue);
        });
      }
    };
  }
},39,[40,41,42]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
  var _default = canUseDOM;
},40,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return createCSSStyleSheet;
    }
  });
  var _modulesCanUseDom = require(_dependencyMap[0]);
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  // $FlowFixMe: HTMLStyleElement is incorrectly typed - https://github.com/facebook/flow/issues/2696
  function createCSSStyleSheet(id, rootNode, textContent) {
    if (canUseDOM.default) {
      var root = rootNode != null ? rootNode : document;
      var element = root.getElementById(id);
      if (element == null) {
        element = document.createElement('style');
        element.setAttribute('id', id);
        if (typeof textContent === 'string') {
          element.appendChild(document.createTextNode(textContent));
        }
        if (root instanceof ShadowRoot) {
          root.insertBefore(element, root.firstChild);
        } else {
          var head = root.head;
          if (head) {
            head.insertBefore(element, head.firstChild);
          }
        }
      }
      // $FlowFixMe: HTMLElement is incorrectly typed
      return element.sheet;
    } else {
      return null;
    }
  }
},41,[40]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return createOrderedCSSStyleSheet;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var slice = Array.prototype.slice;

  /**
   * Order-based insertion of CSS.
   *
   * Each rule is associated with a numerically defined group.
   * Groups are ordered within the style sheet according to their number, with the
   * lowest first.
   *
   * Groups are implemented using marker rules. The selector of the first rule of
   * each group is used only to encode the group number for hydration. An
   * alternative implementation could rely on CSSMediaRule, allowing groups to be
   * treated as a sub-sheet, but the Edge implementation of CSSMediaRule is
   * broken.
   * https://developer.mozilla.org/en-US/docs/Web/API/CSSMediaRule
   * https://gist.github.com/necolas/aa0c37846ad6bd3b05b727b959e82674
   */
  function createOrderedCSSStyleSheet(sheet) {
    var groups = {};
    var selectors = {};

    /**
     * Hydrate approximate record from any existing rules in the sheet.
     */
    if (sheet != null) {
      var group;
      slice.call(sheet.cssRules).forEach((cssRule, i) => {
        var cssText = cssRule.cssText;
        // Create record of existing selectors and rules
        if (cssText.indexOf('stylesheet-group') > -1) {
          group = decodeGroupRule(cssRule);
          groups[group] = {
            start: i,
            rules: [cssText]
          };
        } else {
          var selectorText = getSelectorText(cssText);
          if (selectorText != null) {
            selectors[selectorText] = true;
            groups[group].rules.push(cssText);
          }
        }
      });
    }
    function sheetInsert(sheet, group, text) {
      var orderedGroups = getOrderedGroups(groups);
      var groupIndex = orderedGroups.indexOf(group);
      var nextGroupIndex = groupIndex + 1;
      var nextGroup = orderedGroups[nextGroupIndex];
      // Insert rule before the next group, or at the end of the stylesheet
      var position = nextGroup != null && groups[nextGroup].start != null ? groups[nextGroup].start : sheet.cssRules.length;
      var isInserted = insertRuleAt(sheet, text, position);
      if (isInserted) {
        // Set the starting index of the new group
        if (groups[group].start == null) {
          groups[group].start = position;
        }
        // Increment the starting index of all subsequent groups
        for (var i = nextGroupIndex; i < orderedGroups.length; i += 1) {
          var groupNumber = orderedGroups[i];
          var previousStart = groups[groupNumber].start || 0;
          groups[groupNumber].start = previousStart + 1;
        }
      }
      return isInserted;
    }
    var OrderedCSSStyleSheet = {
      /**
       * The textContent of the style sheet.
       */
      getTextContent() {
        return getOrderedGroups(groups).map(group => {
          var rules = groups[group].rules;
          // Sorting provides deterministic order of styles in group for
          // build-time extraction of the style sheet.
          var marker = rules.shift();
          rules.sort();
          rules.unshift(marker);
          return rules.join('\n');
        }).join('\n');
      },
      /**
       * Insert a rule into the style sheet
       */
      insert(cssText, groupValue) {
        var group = Number(groupValue);

        // Create a new group.
        if (groups[group] == null) {
          var markerRule = encodeGroupRule(group);
          // Create the internal record.
          groups[group] = {
            start: null,
            rules: [markerRule]
          };
          // Update CSSOM.
          if (sheet != null) {
            sheetInsert(sheet, group, markerRule);
          }
        }

        // selectorText is more reliable than cssText for insertion checks. The
        // browser excludes vendor-prefixed properties and rewrites certain values
        // making cssText more likely to be different from what was inserted.
        var selectorText = getSelectorText(cssText);
        if (selectorText != null && selectors[selectorText] == null) {
          // Update the internal records.
          selectors[selectorText] = true;
          groups[group].rules.push(cssText);
          // Update CSSOM.
          if (sheet != null) {
            var isInserted = sheetInsert(sheet, group, cssText);
            if (!isInserted) {
              // Revert internal record change if a rule was rejected (e.g.,
              // unrecognized pseudo-selector)
              groups[group].rules.pop();
            }
          }
        }
      }
    };
    return OrderedCSSStyleSheet;
  }

  /**
   * Helper functions
   */

  function encodeGroupRule(group) {
    return "[stylesheet-group=\"" + group + "\"]{}";
  }
  var groupPattern = /["']/g;
  function decodeGroupRule(cssRule) {
    return Number(cssRule.selectorText.split(groupPattern)[1]);
  }
  function getOrderedGroups(obj) {
    return Object.keys(obj).map(Number).sort((a, b) => a > b ? 1 : -1);
  }
  var selectorPattern = /\s*([,])\s*/g;
  function getSelectorText(cssText) {
    var selector = cssText.split('{')[0].trim();
    return selector !== '' ? selector.replace(selectorPattern, '$1') : null;
  }
  function insertRuleAt(root, cssText, position) {
    try {
      // $FlowFixMe: Flow is missing CSSOM types needed to type 'root'.
      root.insertRule(cssText, position);
      return true;
    } catch (e) {
      // JSDOM doesn't support `CSSSMediaRule#insertRule`.
      // Also ignore errors that occur from attempting to insert vendor-prefixed selectors.
      return false;
    }
  }
},42,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _compiler = require(_dependencyMap[2]);
  var _dom = require(_dependencyMap[3]);
  var _styleqTransformLocalizeStyle = require(_dependencyMap[4]);
  var _preprocess = require(_dependencyMap[5]);
  var _styleq = require(_dependencyMap[6]);
  var _validate = require(_dependencyMap[7]);
  var _modulesCanUseDom = require(_dependencyMap[8]);
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  var _excluded = ["writingDirection"];
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var staticStyleMap = new WeakMap();
  var sheet = (0, _dom.createSheet)();
  var defaultPreprocessOptions = {
    shadow: true,
    textShadow: true
  };
  function customStyleq(styles, options) {
    if (options === undefined) {
      options = {};
    }
    var _options = options,
      writingDirection = _options.writingDirection,
      preprocessOptions = (0, _objectWithoutPropertiesLoose.default)(_options, _excluded);
    var isRTL = writingDirection === 'rtl';
    return _styleq.styleq.factory({
      transform(style) {
        var compiledStyle = staticStyleMap.get(style);
        if (compiledStyle != null) {
          return (0, _styleqTransformLocalizeStyle.localizeStyle)(compiledStyle, isRTL);
        }
        return (0, _preprocess.preprocess)(style, (0, _objectSpread.default)((0, _objectSpread.default)({}, defaultPreprocessOptions), preprocessOptions));
      }
    })(styles);
  }
  function insertRules(compiledOrderedRules) {
    compiledOrderedRules.forEach(_ref => {
      var rules = _ref[0],
        order = _ref[1];
      if (sheet != null) {
        rules.forEach(rule => {
          sheet.insert(rule, order);
        });
      }
    });
  }
  function compileAndInsertAtomic(style) {
    var _atomic = (0, _compiler.atomic)((0, _preprocess.preprocess)(style, defaultPreprocessOptions)),
      compiledStyle = _atomic[0],
      compiledOrderedRules = _atomic[1];
    insertRules(compiledOrderedRules);
    return compiledStyle;
  }
  function compileAndInsertReset(style, key) {
    var _classic = (0, _compiler.classic)(style, key),
      compiledStyle = _classic[0],
      compiledOrderedRules = _classic[1];
    insertRules(compiledOrderedRules);
    return compiledStyle;
  }

  /* ----- API ----- */

  var absoluteFillObject = {
    position: 'absolute',
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  };
  var absoluteFill = create({
    x: (0, _objectSpread.default)({}, absoluteFillObject)
  }).x;

  /**
   * create
   */
  function create(styles) {
    Object.keys(styles).forEach(key => {
      var styleObj = styles[key];
      // Only compile at runtime if the style is not already compiled
      if (styleObj != null && styleObj.$$css !== true) {
        var compiledStyles;
        if (key.indexOf('$raw') > -1) {
          compiledStyles = compileAndInsertReset(styleObj, key.split('$raw')[0]);
        } else {
          compiledStyles = compileAndInsertAtomic(styleObj);
        }
        staticStyleMap.set(styleObj, compiledStyles);
      }
    });
    return styles;
  }

  /**
   * compose
   */
  function compose(style1, style2) {
    return [style1, style2];
  }

  /**
   * flatten
   */
  function flatten() {
    for (var _len = arguments.length, styles = new Array(_len), _key = 0; _key < _len; _key++) {
      styles[_key] = arguments[_key];
    }
    var flatArray = styles.flat(Infinity);
    var result = {};
    for (var i = 0; i < flatArray.length; i++) {
      var style = flatArray[i];
      if (style != null && typeof style === 'object') {
        // $FlowFixMe
        Object.assign(result, style);
      }
    }
    return result;
  }

  /**
   * getSheet
   */
  function getSheet() {
    return {
      id: sheet.id,
      textContent: sheet.getTextContent()
    };
  }

  /**
   * resolve
   */

  function StyleSheet(styles, options) {
    if (options === undefined) {
      options = {};
    }
    var isRTL = options.writingDirection === 'rtl';
    var styleProps = customStyleq(styles, options);
    if (Array.isArray(styleProps) && styleProps[1] != null) {
      styleProps[1] = (0, _compiler.inline)(styleProps[1], isRTL);
    }
    return styleProps;
  }
  StyleSheet.absoluteFill = absoluteFill;
  StyleSheet.absoluteFillObject = absoluteFillObject;
  StyleSheet.create = create;
  StyleSheet.compose = compose;
  StyleSheet.flatten = flatten;
  StyleSheet.getSheet = getSheet;
  // `hairlineWidth` is not implemented using screen density as browsers may
  // round sub-pixel values down to `0`, causing the line not to be rendered.
  StyleSheet.hairlineWidth = 1;
  if (canUseDOM.default && window.__REACT_DEVTOOLS_GLOBAL_HOOK__) {
    window.__REACT_DEVTOOLS_GLOBAL_HOOK__.resolveRNStyle = StyleSheet.flatten;
  }
  var stylesheet = StyleSheet;
  var _default = stylesheet;
},43,[20,44,45,39,85,87,89,90,40]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _objectWithoutPropertiesLoose;
    }
  });
  function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
      if (e.includes(n)) continue;
      t[n] = r[n];
    }
    return t;
  }
},44,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.atomic = atomic;
  exports.classic = classic;
  exports.inline = inline;
  exports.stringifyValueWithProperty = stringifyValueWithProperty;
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _createReactDOMStyle = require(_dependencyMap[2]);
  var createReactDOMStyle = _interopDefault(_createReactDOMStyle);
  var _hash = require(_dependencyMap[3]);
  var hash = _interopDefault(_hash);
  var _hyphenateStyleName = require(_dependencyMap[4]);
  var hyphenateStyleName = _interopDefault(_hyphenateStyleName);
  var _normalizeValueWithProperty = require(_dependencyMap[5]);
  var normalizeValueWithProperty = _interopDefault(_normalizeValueWithProperty);
  var _modulesPrefixStyles = require(_dependencyMap[6]);
  var prefixStyles = _interopDefault(_modulesPrefixStyles);
  var _excluded = ["animationKeyframes"];
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var cache = new Map();
  var emptyObject = {};
  var classicGroup = 1;
  var atomicGroup = 3;
  var customGroup = {
    borderColor: 2,
    borderRadius: 2,
    borderStyle: 2,
    borderWidth: 2,
    display: 2,
    flex: 2,
    inset: 2,
    margin: 2,
    overflow: 2,
    overscrollBehavior: 2,
    padding: 2,
    insetBlock: 2.1,
    insetInline: 2.1,
    marginInline: 2.1,
    marginBlock: 2.1,
    paddingInline: 2.1,
    paddingBlock: 2.1,
    borderBlockStartColor: 2.2,
    borderBlockStartStyle: 2.2,
    borderBlockStartWidth: 2.2,
    borderBlockEndColor: 2.2,
    borderBlockEndStyle: 2.2,
    borderBlockEndWidth: 2.2,
    borderInlineStartColor: 2.2,
    borderInlineStartStyle: 2.2,
    borderInlineStartWidth: 2.2,
    borderInlineEndColor: 2.2,
    borderInlineEndStyle: 2.2,
    borderInlineEndWidth: 2.2,
    borderEndStartRadius: 2.2,
    borderEndEndRadius: 2.2,
    borderStartStartRadius: 2.2,
    borderStartEndRadius: 2.2,
    insetBlockEnd: 2.2,
    insetBlockStart: 2.2,
    insetInlineEnd: 2.2,
    insetInlineStart: 2.2,
    marginBlockStart: 2.2,
    marginBlockEnd: 2.2,
    marginInlineStart: 2.2,
    marginInlineEnd: 2.2,
    paddingBlockStart: 2.2,
    paddingBlockEnd: 2.2,
    paddingInlineStart: 2.2,
    paddingInlineEnd: 2.2
  };
  var borderTopLeftRadius = 'borderTopLeftRadius';
  var borderTopRightRadius = 'borderTopRightRadius';
  var borderBottomLeftRadius = 'borderBottomLeftRadius';
  var borderBottomRightRadius = 'borderBottomRightRadius';
  var borderLeftColor = 'borderLeftColor';
  var borderLeftStyle = 'borderLeftStyle';
  var borderLeftWidth = 'borderLeftWidth';
  var borderRightColor = 'borderRightColor';
  var borderRightStyle = 'borderRightStyle';
  var borderRightWidth = 'borderRightWidth';
  var right = 'right';
  var marginLeft = 'marginLeft';
  var marginRight = 'marginRight';
  var paddingLeft = 'paddingLeft';
  var paddingRight = 'paddingRight';
  var left = 'left';

  // Map of LTR property names to their BiDi equivalent.
  var PROPERTIES_FLIP = {
    [borderTopLeftRadius]: borderTopRightRadius,
    [borderTopRightRadius]: borderTopLeftRadius,
    [borderBottomLeftRadius]: borderBottomRightRadius,
    [borderBottomRightRadius]: borderBottomLeftRadius,
    [borderLeftColor]: borderRightColor,
    [borderLeftStyle]: borderRightStyle,
    [borderLeftWidth]: borderRightWidth,
    [borderRightColor]: borderLeftColor,
    [borderRightStyle]: borderLeftStyle,
    [borderRightWidth]: borderLeftWidth,
    [left]: right,
    [marginLeft]: marginRight,
    [marginRight]: marginLeft,
    [paddingLeft]: paddingRight,
    [paddingRight]: paddingLeft,
    [right]: left
  };

  // Map of I18N property names to their LTR equivalent.
  var PROPERTIES_I18N = {
    borderStartStartRadius: borderTopLeftRadius,
    borderStartEndRadius: borderTopRightRadius,
    borderEndStartRadius: borderBottomLeftRadius,
    borderEndEndRadius: borderBottomRightRadius,
    borderInlineStartColor: borderLeftColor,
    borderInlineStartStyle: borderLeftStyle,
    borderInlineStartWidth: borderLeftWidth,
    borderInlineEndColor: borderRightColor,
    borderInlineEndStyle: borderRightStyle,
    borderInlineEndWidth: borderRightWidth,
    insetInlineEnd: right,
    insetInlineStart: left,
    marginInlineStart: marginLeft,
    marginInlineEnd: marginRight,
    paddingInlineStart: paddingLeft,
    paddingInlineEnd: paddingRight
  };
  var PROPERTIES_VALUE = ['clear', 'float', 'textAlign'];
  function atomic(style) {
    var compiledStyle = {
      $$css: true
    };
    var compiledRules = [];
    function atomicCompile(srcProp, prop, value) {
      var valueString = stringifyValueWithProperty(value, prop);
      var cacheKey = prop + valueString;
      var cachedResult = cache.get(cacheKey);
      var identifier;
      if (cachedResult != null) {
        identifier = cachedResult[0];
        compiledRules.push(cachedResult[1]);
      } else {
        var v = srcProp !== prop ? cacheKey : valueString;
        identifier = createIdentifier('r', srcProp, v);
        var order = customGroup[srcProp] || atomicGroup;
        var rules = createAtomicRules(identifier, prop, value);
        var orderedRules = [rules, order];
        compiledRules.push(orderedRules);
        cache.set(cacheKey, [identifier, orderedRules]);
      }
      return identifier;
    }
    Object.keys(style).sort().forEach(srcProp => {
      var value = style[srcProp];
      if (value != null) {
        var localizeableValue;
        // BiDi flip values
        if (PROPERTIES_VALUE.indexOf(srcProp) > -1) {
          var _left = atomicCompile(srcProp, srcProp, 'left');
          var _right = atomicCompile(srcProp, srcProp, 'right');
          if (value === 'start') {
            localizeableValue = [_left, _right];
          } else if (value === 'end') {
            localizeableValue = [_right, _left];
          }
        }
        // BiDi flip properties
        var propPolyfill = PROPERTIES_I18N[srcProp];
        if (propPolyfill != null) {
          var ltr = atomicCompile(srcProp, propPolyfill, value);
          var rtl = atomicCompile(srcProp, PROPERTIES_FLIP[propPolyfill], value);
          localizeableValue = [ltr, rtl];
        }
        // BiDi flip transitionProperty value
        if (srcProp === 'transitionProperty') {
          var values = Array.isArray(value) ? value : [value];
          var polyfillIndices = [];
          for (var i = 0; i < values.length; i++) {
            var val = values[i];
            if (typeof val === 'string' && PROPERTIES_I18N[val] != null) {
              polyfillIndices.push(i);
            }
          }
          if (polyfillIndices.length > 0) {
            var ltrPolyfillValues = [...values];
            var rtlPolyfillValues = [...values];
            polyfillIndices.forEach(i => {
              var ltrVal = ltrPolyfillValues[i];
              if (typeof ltrVal === 'string') {
                var ltrPolyfill = PROPERTIES_I18N[ltrVal];
                var rtlPolyfill = PROPERTIES_FLIP[ltrPolyfill];
                ltrPolyfillValues[i] = ltrPolyfill;
                rtlPolyfillValues[i] = rtlPolyfill;
                var _ltr = atomicCompile(srcProp, srcProp, ltrPolyfillValues);
                var _rtl = atomicCompile(srcProp, srcProp, rtlPolyfillValues);
                localizeableValue = [_ltr, _rtl];
              }
            });
          }
        }
        if (localizeableValue == null) {
          localizeableValue = atomicCompile(srcProp, srcProp, value);
        } else {
          compiledStyle['$$css$localize'] = true;
        }
        compiledStyle[srcProp] = localizeableValue;
      }
    });
    return [compiledStyle, compiledRules];
  }

  /**
   * Compile simple style object to classic CSS rules.
   * No support for 'placeholderTextColor', 'scrollbarWidth', or 'pointerEvents'.
   */
  function classic(style, name) {
    var compiledStyle = {
      $$css: true
    };
    var compiledRules = [];
    var animationKeyframes = style.animationKeyframes,
      rest = (0, _objectWithoutPropertiesLoose.default)(style, _excluded);
    var identifier = createIdentifier('css', name, JSON.stringify(style));
    var selector = "." + identifier;
    var animationName;
    if (animationKeyframes != null) {
      var _processKeyframesValu = processKeyframesValue(animationKeyframes),
        animationNames = _processKeyframesValu[0],
        keyframesRules = _processKeyframesValu[1];
      animationName = animationNames.join(',');
      compiledRules.push(...keyframesRules);
    }
    var block = createDeclarationBlock((0, _objectSpread.default)((0, _objectSpread.default)({}, rest), {}, {
      animationName
    }));
    compiledRules.push("" + selector + block);
    compiledStyle[identifier] = identifier;
    return [compiledStyle, [[compiledRules, classicGroup]]];
  }

  /**
   * Compile simple style object to inline DOM styles.
   * No support for 'animationKeyframes', 'placeholderTextColor', 'scrollbarWidth', or 'pointerEvents'.
   */
  function inline(originalStyle, isRTL) {
    var style = originalStyle || emptyObject;
    var frozenProps = {};
    var nextStyle = {};
    var _loop = function _loop() {
      var originalValue = style[originalProp];
      var prop = originalProp;
      var value = originalValue;
      if (!Object.prototype.hasOwnProperty.call(style, originalProp) || originalValue == null) {
        return "continue";
      }

      // BiDi flip values
      if (PROPERTIES_VALUE.indexOf(originalProp) > -1) {
        if (originalValue === 'start') {
          value = isRTL ? 'right' : 'left';
        } else if (originalValue === 'end') {
          value = isRTL ? 'left' : 'right';
        }
      }
      // BiDi flip properties
      var propPolyfill = PROPERTIES_I18N[originalProp];
      if (propPolyfill != null) {
        prop = isRTL ? PROPERTIES_FLIP[propPolyfill] : propPolyfill;
      }
      // BiDi flip transitionProperty value
      if (originalProp === 'transitionProperty') {
        // $FlowFixMe
        var originalValues = Array.isArray(originalValue) ? originalValue : [originalValue];
        originalValues.forEach((val, i) => {
          if (typeof val === 'string') {
            var valuePolyfill = PROPERTIES_I18N[val];
            if (valuePolyfill != null) {
              originalValues[i] = isRTL ? PROPERTIES_FLIP[valuePolyfill] : valuePolyfill;
              value = originalValues.join(' ');
            }
          }
        });
      }

      // Create finalized style
      if (!frozenProps[prop]) {
        nextStyle[prop] = value;
      }
      if (prop === originalProp) {
        frozenProps[prop] = true;
      }

      //    if (PROPERTIES_I18N.hasOwnProperty(originalProp)) {
      //    frozenProps[prop] = true;
      //}
    };
    for (var originalProp in style) {
      var _ret = _loop();
      if (_ret === "continue") continue;
    }
    return (0, createReactDOMStyle.default)(nextStyle, true);
  }

  /**
   * Create a value string that normalizes different input values with a common
   * output.
   */
  function stringifyValueWithProperty(value, property) {
    // e.g., 0 => '0px', 'black' => 'rgba(0,0,0,1)'
    var normalizedValue = (0, normalizeValueWithProperty.default)(value, property);
    return typeof normalizedValue !== 'string' ? JSON.stringify(normalizedValue || '') : normalizedValue;
  }

  /**
   * Create the Atomic CSS rules needed for a given StyleSheet rule.
   * Translates StyleSheet declarations to CSS.
   */
  function createAtomicRules(identifier, property, value) {
    var rules = [];
    var selector = "." + identifier;

    // Handle non-standard properties and object values that require multiple
    // CSS rules to be created.
    switch (property) {
      case 'animationKeyframes':
        {
          var _processKeyframesValu2 = processKeyframesValue(value),
            animationNames = _processKeyframesValu2[0],
            keyframesRules = _processKeyframesValu2[1];
          var block = createDeclarationBlock({
            animationName: animationNames.join(',')
          });
          rules.push("" + selector + block, ...keyframesRules);
          break;
        }

      // Equivalent to using '::placeholder'
      case 'placeholderTextColor':
        {
          var _block = createDeclarationBlock({
            color: value,
            opacity: 1
          });
          rules.push(selector + "::-webkit-input-placeholder" + _block, selector + "::-moz-placeholder" + _block, selector + ":-ms-input-placeholder" + _block, selector + "::placeholder" + _block);
          break;
        }

      // Polyfill for additional 'pointer-events' values
      // See d13f78622b233a0afc0c7a200c0a0792c8ca9e58
      // See https://reactnative.dev/docs/view#pointerevents
      case 'pointerEvents':
        {
          var finalValue = value;
          if (value === 'auto') {
            finalValue = 'auto!important';
          } else if (value === 'none') {
            finalValue = 'none!important';
            var _block2 = createDeclarationBlock({
              pointerEvents: 'none'
            });
            rules.push(selector + " * " + _block2);
          } else if (value === 'box-none') {
            finalValue = 'none!important';
            var _block3 = createDeclarationBlock({
              pointerEvents: 'auto'
            });
            rules.push(selector + " * " + _block3);
          } else if (value === 'box-only') {
            finalValue = 'auto!important';
            var _block4 = createDeclarationBlock({
              pointerEvents: 'none'
            });
            rules.push(selector + " * " + _block4);
          }
          var _block5 = createDeclarationBlock({
            pointerEvents: finalValue
          });
          rules.push("" + selector + _block5);
          break;
        }

      // Polyfill for draft spec
      // https://drafts.csswg.org/css-scrollbars-1/
      case 'scrollbarWidth':
        {
          if (value === 'none') {
            rules.push(selector + "::-webkit-scrollbar{display:none}");
          }
          var _block6 = createDeclarationBlock({
            scrollbarWidth: value
          });
          rules.push("" + selector + _block6);
          break;
        }
      default:
        {
          var _block7 = createDeclarationBlock({
            [property]: value
          });
          rules.push("" + selector + _block7);
          break;
        }
    }
    return rules;
  }

  /**
   * Creates a CSS declaration block from a StyleSheet object.
   */
  function createDeclarationBlock(style) {
    var domStyle = (0, prefixStyles.default)((0, createReactDOMStyle.default)(style));
    var declarationsString = Object.keys(domStyle).map(property => {
      var value = domStyle[property];
      var prop = (0, hyphenateStyleName.default)(property);
      // The prefixer may return an array of values:
      // { display: [ '-webkit-flex', 'flex' ] }
      // to represent "fallback" declarations
      // { display: -webkit-flex; display: flex; }
      if (Array.isArray(value)) {
        return value.map(v => prop + ":" + v).join(';');
      } else {
        return prop + ":" + value;
      }
    })
    // Once properties are hyphenated, this will put the vendor
    // prefixed and short-form properties first in the list.
    .sort().join(';');
    return "{" + declarationsString + ";}";
  }

  /**
   * An identifier is associated with a unique set of styles.
   */
  function createIdentifier(prefix, name, key) {
    var hashedString = (0, hash.default)(name + key);
    return prefix + "-" + hashedString;
  }

  /**
   * Create individual CSS keyframes rules.
   */
  function createKeyframes(keyframes) {
    var prefixes = ['-webkit-', ''];
    var identifier = createIdentifier('r', 'animation', JSON.stringify(keyframes));
    var steps = '{' + Object.keys(keyframes).map(stepName => {
      var rule = keyframes[stepName];
      var block = createDeclarationBlock(rule);
      return "" + stepName + block;
    }).join('') + '}';
    var rules = prefixes.map(prefix => {
      return "@" + prefix + "keyframes " + identifier + steps;
    });
    return [identifier, rules];
  }

  /**
   * Create CSS keyframes rules and names from a StyleSheet keyframes object.
   */
  function processKeyframesValue(keyframesValue) {
    if (typeof keyframesValue === 'number') {
      throw new Error("Invalid CSS keyframes type: " + typeof keyframesValue);
    }
    var animationNames = [];
    var rules = [];
    var value = Array.isArray(keyframesValue) ? keyframesValue : [keyframesValue];
    value.forEach(keyframes => {
      if (typeof keyframes === 'string') {
        // Support external animation libraries (identifiers only)
        animationNames.push(keyframes);
      } else {
        // Create rules for each of the keyframes
        var _createKeyframes = createKeyframes(keyframes),
          identifier = _createKeyframes[0],
          keyframesRules = _createKeyframes[1];
        animationNames.push(identifier);
        rules.push(...keyframesRules);
      }
    });
    return [animationNames, rules];
  }
},45,[20,44,46,53,54,47,55]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _normalizeValueWithProperty = require(_dependencyMap[0]);
  var normalizeValueWithProperty = _interopDefault(_normalizeValueWithProperty);
  var _modulesCanUseDom = require(_dependencyMap[1]);
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * The browser implements the CSS cascade, where the order of properties is a
   * factor in determining which styles to paint. React Native is different. It
   * gives giving precedence to the more specific style property. For example,
   * the value of `paddingTop` takes precedence over that of `padding`.
   *
   * This module creates mutally exclusive style declarations by expanding all of
   * React Native's supported shortform properties (e.g. `padding`) to their
   * longfrom equivalents.
   */

  var emptyObject = {};
  var supportsCSS3TextDecoration = !canUseDOM.default || window.CSS != null && window.CSS.supports != null && (window.CSS.supports('text-decoration-line', 'none') || window.CSS.supports('-webkit-text-decoration-line', 'none'));
  var MONOSPACE_FONT_STACK = 'monospace,monospace';
  var SYSTEM_FONT_STACK = '-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif';
  var STYLE_SHORT_FORM_EXPANSIONS = {
    borderColor: ['borderTopColor', 'borderRightColor', 'borderBottomColor', 'borderLeftColor'],
    borderBlockColor: ['borderTopColor', 'borderBottomColor'],
    borderInlineColor: ['borderRightColor', 'borderLeftColor'],
    borderRadius: ['borderTopLeftRadius', 'borderTopRightRadius', 'borderBottomRightRadius', 'borderBottomLeftRadius'],
    borderStyle: ['borderTopStyle', 'borderRightStyle', 'borderBottomStyle', 'borderLeftStyle'],
    borderBlockStyle: ['borderTopStyle', 'borderBottomStyle'],
    borderInlineStyle: ['borderRightStyle', 'borderLeftStyle'],
    borderWidth: ['borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth'],
    borderBlockWidth: ['borderTopWidth', 'borderBottomWidth'],
    borderInlineWidth: ['borderRightWidth', 'borderLeftWidth'],
    insetBlock: ['top', 'bottom'],
    insetInline: ['left', 'right'],
    marginBlock: ['marginTop', 'marginBottom'],
    marginInline: ['marginRight', 'marginLeft'],
    paddingBlock: ['paddingTop', 'paddingBottom'],
    paddingInline: ['paddingRight', 'paddingLeft'],
    overflow: ['overflowX', 'overflowY'],
    overscrollBehavior: ['overscrollBehaviorX', 'overscrollBehaviorY'],
    borderBlockStartColor: ['borderTopColor'],
    borderBlockStartStyle: ['borderTopStyle'],
    borderBlockStartWidth: ['borderTopWidth'],
    borderBlockEndColor: ['borderBottomColor'],
    borderBlockEndStyle: ['borderBottomStyle'],
    borderBlockEndWidth: ['borderBottomWidth'],
    //borderInlineStartColor: ['borderLeftColor'],
    //borderInlineStartStyle: ['borderLeftStyle'],
    //borderInlineStartWidth: ['borderLeftWidth'],
    //borderInlineEndColor: ['borderRightColor'],
    //borderInlineEndStyle: ['borderRightStyle'],
    //borderInlineEndWidth: ['borderRightWidth'],
    borderEndStartRadius: ['borderBottomLeftRadius'],
    borderEndEndRadius: ['borderBottomRightRadius'],
    borderStartStartRadius: ['borderTopLeftRadius'],
    borderStartEndRadius: ['borderTopRightRadius'],
    insetBlockEnd: ['bottom'],
    insetBlockStart: ['top'],
    //insetInlineEnd: ['right'],
    //insetInlineStart: ['left'],
    marginBlockStart: ['marginTop'],
    marginBlockEnd: ['marginBottom'],
    //marginInlineStart: ['marginLeft'],
    //marginInlineEnd: ['marginRight'],
    paddingBlockStart: ['paddingTop'],
    paddingBlockEnd: ['paddingBottom']
    //paddingInlineStart: ['marginLeft'],
    //paddingInlineEnd: ['marginRight'],
  };

  /**
   * Reducer
   */

  var createReactDOMStyle = (style, isInline) => {
    if (!style) {
      return emptyObject;
    }
    var resolvedStyle = {};
    var _loop = function _loop() {
      var value = style[prop];
      if (
      // Ignore everything with a null value
      value == null) {
        return "continue";
      }
      if (prop === 'backgroundClip') {
        // TODO: remove once this issue is fixed
        // https://github.com/rofrischmann/inline-style-prefixer/issues/159
        if (value === 'text') {
          resolvedStyle.backgroundClip = value;
          resolvedStyle.WebkitBackgroundClip = value;
        }
      } else if (prop === 'flex') {
        if (value === -1) {
          resolvedStyle.flexGrow = 0;
          resolvedStyle.flexShrink = 1;
          resolvedStyle.flexBasis = 'auto';
        } else {
          resolvedStyle.flex = value;
        }
      } else if (prop === 'font') {
        resolvedStyle[prop] = value.replace('System', SYSTEM_FONT_STACK);
      } else if (prop === 'fontFamily') {
        if (value.indexOf('System') > -1) {
          var stack = value.split(/,\s*/);
          stack[stack.indexOf('System')] = SYSTEM_FONT_STACK;
          resolvedStyle[prop] = stack.join(',');
        } else if (value === 'monospace') {
          resolvedStyle[prop] = MONOSPACE_FONT_STACK;
        } else {
          resolvedStyle[prop] = value;
        }
      } else if (prop === 'textDecorationLine') {
        // use 'text-decoration' for browsers that only support CSS2
        // text-decoration (e.g., IE, Edge)
        if (!supportsCSS3TextDecoration) {
          resolvedStyle.textDecoration = value;
        } else {
          resolvedStyle.textDecorationLine = value;
        }
      } else if (prop === 'writingDirection') {
        resolvedStyle.direction = value;
      } else {
        var _value = (0, normalizeValueWithProperty.default)(style[prop], prop);
        var longFormProperties = STYLE_SHORT_FORM_EXPANSIONS[prop];
        if (isInline && prop === 'inset') {
          if (style.insetInline == null) {
            resolvedStyle.left = _value;
            resolvedStyle.right = _value;
          }
          if (style.insetBlock == null) {
            resolvedStyle.top = _value;
            resolvedStyle.bottom = _value;
          }
        } else if (isInline && prop === 'margin') {
          if (style.marginInline == null) {
            resolvedStyle.marginLeft = _value;
            resolvedStyle.marginRight = _value;
          }
          if (style.marginBlock == null) {
            resolvedStyle.marginTop = _value;
            resolvedStyle.marginBottom = _value;
          }
        } else if (isInline && prop === 'padding') {
          if (style.paddingInline == null) {
            resolvedStyle.paddingLeft = _value;
            resolvedStyle.paddingRight = _value;
          }
          if (style.paddingBlock == null) {
            resolvedStyle.paddingTop = _value;
            resolvedStyle.paddingBottom = _value;
          }
        } else if (longFormProperties) {
          longFormProperties.forEach((longForm, i) => {
            // The value of any longform property in the original styles takes
            // precedence over the shortform's value.
            if (style[longForm] == null) {
              resolvedStyle[longForm] = _value;
            }
          });
        } else {
          resolvedStyle[prop] = _value;
        }
      }
    };
    for (var prop in style) {
      var _ret = _loop();
      if (_ret === "continue") continue;
    }
    return resolvedStyle;
  };
  var _default = createReactDOMStyle;
},46,[47,40]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return normalizeValueWithProperty;
    }
  });
  var _unitlessNumbers = require(_dependencyMap[0]);
  var unitlessNumbers = _interopDefault(_unitlessNumbers);
  var _normalizeColor = require(_dependencyMap[1]);
  var normalizeColor = _interopDefault(_normalizeColor);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var colorProps = {
    backgroundColor: true,
    borderColor: true,
    borderTopColor: true,
    borderRightColor: true,
    borderBottomColor: true,
    borderLeftColor: true,
    color: true,
    shadowColor: true,
    textDecorationColor: true,
    textShadowColor: true
  };
  function normalizeValueWithProperty(value, property) {
    var returnValue = value;
    if ((property == null || !unitlessNumbers.default[property]) && typeof value === 'number') {
      returnValue = value + "px";
    } else if (property != null && colorProps[property]) {
      returnValue = (0, normalizeColor.default)(value);
    }
    return returnValue;
  }
},47,[48,49]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var unitlessNumbers = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexOrder: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    fontWeight: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowGap: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnGap: true,
    gridColumnStart: true,
    lineClamp: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    // SVG-related
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true,
    // transform types
    scale: true,
    scaleX: true,
    scaleY: true,
    scaleZ: true,
    // RN properties
    shadowOpacity: true
  };

  /**
   * Support style names that may come passed in prefixed by adding permutations
   * of vendor prefixes.
   */
  var prefixes = ['ms', 'Moz', 'O', 'Webkit'];
  var prefixKey = (prefix, key) => {
    return prefix + key.charAt(0).toUpperCase() + key.substring(1);
  };
  Object.keys(unitlessNumbers).forEach(prop => {
    prefixes.forEach(prefix => {
      unitlessNumbers[prefixKey(prefix, prop)] = unitlessNumbers[prop];
    });
  });
  var _default = unitlessNumbers;
},48,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _modulesIsWebColor = require(_dependencyMap[0]);
  var isWebColor = _interopDefault(_modulesIsWebColor);
  var _exportsProcessColor = require(_dependencyMap[1]);
  var processColor = _interopDefault(_exportsProcessColor);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var normalizeColor = function normalizeColor(color, opacity) {
    if (opacity === undefined) {
      opacity = 1;
    }
    if (color == null) return;
    if (typeof color === 'string' && (0, isWebColor.default)(color)) {
      return color;
    }
    var colorInt = (0, processColor.default)(color);
    if (colorInt != null) {
      var r = colorInt >> 16 & 255;
      var g = colorInt >> 8 & 255;
      var b = colorInt & 255;
      var a = (colorInt >> 24 & 255) / 255;
      var alpha = (a * opacity).toFixed(2);
      return "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
    }
  };
  var _default = normalizeColor;
},49,[50,51]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var isWebColor = color => color === 'currentcolor' || color === 'currentColor' || color === 'inherit' || color.indexOf('var(') === 0;
  var _default = isWebColor;
},50,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _reactNativeNormalizeColors = require(_dependencyMap[0]);
  var normalizeColor = _interopDefault(_reactNativeNormalizeColors);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var processColor = color => {
    if (color === undefined || color === null) {
      return color;
    }

    // convert number and hex
    var int32Color = (0, normalizeColor.default)(color);
    if (int32Color === undefined || int32Color === null) {
      return undefined;
    }
    int32Color = (int32Color << 24 | int32Color >>> 8) >>> 0;
    return int32Color;
  };
  var _default = processColor;
},51,[52]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  /* eslint no-bitwise: 0 */

  'use strict';

  function normalizeColor(color) {
    if (typeof color === 'number') {
      if (color >>> 0 === color && color >= 0 && color <= 0xffffffff) {
        return color;
      }
      return null;
    }
    if (typeof color !== 'string') {
      return null;
    }
    const matchers = getMatchers();
    let match;

    // Ordered based on occurrences on Facebook codebase
    if (match = matchers.hex6.exec(color)) {
      return parseInt(match[1] + 'ff', 16) >>> 0;
    }
    const colorFromKeyword = normalizeKeyword(color);
    if (colorFromKeyword != null) {
      return colorFromKeyword;
    }
    if (match = matchers.rgb.exec(color)) {
      return (parse255(match[1]) << 24 |
      // r
      parse255(match[2]) << 16 |
      // g
      parse255(match[3]) << 8 |
      // b
      0x000000ff) >>>
      // a
      0;
    }
    if (match = matchers.rgba.exec(color)) {
      // rgba(R G B / A) notation
      if (match[6] !== undefined) {
        return (parse255(match[6]) << 24 |
        // r
        parse255(match[7]) << 16 |
        // g
        parse255(match[8]) << 8 |
        // b
        parse1(match[9])) >>>
        // a
        0;
      }

      // rgba(R, G, B, A) notation
      return (parse255(match[2]) << 24 |
      // r
      parse255(match[3]) << 16 |
      // g
      parse255(match[4]) << 8 |
      // b
      parse1(match[5])) >>>
      // a
      0;
    }
    if (match = matchers.hex3.exec(color)) {
      return parseInt(match[1] + match[1] +
      // r
      match[2] + match[2] +
      // g
      match[3] + match[3] +
      // b
      'ff',
      // a
      16) >>> 0;
    }

    // https://drafts.csswg.org/css-color-4/#hex-notation
    if (match = matchers.hex8.exec(color)) {
      return parseInt(match[1], 16) >>> 0;
    }
    if (match = matchers.hex4.exec(color)) {
      return parseInt(match[1] + match[1] +
      // r
      match[2] + match[2] +
      // g
      match[3] + match[3] +
      // b
      match[4] + match[4],
      // a
      16) >>> 0;
    }
    if (match = matchers.hsl.exec(color)) {
      return (hslToRgb(parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3]) // l
      ) | 0x000000ff) >>>
      // a
      0;
    }
    if (match = matchers.hsla.exec(color)) {
      // hsla(H S L / A) notation
      if (match[6] !== undefined) {
        return (hslToRgb(parse360(match[6]),
        // h
        parsePercentage(match[7]),
        // s
        parsePercentage(match[8]) // l
        ) | parse1(match[9])) >>>
        // a
        0;
      }

      // hsla(H, S, L, A) notation
      return (hslToRgb(parse360(match[2]),
      // h
      parsePercentage(match[3]),
      // s
      parsePercentage(match[4]) // l
      ) | parse1(match[5])) >>>
      // a
      0;
    }
    if (match = matchers.hwb.exec(color)) {
      return (hwbToRgb(parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // w
      parsePercentage(match[3]) // b
      ) | 0x000000ff) >>>
      // a
      0;
    }
    return null;
  }
  function hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }
    if (t > 1) {
      t -= 1;
    }
    if (t < 0.16666666666666666) {
      return p + (q - p) * 6 * t;
    }
    if (t < 0.5) {
      return q;
    }
    if (t < 0.6666666666666666) {
      return p + (q - p) * (0.6666666666666666 - t) * 6;
    }
    return p;
  }
  function hslToRgb(h, s, l) {
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    const r = hue2rgb(p, q, h + 0.3333333333333333);
    const g = hue2rgb(p, q, h);
    const b = hue2rgb(p, q, h - 0.3333333333333333);
    return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
  }
  function hwbToRgb(h, w, b) {
    if (w + b >= 1) {
      const gray = Math.round(w * 255 / (w + b));
      return gray << 24 | gray << 16 | gray << 8;
    }
    const red = hue2rgb(0, 1, h + 0.3333333333333333) * (1 - w - b) + w;
    const green = hue2rgb(0, 1, h) * (1 - w - b) + w;
    const blue = hue2rgb(0, 1, h - 0.3333333333333333) * (1 - w - b) + w;
    return Math.round(red * 255) << 24 | Math.round(green * 255) << 16 | Math.round(blue * 255) << 8;
  }
  const NUMBER = '[-+]?\\d*\\.?\\d+';
  const PERCENTAGE = "[-+]?\\d*\\.?\\d+%";
  function call(...args) {
    return '\\(\\s*(' + args.join(')\\s*,?\\s*(') + ')\\s*\\)';
  }
  function callWithSlashSeparator(...args) {
    return '\\(\\s*(' + args.slice(0, args.length - 1).join(')\\s*,?\\s*(') + ')\\s*/\\s*(' + args[args.length - 1] + ')\\s*\\)';
  }
  function commaSeparatedCall(...args) {
    return '\\(\\s*(' + args.join(')\\s*,\\s*(') + ')\\s*\\)';
  }
  let cachedMatchers;
  function getMatchers() {
    if (cachedMatchers === undefined) {
      cachedMatchers = {
        rgb: new RegExp('rgb' + call(NUMBER, NUMBER, NUMBER)),
        rgba: new RegExp('rgba(' + commaSeparatedCall(NUMBER, NUMBER, NUMBER, NUMBER) + '|' + callWithSlashSeparator(NUMBER, NUMBER, NUMBER, NUMBER) + ')'),
        hsl: new RegExp('hsl' + call(NUMBER, PERCENTAGE, PERCENTAGE)),
        hsla: new RegExp('hsla(' + commaSeparatedCall(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER) + '|' + callWithSlashSeparator(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER) + ')'),
        hwb: new RegExp('hwb' + call(NUMBER, PERCENTAGE, PERCENTAGE)),
        hex3: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex4: /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#([0-9a-fA-F]{6})$/,
        hex8: /^#([0-9a-fA-F]{8})$/
      };
    }
    return cachedMatchers;
  }
  function parse255(str) {
    const int = parseInt(str, 10);
    if (int < 0) {
      return 0;
    }
    if (int > 255) {
      return 255;
    }
    return int;
  }
  function parse360(str) {
    const int = parseFloat(str);
    return (int % 360 + 360) % 360 / 360;
  }
  function parse1(str) {
    const num = parseFloat(str);
    if (num < 0) {
      return 0;
    }
    if (num > 1) {
      return 255;
    }
    return Math.round(num * 255);
  }
  function parsePercentage(str) {
    // parseFloat conveniently ignores the final %
    const int = parseFloat(str);
    if (int < 0) {
      return 0;
    }
    if (int > 100) {
      return 1;
    }
    return int / 100;
  }
  function normalizeKeyword(name) {
    // prettier-ignore
    switch (name) {
      case 'transparent':
        return 0x00000000;
      // http://www.w3.org/TR/css3-color/#svg-color
      case 'aliceblue':
        return 0xf0f8ffff;
      case 'antiquewhite':
        return 0xfaebd7ff;
      case 'aqua':
        return 0x00ffffff;
      case 'aquamarine':
        return 0x7fffd4ff;
      case 'azure':
        return 0xf0ffffff;
      case 'beige':
        return 0xf5f5dcff;
      case 'bisque':
        return 0xffe4c4ff;
      case 'black':
        return 0x000000ff;
      case 'blanchedalmond':
        return 0xffebcdff;
      case 'blue':
        return 0x0000ffff;
      case 'blueviolet':
        return 0x8a2be2ff;
      case 'brown':
        return 0xa52a2aff;
      case 'burlywood':
        return 0xdeb887ff;
      case 'burntsienna':
        return 0xea7e5dff;
      case 'cadetblue':
        return 0x5f9ea0ff;
      case 'chartreuse':
        return 0x7fff00ff;
      case 'chocolate':
        return 0xd2691eff;
      case 'coral':
        return 0xff7f50ff;
      case 'cornflowerblue':
        return 0x6495edff;
      case 'cornsilk':
        return 0xfff8dcff;
      case 'crimson':
        return 0xdc143cff;
      case 'cyan':
        return 0x00ffffff;
      case 'darkblue':
        return 0x00008bff;
      case 'darkcyan':
        return 0x008b8bff;
      case 'darkgoldenrod':
        return 0xb8860bff;
      case 'darkgray':
        return 0xa9a9a9ff;
      case 'darkgreen':
        return 0x006400ff;
      case 'darkgrey':
        return 0xa9a9a9ff;
      case 'darkkhaki':
        return 0xbdb76bff;
      case 'darkmagenta':
        return 0x8b008bff;
      case 'darkolivegreen':
        return 0x556b2fff;
      case 'darkorange':
        return 0xff8c00ff;
      case 'darkorchid':
        return 0x9932ccff;
      case 'darkred':
        return 0x8b0000ff;
      case 'darksalmon':
        return 0xe9967aff;
      case 'darkseagreen':
        return 0x8fbc8fff;
      case 'darkslateblue':
        return 0x483d8bff;
      case 'darkslategray':
        return 0x2f4f4fff;
      case 'darkslategrey':
        return 0x2f4f4fff;
      case 'darkturquoise':
        return 0x00ced1ff;
      case 'darkviolet':
        return 0x9400d3ff;
      case 'deeppink':
        return 0xff1493ff;
      case 'deepskyblue':
        return 0x00bfffff;
      case 'dimgray':
        return 0x696969ff;
      case 'dimgrey':
        return 0x696969ff;
      case 'dodgerblue':
        return 0x1e90ffff;
      case 'firebrick':
        return 0xb22222ff;
      case 'floralwhite':
        return 0xfffaf0ff;
      case 'forestgreen':
        return 0x228b22ff;
      case 'fuchsia':
        return 0xff00ffff;
      case 'gainsboro':
        return 0xdcdcdcff;
      case 'ghostwhite':
        return 0xf8f8ffff;
      case 'gold':
        return 0xffd700ff;
      case 'goldenrod':
        return 0xdaa520ff;
      case 'gray':
        return 0x808080ff;
      case 'green':
        return 0x008000ff;
      case 'greenyellow':
        return 0xadff2fff;
      case 'grey':
        return 0x808080ff;
      case 'honeydew':
        return 0xf0fff0ff;
      case 'hotpink':
        return 0xff69b4ff;
      case 'indianred':
        return 0xcd5c5cff;
      case 'indigo':
        return 0x4b0082ff;
      case 'ivory':
        return 0xfffff0ff;
      case 'khaki':
        return 0xf0e68cff;
      case 'lavender':
        return 0xe6e6faff;
      case 'lavenderblush':
        return 0xfff0f5ff;
      case 'lawngreen':
        return 0x7cfc00ff;
      case 'lemonchiffon':
        return 0xfffacdff;
      case 'lightblue':
        return 0xadd8e6ff;
      case 'lightcoral':
        return 0xf08080ff;
      case 'lightcyan':
        return 0xe0ffffff;
      case 'lightgoldenrodyellow':
        return 0xfafad2ff;
      case 'lightgray':
        return 0xd3d3d3ff;
      case 'lightgreen':
        return 0x90ee90ff;
      case 'lightgrey':
        return 0xd3d3d3ff;
      case 'lightpink':
        return 0xffb6c1ff;
      case 'lightsalmon':
        return 0xffa07aff;
      case 'lightseagreen':
        return 0x20b2aaff;
      case 'lightskyblue':
        return 0x87cefaff;
      case 'lightslategray':
        return 0x778899ff;
      case 'lightslategrey':
        return 0x778899ff;
      case 'lightsteelblue':
        return 0xb0c4deff;
      case 'lightyellow':
        return 0xffffe0ff;
      case 'lime':
        return 0x00ff00ff;
      case 'limegreen':
        return 0x32cd32ff;
      case 'linen':
        return 0xfaf0e6ff;
      case 'magenta':
        return 0xff00ffff;
      case 'maroon':
        return 0x800000ff;
      case 'mediumaquamarine':
        return 0x66cdaaff;
      case 'mediumblue':
        return 0x0000cdff;
      case 'mediumorchid':
        return 0xba55d3ff;
      case 'mediumpurple':
        return 0x9370dbff;
      case 'mediumseagreen':
        return 0x3cb371ff;
      case 'mediumslateblue':
        return 0x7b68eeff;
      case 'mediumspringgreen':
        return 0x00fa9aff;
      case 'mediumturquoise':
        return 0x48d1ccff;
      case 'mediumvioletred':
        return 0xc71585ff;
      case 'midnightblue':
        return 0x191970ff;
      case 'mintcream':
        return 0xf5fffaff;
      case 'mistyrose':
        return 0xffe4e1ff;
      case 'moccasin':
        return 0xffe4b5ff;
      case 'navajowhite':
        return 0xffdeadff;
      case 'navy':
        return 0x000080ff;
      case 'oldlace':
        return 0xfdf5e6ff;
      case 'olive':
        return 0x808000ff;
      case 'olivedrab':
        return 0x6b8e23ff;
      case 'orange':
        return 0xffa500ff;
      case 'orangered':
        return 0xff4500ff;
      case 'orchid':
        return 0xda70d6ff;
      case 'palegoldenrod':
        return 0xeee8aaff;
      case 'palegreen':
        return 0x98fb98ff;
      case 'paleturquoise':
        return 0xafeeeeff;
      case 'palevioletred':
        return 0xdb7093ff;
      case 'papayawhip':
        return 0xffefd5ff;
      case 'peachpuff':
        return 0xffdab9ff;
      case 'peru':
        return 0xcd853fff;
      case 'pink':
        return 0xffc0cbff;
      case 'plum':
        return 0xdda0ddff;
      case 'powderblue':
        return 0xb0e0e6ff;
      case 'purple':
        return 0x800080ff;
      case 'rebeccapurple':
        return 0x663399ff;
      case 'red':
        return 0xff0000ff;
      case 'rosybrown':
        return 0xbc8f8fff;
      case 'royalblue':
        return 0x4169e1ff;
      case 'saddlebrown':
        return 0x8b4513ff;
      case 'salmon':
        return 0xfa8072ff;
      case 'sandybrown':
        return 0xf4a460ff;
      case 'seagreen':
        return 0x2e8b57ff;
      case 'seashell':
        return 0xfff5eeff;
      case 'sienna':
        return 0xa0522dff;
      case 'silver':
        return 0xc0c0c0ff;
      case 'skyblue':
        return 0x87ceebff;
      case 'slateblue':
        return 0x6a5acdff;
      case 'slategray':
        return 0x708090ff;
      case 'slategrey':
        return 0x708090ff;
      case 'snow':
        return 0xfffafaff;
      case 'springgreen':
        return 0x00ff7fff;
      case 'steelblue':
        return 0x4682b4ff;
      case 'tan':
        return 0xd2b48cff;
      case 'teal':
        return 0x008080ff;
      case 'thistle':
        return 0xd8bfd8ff;
      case 'tomato':
        return 0xff6347ff;
      case 'turquoise':
        return 0x40e0d0ff;
      case 'violet':
        return 0xee82eeff;
      case 'wheat':
        return 0xf5deb3ff;
      case 'white':
        return 0xffffffff;
      case 'whitesmoke':
        return 0xf5f5f5ff;
      case 'yellow':
        return 0xffff00ff;
      case 'yellowgreen':
        return 0x9acd32ff;
    }
    return null;
  }
  module.exports = normalizeColor;
},52,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /* eslint-disable */

  /**
   * JS Implementation of MurmurHash2
   *
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/murmurhash-js
   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
   * @see http://sites.google.com/site/murmurhash/
   *
   * @param {string} str ASCII only
   * @param {number} seed Positive integer only
   * @return {number} 32-bit positive integer hash
   *
   * 
   */

  function murmurhash2_32_gc(str, seed) {
    var l = str.length,
      h = seed ^ l,
      i = 0,
      k;
    while (l >= 4) {
      k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
      k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
      k ^= k >>> 24;
      k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
      h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16) ^ k;
      l -= 4;
      ++i;
    }
    switch (l) {
      case 3:
        h ^= (str.charCodeAt(i + 2) & 0xff) << 16;
      case 2:
        h ^= (str.charCodeAt(i + 1) & 0xff) << 8;
      case 1:
        h ^= str.charCodeAt(i) & 0xff;
        h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
    }
    h ^= h >>> 13;
    h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
    h ^= h >>> 15;
    return h >>> 0;
  }
  var hash = str => murmurhash2_32_gc(str, 1).toString(36);
  var _default = hash;
},53,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var uppercasePattern = /[A-Z]/g;
  var msPattern = /^ms-/;
  var cache = {};
  function toHyphenLower(match) {
    return '-' + match.toLowerCase();
  }
  function hyphenateStyleName(name) {
    if (name in cache) {
      return cache[name];
    }
    var hName = name.replace(uppercasePattern, toHyphenLower);
    return cache[name] = msPattern.test(hName) ? '-' + hName : hName;
  }
  var _default = hyphenateStyleName;
},54,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _inlineStylePrefixerLibCreatePrefixer = require(_dependencyMap[0]);
  var createPrefixer = _interopDefault(_inlineStylePrefixerLibCreatePrefixer);
  var _static = require(_dependencyMap[1]);
  var staticData = _interopDefault(_static);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var prefixAll = (0, createPrefixer.default)(staticData.default);
  var _default = prefixAll;
},55,[56,62]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = createPrefixer;
  var _prefixProperty = require(_dependencyMap[0]);
  var _prefixProperty2 = _interopRequireDefault(_prefixProperty);
  var _prefixValue = require(_dependencyMap[1]);
  var _prefixValue2 = _interopRequireDefault(_prefixValue);
  var _addNewValuesOnly = require(_dependencyMap[2]);
  var _addNewValuesOnly2 = _interopRequireDefault(_addNewValuesOnly);
  var _isObject = require(_dependencyMap[3]);
  var _isObject2 = _interopRequireDefault(_isObject);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function createPrefixer(_ref) {
    var prefixMap = _ref.prefixMap,
      plugins = _ref.plugins;
    return function prefix(style) {
      for (var property in style) {
        var value = style[property];

        // handle nested objects
        if ((0, _isObject2.default)(value)) {
          style[property] = prefix(value);
          // handle array values
        } else if (Array.isArray(value)) {
          var combinedValue = [];
          for (var i = 0, len = value.length; i < len; ++i) {
            var processedValue = (0, _prefixValue2.default)(plugins, property, value[i], style, prefixMap);
            (0, _addNewValuesOnly2.default)(combinedValue, processedValue || value[i]);
          }

          // only modify the value if it was touched
          // by any plugin to prevent unnecessary mutations
          if (combinedValue.length > 0) {
            style[property] = combinedValue;
          }
        } else {
          var _processedValue = (0, _prefixValue2.default)(plugins, property, value, style, prefixMap);

          // only modify the value if it was touched
          // by any plugin to prevent unnecessary mutations
          if (_processedValue) {
            style[property] = _processedValue;
          }
          style = (0, _prefixProperty2.default)(prefixMap, property, style);
        }
      }
      return style;
    };
  }
},56,[57,59,60,61]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = prefixProperty;
  var _capitalizeString = require(_dependencyMap[0]);
  var _capitalizeString2 = _interopRequireDefault(_capitalizeString);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  function prefixProperty(prefixProperties, property, style) {
    var requiredPrefixes = prefixProperties[property];
    if (requiredPrefixes && style.hasOwnProperty(property)) {
      var capitalizedProperty = (0, _capitalizeString2.default)(property);
      for (var i = 0; i < requiredPrefixes.length; ++i) {
        var prefixedProperty = requiredPrefixes[i] + capitalizedProperty;
        if (!style[prefixedProperty]) {
          style[prefixedProperty] = style[property];
        }
      }
    }
    return style;
  }
},57,[58]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = capitalizeString;
  function capitalizeString(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
},58,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = prefixValue;
  function prefixValue(plugins, property, value, style, metaData) {
    for (var i = 0, len = plugins.length; i < len; ++i) {
      var processedValue = plugins[i](property, value, style, metaData);

      // we can stop processing if a value is returned
      // as all plugin criteria are unique
      if (processedValue) {
        return processedValue;
      }
    }
  }
},59,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addNewValuesOnly;
  function addIfNew(list, value) {
    if (list.indexOf(value) === -1) {
      list.push(value);
    }
  }
  function addNewValuesOnly(list, values) {
    if (Array.isArray(values)) {
      for (var i = 0, len = values.length; i < len; ++i) {
        addIfNew(list, values[i]);
      }
    } else {
      addIfNew(list, values);
    }
  }
},60,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isObject;
  function isObject(value) {
    return value instanceof Object && !Array.isArray(value);
  }
},61,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _inlineStylePrefixerLibPluginsCrossFade = require(_dependencyMap[0]);
  var crossFade = _interopDefault(_inlineStylePrefixerLibPluginsCrossFade);
  var _inlineStylePrefixerLibPluginsImageSet = require(_dependencyMap[1]);
  var imageSet = _interopDefault(_inlineStylePrefixerLibPluginsImageSet);
  var _inlineStylePrefixerLibPluginsLogical = require(_dependencyMap[2]);
  var logical = _interopDefault(_inlineStylePrefixerLibPluginsLogical);
  var _inlineStylePrefixerLibPluginsPosition = require(_dependencyMap[3]);
  var position = _interopDefault(_inlineStylePrefixerLibPluginsPosition);
  var _inlineStylePrefixerLibPluginsSizing = require(_dependencyMap[4]);
  var sizing = _interopDefault(_inlineStylePrefixerLibPluginsSizing);
  var _inlineStylePrefixerLibPluginsTransition = require(_dependencyMap[5]);
  var transition = _interopDefault(_inlineStylePrefixerLibPluginsTransition);
  var w = ['Webkit'];
  var m = ['Moz'];
  var wm = ['Webkit', 'Moz'];
  var wms = ['Webkit', 'ms'];
  var wmms = ['Webkit', 'Moz', 'ms'];
  var _default = {
    plugins: [crossFade.default, imageSet.default, logical.default, position.default, sizing.default, transition.default],
    prefixMap: {
      appearance: wmms,
      userSelect: wm,
      textEmphasisPosition: wms,
      textEmphasis: wms,
      textEmphasisStyle: wms,
      textEmphasisColor: wms,
      boxDecorationBreak: wms,
      clipPath: w,
      maskImage: wms,
      maskMode: wms,
      maskRepeat: wms,
      maskPosition: wms,
      maskClip: wms,
      maskOrigin: wms,
      maskSize: wms,
      maskComposite: wms,
      mask: wms,
      maskBorderSource: wms,
      maskBorderMode: wms,
      maskBorderSlice: wms,
      maskBorderWidth: wms,
      maskBorderOutset: wms,
      maskBorderRepeat: wms,
      maskBorder: wms,
      maskType: wms,
      textDecorationStyle: w,
      textDecorationSkip: w,
      textDecorationLine: w,
      textDecorationColor: w,
      filter: w,
      breakAfter: w,
      breakBefore: w,
      breakInside: w,
      columnCount: w,
      columnFill: w,
      columnGap: w,
      columnRule: w,
      columnRuleColor: w,
      columnRuleStyle: w,
      columnRuleWidth: w,
      columns: w,
      columnSpan: w,
      columnWidth: w,
      backdropFilter: w,
      hyphens: w,
      flowInto: w,
      flowFrom: w,
      regionFragment: w,
      textOrientation: w,
      tabSize: m,
      fontKerning: w,
      textSizeAdjust: w
    }
  };
},62,[63,78,80,81,82,83]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = crossFade;
  var _cssInJsUtils = require(_dependencyMap[0]);
  var CROSS_FADE_REGEX = /cross-fade\(/g;
  // http://caniuse.com/#search=cross-fade
  var prefixes = ['-webkit-', ''];
  function crossFade(property, value) {
    if (typeof value === 'string' && !(0, _cssInJsUtils.isPrefixedValue)(value) && value.indexOf('cross-fade(') !== -1) {
      return prefixes.map(function (prefix) {
        return value.replace(CROSS_FADE_REGEX, prefix + 'cross-fade(');
      });
    }
  }
},63,[64]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "assignStyle", {
    enumerable: true,
    get: function () {
      return assignStyle.default;
    }
  });
  Object.defineProperty(exports, "camelCaseProperty", {
    enumerable: true,
    get: function () {
      return camelCaseProperty.default;
    }
  });
  Object.defineProperty(exports, "cssifyDeclaration", {
    enumerable: true,
    get: function () {
      return cssifyDeclaration.default;
    }
  });
  Object.defineProperty(exports, "cssifyObject", {
    enumerable: true,
    get: function () {
      return cssifyObject.default;
    }
  });
  Object.defineProperty(exports, "hyphenateProperty", {
    enumerable: true,
    get: function () {
      return hyphenateProperty.default;
    }
  });
  Object.defineProperty(exports, "isPrefixedProperty", {
    enumerable: true,
    get: function () {
      return isPrefixedProperty.default;
    }
  });
  Object.defineProperty(exports, "isPrefixedValue", {
    enumerable: true,
    get: function () {
      return isPrefixedValue.default;
    }
  });
  Object.defineProperty(exports, "isUnitlessProperty", {
    enumerable: true,
    get: function () {
      return isUnitlessProperty.default;
    }
  });
  Object.defineProperty(exports, "normalizeProperty", {
    enumerable: true,
    get: function () {
      return normalizeProperty.default;
    }
  });
  Object.defineProperty(exports, "resolveArrayValue", {
    enumerable: true,
    get: function () {
      return resolveArrayValue.default;
    }
  });
  Object.defineProperty(exports, "unprefixProperty", {
    enumerable: true,
    get: function () {
      return unprefixProperty.default;
    }
  });
  Object.defineProperty(exports, "unprefixValue", {
    enumerable: true,
    get: function () {
      return unprefixValue.default;
    }
  });
  var _assignStyle = require(_dependencyMap[0]);
  var assignStyle = _interopDefault(_assignStyle);
  var _camelCaseProperty = require(_dependencyMap[1]);
  var camelCaseProperty = _interopDefault(_camelCaseProperty);
  var _cssifyDeclaration = require(_dependencyMap[2]);
  var cssifyDeclaration = _interopDefault(_cssifyDeclaration);
  var _cssifyObject = require(_dependencyMap[3]);
  var cssifyObject = _interopDefault(_cssifyObject);
  var _hyphenateProperty = require(_dependencyMap[4]);
  var hyphenateProperty = _interopDefault(_hyphenateProperty);
  var _isPrefixedProperty = require(_dependencyMap[5]);
  var isPrefixedProperty = _interopDefault(_isPrefixedProperty);
  var _isPrefixedValue = require(_dependencyMap[6]);
  var isPrefixedValue = _interopDefault(_isPrefixedValue);
  var _isUnitlessProperty = require(_dependencyMap[7]);
  var isUnitlessProperty = _interopDefault(_isUnitlessProperty);
  var _normalizeProperty = require(_dependencyMap[8]);
  var normalizeProperty = _interopDefault(_normalizeProperty);
  var _resolveArrayValue = require(_dependencyMap[9]);
  var resolveArrayValue = _interopDefault(_resolveArrayValue);
  var _unprefixProperty = require(_dependencyMap[10]);
  var unprefixProperty = _interopDefault(_unprefixProperty);
  var _unprefixValue = require(_dependencyMap[11]);
  var unprefixValue = _interopDefault(_unprefixValue);
},64,[65,66,67,70,68,71,72,73,74,76,75,77]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return assignStyle;
    }
  });
  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }
    return _typeof(obj);
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function filterUniqueArray(arr) {
    return arr.filter(function (val, index) {
      return arr.lastIndexOf(val) === index;
    });
  }
  function assignStyle(base) {
    for (var i = 0, len = arguments.length <= 1 ? 0 : arguments.length - 1; i < len; ++i) {
      var style = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];
      for (var property in style) {
        var value = style[property];
        var baseValue = base[property];
        if (baseValue && value) {
          if (Array.isArray(baseValue)) {
            base[property] = filterUniqueArray(baseValue.concat(value));
            continue;
          }
          if (Array.isArray(value)) {
            base[property] = filterUniqueArray([baseValue].concat(_toConsumableArray(value)));
            continue;
          }
          if (_typeof(value) === 'object') {
            base[property] = assignStyle({}, baseValue, value);
            continue;
          }
        }
        base[property] = value;
      }
    }
    return base;
  }
},65,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return camelCaseProperty;
    }
  });
  var DASH = /-([a-z])/g;
  var MS = /^Ms/g;
  var cache = {};
  function toUpper(match) {
    return match[1].toUpperCase();
  }
  function camelCaseProperty(property) {
    if (cache.hasOwnProperty(property)) {
      return cache[property];
    }
    var camelProp = property.replace(DASH, toUpper).replace(MS, 'ms');
    cache[property] = camelProp;
    return camelProp;
  }
},66,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return cssifyDeclaration;
    }
  });
  var _hyphenateProperty = require(_dependencyMap[0]);
  var hyphenateProperty = _interopDefault(_hyphenateProperty);
  function cssifyDeclaration(property, value) {
    return (0, hyphenateProperty.default)(property) + ':' + value;
  }
},67,[68]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return hyphenateProperty;
    }
  });
  var _hyphenateStyleName = require(_dependencyMap[0]);
  var hyphenateStyleName = _interopDefault(_hyphenateStyleName);
  function hyphenateProperty(property) {
    return (0, hyphenateStyleName.default)(property);
  }
},68,[69]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /* eslint-disable no-var, prefer-template */
  var uppercasePattern = /[A-Z]/g;
  var msPattern = /^ms-/;
  var cache = {};
  function toHyphenLower(match) {
    return '-' + match.toLowerCase();
  }
  function hyphenateStyleName(name) {
    if (cache.hasOwnProperty(name)) {
      return cache[name];
    }
    var hName = name.replace(uppercasePattern, toHyphenLower);
    return cache[name] = msPattern.test(hName) ? '-' + hName : hName;
  }
  var _default = hyphenateStyleName;
},69,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return cssifyObject;
    }
  });
  var _cssifyDeclaration = require(_dependencyMap[0]);
  var cssifyDeclaration = _interopDefault(_cssifyDeclaration);
  function cssifyObject(style) {
    var css = '';
    for (var property in style) {
      var value = style[property];
      if (typeof value !== 'string' && typeof value !== 'number') {
        continue;
      } // prevents the semicolon after
      // the last rule declaration

      if (css) {
        css += ';';
      }
      css += (0, cssifyDeclaration.default)(property, value);
    }
    return css;
  }
},70,[67]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return isPrefixedProperty;
    }
  });
  var RE = /^(Webkit|Moz|O|ms)/;
  function isPrefixedProperty(property) {
    return RE.test(property);
  }
},71,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return isPrefixedValue;
    }
  });
  var RE = /-webkit-|-moz-|-ms-/;
  function isPrefixedValue(value) {
    return typeof value === 'string' && RE.test(value);
  }
},72,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return isUnitlessProperty;
    }
  });
  var _hyphenateProperty = require(_dependencyMap[0]);
  var hyphenateProperty = _interopDefault(_hyphenateProperty);
  var unitlessProperties = {
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    fontWeight: true,
    lineHeight: true,
    opacity: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    // SVG-related properties
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  var prefixedUnitlessProperties = ['animationIterationCount', 'boxFlex', 'boxFlexGroup', 'boxOrdinalGroup', 'columnCount', 'flex', 'flexGrow', 'flexPositive', 'flexShrink', 'flexNegative', 'flexOrder', 'gridColumn', 'gridColumnEnd', 'gridColumnStart', 'gridRow', 'gridRowEnd', 'gridRowStart', 'lineClamp', 'order'];
  var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
  function getPrefixedProperty(prefix, property) {
    return prefix + property.charAt(0).toUpperCase() + property.slice(1);
  } // add all prefixed properties to the unitless properties

  for (var i = 0, len = prefixedUnitlessProperties.length; i < len; ++i) {
    var property = prefixedUnitlessProperties[i];
    unitlessProperties[property] = true;
    for (var j = 0, jLen = prefixes.length; j < jLen; ++j) {
      unitlessProperties[getPrefixedProperty(prefixes[j], property)] = true;
    }
  } // add all hypenated properties as well

  for (var _property in unitlessProperties) {
    unitlessProperties[(0, hyphenateProperty.default)(_property)] = true;
  }
  function isUnitlessProperty(property) {
    return unitlessProperties.hasOwnProperty(property);
  }
},73,[68]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return normalizeProperty;
    }
  });
  var _camelCaseProperty = require(_dependencyMap[0]);
  var camelCaseProperty = _interopDefault(_camelCaseProperty);
  var _unprefixProperty = require(_dependencyMap[1]);
  var unprefixProperty = _interopDefault(_unprefixProperty);
  function normalizeProperty(property) {
    return (0, unprefixProperty.default)((0, camelCaseProperty.default)(property));
  }
},74,[66,75]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return unprefixProperty;
    }
  });
  var RE = /^(ms|Webkit|Moz|O)/;
  function unprefixProperty(property) {
    var propertyWithoutPrefix = property.replace(RE, '');
    return propertyWithoutPrefix.charAt(0).toLowerCase() + propertyWithoutPrefix.slice(1);
  }
},75,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return resolveArrayValue;
    }
  });
  var _hyphenateProperty = require(_dependencyMap[0]);
  var hyphenateProperty = _interopDefault(_hyphenateProperty);
  function resolveArrayValue(property, value) {
    return value.join(';' + (0, hyphenateProperty.default)(property) + ':');
  }
},76,[68]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return unprefixValue;
    }
  });
  var RE = /(-ms-|-webkit-|-moz-|-o-)/g;
  function unprefixValue(value) {
    if (typeof value === 'string') {
      return value.replace(RE, '');
    }
    return value;
  }
},77,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = imageSet;
  var _isPrefixedValue = require(_dependencyMap[0]);
  var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  // http://caniuse.com/#feat=css-image-set
  var prefixes = ['-webkit-', ''];
  function imageSet(property, value) {
    if (typeof value === 'string' && !(0, _isPrefixedValue2.default)(value) && value.indexOf('image-set(') > -1) {
      return prefixes.map(function (prefix) {
        return value.replace(/image-set\(/g, prefix + 'image-set(');
      });
    }
  }
},78,[79]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = isPrefixedValue;
  var RE = /-webkit-|-moz-|-ms-/;
  function isPrefixedValue(value) {
    return typeof value === 'string' && RE.test(value);
  }
},79,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = logical;
  var alternativeProps = {
    marginBlockStart: ['WebkitMarginBefore'],
    marginBlockEnd: ['WebkitMarginAfter'],
    marginInlineStart: ['WebkitMarginStart', 'MozMarginStart'],
    marginInlineEnd: ['WebkitMarginEnd', 'MozMarginEnd'],
    paddingBlockStart: ['WebkitPaddingBefore'],
    paddingBlockEnd: ['WebkitPaddingAfter'],
    paddingInlineStart: ['WebkitPaddingStart', 'MozPaddingStart'],
    paddingInlineEnd: ['WebkitPaddingEnd', 'MozPaddingEnd'],
    borderBlockStart: ['WebkitBorderBefore'],
    borderBlockStartColor: ['WebkitBorderBeforeColor'],
    borderBlockStartStyle: ['WebkitBorderBeforeStyle'],
    borderBlockStartWidth: ['WebkitBorderBeforeWidth'],
    borderBlockEnd: ['WebkitBorderAfter'],
    borderBlockEndColor: ['WebkitBorderAfterColor'],
    borderBlockEndStyle: ['WebkitBorderAfterStyle'],
    borderBlockEndWidth: ['WebkitBorderAfterWidth'],
    borderInlineStart: ['WebkitBorderStart', 'MozBorderStart'],
    borderInlineStartColor: ['WebkitBorderStartColor', 'MozBorderStartColor'],
    borderInlineStartStyle: ['WebkitBorderStartStyle', 'MozBorderStartStyle'],
    borderInlineStartWidth: ['WebkitBorderStartWidth', 'MozBorderStartWidth'],
    borderInlineEnd: ['WebkitBorderEnd', 'MozBorderEnd'],
    borderInlineEndColor: ['WebkitBorderEndColor', 'MozBorderEndColor'],
    borderInlineEndStyle: ['WebkitBorderEndStyle', 'MozBorderEndStyle'],
    borderInlineEndWidth: ['WebkitBorderEndWidth', 'MozBorderEndWidth']
  };
  function logical(property, value, style) {
    if (Object.prototype.hasOwnProperty.call(alternativeProps, property)) {
      var alternativePropList = alternativeProps[property];
      for (var i = 0, len = alternativePropList.length; i < len; ++i) {
        style[alternativePropList[i]] = value;
      }
    }
  }
},80,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = position;
  function position(property, value) {
    if (property === 'position' && value === 'sticky') {
      return ['-webkit-sticky', 'sticky'];
    }
  }
},81,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = sizing;
  var prefixes = ['-webkit-', '-moz-', ''];
  var properties = {
    maxHeight: true,
    maxWidth: true,
    width: true,
    height: true,
    columnWidth: true,
    minWidth: true,
    minHeight: true
  };
  var values = {
    'min-content': true,
    'max-content': true,
    'fill-available': true,
    'fit-content': true,
    'contain-floats': true
  };
  function sizing(property, value) {
    if (properties.hasOwnProperty(property) && values.hasOwnProperty(value)) {
      return prefixes.map(function (prefix) {
        return prefix + value;
      });
    }
  }
},82,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = transition;
  var _hyphenateProperty = require(_dependencyMap[0]);
  var _hyphenateProperty2 = _interopRequireDefault(_hyphenateProperty);
  var _isPrefixedValue = require(_dependencyMap[1]);
  var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
  var _capitalizeString = require(_dependencyMap[2]);
  var _capitalizeString2 = _interopRequireDefault(_capitalizeString);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }
  var properties = {
    transition: true,
    transitionProperty: true,
    WebkitTransition: true,
    WebkitTransitionProperty: true,
    MozTransition: true,
    MozTransitionProperty: true
  };
  var prefixMapping = {
    Webkit: '-webkit-',
    Moz: '-moz-',
    ms: '-ms-'
  };
  function prefixValue(value, propertyPrefixMap) {
    if ((0, _isPrefixedValue2.default)(value)) {
      return value;
    }

    // only split multi values, not cubic beziers
    var multipleValues = value.split(/,(?![^()]*(?:\([^()]*\))?\))/g);
    for (var i = 0, len = multipleValues.length; i < len; ++i) {
      var singleValue = multipleValues[i];
      var values = [singleValue];
      for (var property in propertyPrefixMap) {
        var dashCaseProperty = (0, _hyphenateProperty2.default)(property);
        if (singleValue.indexOf(dashCaseProperty) > -1 && dashCaseProperty !== 'order') {
          var prefixes = propertyPrefixMap[property];
          for (var j = 0, pLen = prefixes.length; j < pLen; ++j) {
            // join all prefixes and create a new value
            values.unshift(singleValue.replace(dashCaseProperty, prefixMapping[prefixes[j]] + dashCaseProperty));
          }
        }
      }
      multipleValues[i] = values.join(',');
    }
    return multipleValues.join(',');
  }
  function transition(property, value, style, propertyPrefixMap) {
    // also check for already prefixed transitions
    if (typeof value === 'string' && properties.hasOwnProperty(property)) {
      var outputValue = prefixValue(value, propertyPrefixMap);
      // if the property is already prefixed
      var webkitOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function (val) {
        return !/-moz-|-ms-/.test(val);
      }).join(',');
      if (property.indexOf('Webkit') > -1) {
        return webkitOutput;
      }
      var mozOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function (val) {
        return !/-webkit-|-ms-/.test(val);
      }).join(',');
      if (property.indexOf('Moz') > -1) {
        return mozOutput;
      }
      style['Webkit' + (0, _capitalizeString2.default)(property)] = webkitOutput;
      style['Moz' + (0, _capitalizeString2.default)(property)] = mozOutput;
      return outputValue;
    }
  }
},83,[84,79,58]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = hyphenateProperty;
  var _hyphenateStyleName = require(_dependencyMap[0]);
  var _hyphenateStyleName2 = _interopRequireDefault(_hyphenateStyleName);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  function hyphenateProperty(property) {
    return (0, _hyphenateStyleName2["default"])(property);
  }
},84,[69]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  module.exports = require(_dependencyMap[0]);
},85,[86]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.localizeStyle = localizeStyle;
  var cache = new WeakMap();
  var markerProp = '$$css$localize';
  /**
   * The compiler polyfills logical properties and values, generating a class
   * name for both writing directions. The style objects are annotated by
   * the compiler as needing this runtime transform. The results are memoized.
   *
   * { '$$css$localize': true, float: [ 'float-left', 'float-right' ] }
   * => { float: 'float-left' }
   */

  function compileStyle(style, isRTL) {
    // Create a new compiled style for styleq
    var compiledStyle = {};
    for (var prop in style) {
      if (prop !== markerProp) {
        var value = style[prop];
        if (Array.isArray(value)) {
          compiledStyle[prop] = isRTL ? value[1] : value[0];
        } else {
          compiledStyle[prop] = value;
        }
      }
    }
    return compiledStyle;
  }
  function localizeStyle(style, isRTL) {
    if (style[markerProp] != null) {
      var compiledStyleIndex = isRTL ? 1 : 0; // Check the cache in case we've already seen this object

      if (cache.has(style)) {
        var _cachedStyles = cache.get(style);
        var _compiledStyle = _cachedStyles[compiledStyleIndex];
        if (_compiledStyle == null) {
          // Update the missing cache entry
          _compiledStyle = compileStyle(style, isRTL);
          _cachedStyles[compiledStyleIndex] = _compiledStyle;
          cache.set(style, _cachedStyles);
        }
        return _compiledStyle;
      } // Create a new compiled style for styleq

      var compiledStyle = compileStyle(style, isRTL);
      var cachedStyles = new Array(2);
      cachedStyles[compiledStyleIndex] = compiledStyle;
      cache.set(style, cachedStyles);
      return compiledStyle;
    }
    return style;
  }
},86,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  Object.defineProperty(exports, "createBoxShadowValue", {
    enumerable: true,
    get: function () {
      return createBoxShadowValue;
    }
  });
  Object.defineProperty(exports, "createTextShadowValue", {
    enumerable: true,
    get: function () {
      return createTextShadowValue;
    }
  });
  Object.defineProperty(exports, "createBoxShadowArrayValue", {
    enumerable: true,
    get: function () {
      return createBoxShadowArrayValue;
    }
  });
  Object.defineProperty(exports, "createTransformValue", {
    enumerable: true,
    get: function () {
      return createTransformValue;
    }
  });
  Object.defineProperty(exports, "createTransformOriginValue", {
    enumerable: true,
    get: function () {
      return createTransformOriginValue;
    }
  });
  Object.defineProperty(exports, "preprocess", {
    enumerable: true,
    get: function () {
      return preprocess;
    }
  });
  var _compilerNormalizeColor = require(_dependencyMap[0]);
  var normalizeColor = _interopDefault(_compilerNormalizeColor);
  var _compilerNormalizeValueWithProperty = require(_dependencyMap[1]);
  var normalizeValueWithProperty = _interopDefault(_compilerNormalizeValueWithProperty);
  var _modulesWarnOnce = require(_dependencyMap[2]);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var emptyObject = {};

  /**
   * Shadows
   */

  var defaultOffset = {
    height: 0,
    width: 0
  };
  var createBoxShadowValue = style => {
    var shadowColor = style.shadowColor,
      shadowOffset = style.shadowOffset,
      shadowOpacity = style.shadowOpacity,
      shadowRadius = style.shadowRadius;
    var _ref = shadowOffset || defaultOffset,
      height = _ref.height,
      width = _ref.width;
    var offsetX = (0, normalizeValueWithProperty.default)(width);
    var offsetY = (0, normalizeValueWithProperty.default)(height);
    var blurRadius = (0, normalizeValueWithProperty.default)(shadowRadius || 0);
    var color = (0, normalizeColor.default)(shadowColor || 'black', shadowOpacity);
    if (color != null && offsetX != null && offsetY != null && blurRadius != null) {
      return offsetX + " " + offsetY + " " + blurRadius + " " + color;
    }
  };
  var createTextShadowValue = style => {
    var textShadowColor = style.textShadowColor,
      textShadowOffset = style.textShadowOffset,
      textShadowRadius = style.textShadowRadius;
    var _ref2 = textShadowOffset || defaultOffset,
      height = _ref2.height,
      width = _ref2.width;
    var radius = textShadowRadius || 0;
    var offsetX = (0, normalizeValueWithProperty.default)(width);
    var offsetY = (0, normalizeValueWithProperty.default)(height);
    var blurRadius = (0, normalizeValueWithProperty.default)(radius);
    var color = (0, normalizeValueWithProperty.default)(textShadowColor, 'textShadowColor');
    if (color && (height !== 0 || width !== 0 || radius !== 0) && offsetX != null && offsetY != null && blurRadius != null) {
      return offsetX + " " + offsetY + " " + blurRadius + " " + color;
    }
  };

  // { offsetX: 1, offsetY: 2, blurRadius: 3, spreadDistance: 4, color: 'rgba(255, 0, 0)', inset: true }
  // => 'rgba(255, 0, 0) 1px 2px 3px 4px inset'
  var mapBoxShadow = boxShadow => {
    if (typeof boxShadow === 'string') {
      return boxShadow;
    }
    var offsetX = (0, normalizeValueWithProperty.default)(boxShadow.offsetX) || 0;
    var offsetY = (0, normalizeValueWithProperty.default)(boxShadow.offsetY) || 0;
    var blurRadius = (0, normalizeValueWithProperty.default)(boxShadow.blurRadius) || 0;
    var spreadDistance = (0, normalizeValueWithProperty.default)(boxShadow.spreadDistance) || 0;
    var color = (0, normalizeColor.default)(boxShadow.color) || 'black';
    var position = boxShadow.inset ? 'inset ' : '';
    return "" + position + offsetX + " " + offsetY + " " + blurRadius + " " + spreadDistance + " " + color;
  };
  var createBoxShadowArrayValue = value => {
    return value.map(mapBoxShadow).join(', ');
  };

  // { scale: 2 } => 'scale(2)'
  // { translateX: 20 } => 'translateX(20px)'
  // { matrix: [1,2,3,4,5,6] } => 'matrix(1,2,3,4,5,6)'
  var mapTransform = transform => {
    var type = Object.keys(transform)[0];
    var value = transform[type];
    if (type === 'matrix' || type === 'matrix3d') {
      return type + "(" + value.join(',') + ")";
    } else {
      var normalizedValue = (0, normalizeValueWithProperty.default)(value, type);
      return type + "(" + normalizedValue + ")";
    }
  };
  var createTransformValue = value => {
    return value.map(mapTransform).join(' ');
  };

  // [2, '30%', 10] => '2px 30% 10px'
  var createTransformOriginValue = value => {
    return value.map(v => (0, normalizeValueWithProperty.default)(v)).join(' ');
  };
  var PROPERTIES_STANDARD = {
    borderBottomEndRadius: 'borderEndEndRadius',
    borderBottomStartRadius: 'borderEndStartRadius',
    borderTopEndRadius: 'borderStartEndRadius',
    borderTopStartRadius: 'borderStartStartRadius',
    borderEndColor: 'borderInlineEndColor',
    borderEndStyle: 'borderInlineEndStyle',
    borderEndWidth: 'borderInlineEndWidth',
    borderStartColor: 'borderInlineStartColor',
    borderStartStyle: 'borderInlineStartStyle',
    borderStartWidth: 'borderInlineStartWidth',
    end: 'insetInlineEnd',
    marginEnd: 'marginInlineEnd',
    marginHorizontal: 'marginInline',
    marginStart: 'marginInlineStart',
    marginVertical: 'marginBlock',
    paddingEnd: 'paddingInlineEnd',
    paddingHorizontal: 'paddingInline',
    paddingStart: 'paddingInlineStart',
    paddingVertical: 'paddingBlock',
    start: 'insetInlineStart'
  };
  var ignoredProps = {
    elevation: true,
    overlayColor: true,
    resizeMode: true,
    tintColor: true
  };

  /**
   * Preprocess styles
   */
  var preprocess = function preprocess(originalStyle, options) {
    if (options === undefined) {
      options = {};
    }
    var style = originalStyle || emptyObject;
    var nextStyle = {};

    // Convert shadow styles
    if (options.shadow === true, style.shadowColor != null || style.shadowOffset != null || style.shadowOpacity != null || style.shadowRadius != null) {
      (0, _modulesWarnOnce.warnOnce)('shadowStyles', "\"shadow*\" style props are deprecated. Use \"boxShadow\".");
      var boxShadowValue = createBoxShadowValue(style);
      if (boxShadowValue != null) {
        nextStyle.boxShadow = boxShadowValue;
      }
    }

    // Convert text shadow styles
    if (options.textShadow === true, style.textShadowColor != null || style.textShadowOffset != null || style.textShadowRadius != null) {
      (0, _modulesWarnOnce.warnOnce)('textShadowStyles', "\"textShadow*\" style props are deprecated. Use \"textShadow\".");
      var textShadowValue = createTextShadowValue(style);
      if (textShadowValue != null && nextStyle.textShadow == null) {
        var textShadow = style.textShadow;
        var value = textShadow ? textShadow + ", " + textShadowValue : textShadowValue;
        nextStyle.textShadow = value;
      }
    }
    for (var originalProp in style) {
      if (
      // Ignore some React Native styles
      ignoredProps[originalProp] != null || originalProp === 'shadowColor' || originalProp === 'shadowOffset' || originalProp === 'shadowOpacity' || originalProp === 'shadowRadius' || originalProp === 'textShadowColor' || originalProp === 'textShadowOffset' || originalProp === 'textShadowRadius') {
        continue;
      }
      var originalValue = style[originalProp];
      var prop = PROPERTIES_STANDARD[originalProp] || originalProp;
      var _value = originalValue;
      if (!Object.prototype.hasOwnProperty.call(style, originalProp) || prop !== originalProp && style[prop] != null) {
        continue;
      }
      if (prop === 'aspectRatio' && typeof _value === 'number') {
        nextStyle[prop] = _value.toString();
      } else if (prop === 'boxShadow') {
        if (Array.isArray(_value)) {
          _value = createBoxShadowArrayValue(_value);
        }
        var boxShadow = nextStyle.boxShadow;
        nextStyle.boxShadow = boxShadow ? _value + ", " + boxShadow : _value;
      } else if (prop === 'fontVariant') {
        if (Array.isArray(_value) && _value.length > 0) {
          /*
          warnOnce(
            'fontVariant',
            '"fontVariant" style array value is deprecated. Use space-separated values.'
          );
          */
          _value = _value.join(' ');
        }
        nextStyle[prop] = _value;
      } else if (prop === 'textAlignVertical') {
        /*
        warnOnce(
          'textAlignVertical',
          '"textAlignVertical" style is deprecated. Use "verticalAlign".'
        );
        */
        if (style.verticalAlign == null) {
          nextStyle.verticalAlign = _value === 'center' ? 'middle' : _value;
        }
      } else if (prop === 'transform') {
        if (Array.isArray(_value)) {
          _value = createTransformValue(_value);
        }
        nextStyle.transform = _value;
      } else if (prop === 'transformOrigin') {
        if (Array.isArray(_value)) {
          _value = createTransformOriginValue(_value);
        }
        nextStyle.transformOrigin = _value;
      } else {
        nextStyle[prop] = _value;
      }
    }

    // $FlowIgnore
    return nextStyle;
  };
  var _default = preprocess;
},87,[49,47,88]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.warnOnce = warnOnce;
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var warnedKeys = {};

  /**
   * A simple function that prints a warning message once per session.
   *
   * @param {string} key - The key used to ensure the message is printed once.
   *                       This should be unique to the callsite.
   * @param {string} message - The message to print
   */
  function warnOnce(key, message) {}
},88,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.styleq = undefined;
  var cache = new WeakMap();
  var compiledKey = '$$css';
  function createStyleq(options) {
    var disableCache;
    var disableMix;
    var transform;
    if (options != null) {
      disableCache = options.disableCache === true;
      disableMix = options.disableMix === true;
      transform = options.transform;
    }
    return function styleq() {
      // Keep track of property commits to the className
      var definedProperties = []; // The className and inline style to build up

      var className = '';
      var inlineStyle = null; // The current position in the cache graph

      var nextCache = disableCache ? null : cache; // This way of creating an array from arguments is fastest

      var styles = new Array(arguments.length);
      for (var i = 0; i < arguments.length; i++) {
        styles[i] = arguments[i];
      } // Iterate over styles from last to first

      while (styles.length > 0) {
        var possibleStyle = styles.pop(); // Skip empty items

        if (possibleStyle == null || possibleStyle === false) {
          continue;
        } // Push nested styles back onto the stack to be processed

        if (Array.isArray(possibleStyle)) {
          for (var _i = 0; _i < possibleStyle.length; _i++) {
            styles.push(possibleStyle[_i]);
          }
          continue;
        } // Process an individual style object

        var style = transform != null ? transform(possibleStyle) : possibleStyle;
        if (style.$$css) {
          // Build up the class names defined by this object
          var classNameChunk = ''; // Check the cache to see if we've already done this work

          if (nextCache != null && nextCache.has(style)) {
            // Cache: read
            var cacheEntry = nextCache.get(style);
            if (cacheEntry != null) {
              classNameChunk = cacheEntry[0]; // $FlowIgnore

              definedProperties.push.apply(definedProperties, cacheEntry[1]);
              nextCache = cacheEntry[2];
            }
          } // Update the chunks with data from this object
          else {
            // The properties defined by this object
            var definedPropertiesChunk = [];
            for (var prop in style) {
              var value = style[prop];
              if (prop === compiledKey) continue; // Each property value is used as an HTML class name
              // { 'debug.string': 'debug.string', opacity: 's-jskmnoqp' }

              if (typeof value === 'string' || value === null) {
                // Only add to chunks if this property hasn't already been seen
                if (!definedProperties.includes(prop)) {
                  definedProperties.push(prop);
                  if (nextCache != null) {
                    definedPropertiesChunk.push(prop);
                  }
                  if (typeof value === 'string') {
                    classNameChunk += classNameChunk ? ' ' + value : value;
                  }
                }
              } // If we encounter a value that isn't a string or `null`
              else {
                console.error("styleq: ".concat(prop, " typeof ").concat(String(value), " is not \"string\" or \"null\"."));
              }
            } // Cache: write

            if (nextCache != null) {
              // Create the next WeakMap for this sequence of styles
              var weakMap = new WeakMap();
              nextCache.set(style, [classNameChunk, definedPropertiesChunk, weakMap]);
              nextCache = weakMap;
            }
          } // Order of classes in chunks matches property-iteration order of style
          // object. Order of chunks matches passed order of styles from first to
          // last (which we iterate over in reverse).

          if (classNameChunk) {
            className = className ? classNameChunk + ' ' + className : classNameChunk;
          }
        } // ----- DYNAMIC: Process inline style object -----
        else {
          if (disableMix) {
            if (inlineStyle == null) {
              inlineStyle = {};
            }
            inlineStyle = Object.assign({}, style, inlineStyle);
          } else {
            var subStyle = null;
            for (var _prop in style) {
              var _value = style[_prop];
              if (_value !== undefined) {
                if (!definedProperties.includes(_prop)) {
                  if (_value != null) {
                    if (inlineStyle == null) {
                      inlineStyle = {};
                    }
                    if (subStyle == null) {
                      subStyle = {};
                    }
                    subStyle[_prop] = _value;
                  }
                  definedProperties.push(_prop); // Cache is unnecessary overhead if results can't be reused.

                  nextCache = null;
                }
              }
            }
            if (subStyle != null) {
              inlineStyle = Object.assign(subStyle, inlineStyle);
            }
          }
        }
      }
      var styleProps = [className, inlineStyle];
      return styleProps;
    };
  }
  var styleq = createStyleq();
  exports.styleq = styleq;
  styleq.factory = createStyleq;
},89,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.validate = validate;
  var _postcssValueParser = require(_dependencyMap[0]);
  var valueParser = _interopDefault(_postcssValueParser);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var invalidShortforms = {
    background: true,
    borderBottom: true,
    borderLeft: true,
    borderRight: true,
    borderTop: true,
    font: true,
    grid: true,
    outline: true,
    textDecoration: true
  };
  var invalidMultiValueShortforms = {
    flex: true,
    margin: true,
    padding: true,
    borderColor: true,
    borderRadius: true,
    borderStyle: true,
    borderWidth: true,
    inset: true,
    insetBlock: true,
    insetInline: true,
    marginBlock: true,
    marginInline: true,
    marginHorizontal: true,
    marginVertical: true,
    paddingBlock: true,
    paddingInline: true,
    paddingHorizontal: true,
    paddingVertical: true,
    overflow: true,
    overscrollBehavior: true,
    backgroundPosition: true
  };
  function error(message) {
    console.error(message);
  }
  function validate(obj) {
    for (var k in obj) {
      var prop = k.trim();
      var value = obj[prop];
      var isInvalid = false;
      if (value === null) {
        continue;
      }
      if (typeof value === 'string' && value.indexOf('!important') > -1) {
        error("Invalid style declaration \"" + prop + ":" + value + "\". Values cannot include \"!important\"");
        isInvalid = true;
      } else {
        var suggestion = '';
        if (prop === 'animation' || prop === 'animationName') {
          suggestion = 'Did you mean "animationKeyframes"?';
          isInvalid = true;
        } else if (prop === 'direction') {
          suggestion = 'Did you mean "writingDirection"?';
          isInvalid = true;
        } else if (invalidShortforms[prop]) {
          suggestion = 'Please use long-form properties.';
          isInvalid = true;
        } else if (invalidMultiValueShortforms[prop]) {
          if (typeof value === 'string' && (0, valueParser.default)(value).nodes.length > 1) {
            suggestion = "Value is \"" + value + "\" but only single values are supported.";
            isInvalid = true;
          }
        }
        if (suggestion !== '') {
          error("Invalid style property of \"" + prop + "\". " + suggestion);
        }
      }
      if (isInvalid) {
        delete obj[k];
      }
    }
  }
},90,[91]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var parse = require(_dependencyMap[0]);
  var walk = require(_dependencyMap[1]);
  var stringify = require(_dependencyMap[2]);
  function ValueParser(value) {
    if (this instanceof ValueParser) {
      this.nodes = parse(value);
      return this;
    }
    return new ValueParser(value);
  }
  ValueParser.prototype.toString = function () {
    return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
  };
  ValueParser.prototype.walk = function (cb, bubble) {
    walk(this.nodes, cb, bubble);
    return this;
  };
  ValueParser.unit = require(_dependencyMap[3]);
  ValueParser.walk = walk;
  ValueParser.stringify = stringify;
  module.exports = ValueParser;
},91,[92,93,94,95]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var openParentheses = "(".charCodeAt(0);
  var closeParentheses = ")".charCodeAt(0);
  var singleQuote = "'".charCodeAt(0);
  var doubleQuote = '"'.charCodeAt(0);
  var backslash = "\\".charCodeAt(0);
  var slash = "/".charCodeAt(0);
  var comma = ",".charCodeAt(0);
  var colon = ":".charCodeAt(0);
  var star = "*".charCodeAt(0);
  var uLower = "u".charCodeAt(0);
  var uUpper = "U".charCodeAt(0);
  var plus = "+".charCodeAt(0);
  var isUnicodeRange = /^[a-f0-9?-]+$/i;
  module.exports = function (input) {
    var tokens = [];
    var value = input;
    var next, quote, prev, token, escape, escapePos, whitespacePos, parenthesesOpenPos;
    var pos = 0;
    var code = value.charCodeAt(pos);
    var max = value.length;
    var stack = [{
      nodes: tokens
    }];
    var balanced = 0;
    var parent;
    var name = "";
    var before = "";
    var after = "";
    while (pos < max) {
      // Whitespaces
      if (code <= 32) {
        next = pos;
        do {
          next += 1;
          code = value.charCodeAt(next);
        } while (code <= 32);
        token = value.slice(pos, next);
        prev = tokens[tokens.length - 1];
        if (code === closeParentheses && balanced) {
          after = token;
        } else if (prev && prev.type === "div") {
          prev.after = token;
          prev.sourceEndIndex += token.length;
        } else if (code === comma || code === colon || code === slash && value.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
          before = token;
        } else {
          tokens.push({
            type: "space",
            sourceIndex: pos,
            sourceEndIndex: next,
            value: token
          });
        }
        pos = next;

        // Quotes
      } else if (code === singleQuote || code === doubleQuote) {
        next = pos;
        quote = code === singleQuote ? "'" : '"';
        token = {
          type: "string",
          sourceIndex: pos,
          quote: quote
        };
        do {
          escape = false;
          next = value.indexOf(quote, next + 1);
          if (~next) {
            escapePos = next;
            while (value.charCodeAt(escapePos - 1) === backslash) {
              escapePos -= 1;
              escape = !escape;
            }
          } else {
            value += quote;
            next = value.length - 1;
            token.unclosed = true;
          }
        } while (escape);
        token.value = value.slice(pos + 1, next);
        token.sourceEndIndex = token.unclosed ? next : next + 1;
        tokens.push(token);
        pos = next + 1;
        code = value.charCodeAt(pos);

        // Comments
      } else if (code === slash && value.charCodeAt(pos + 1) === star) {
        next = value.indexOf("*/", pos);
        token = {
          type: "comment",
          sourceIndex: pos,
          sourceEndIndex: next + 2
        };
        if (next === -1) {
          token.unclosed = true;
          next = value.length;
          token.sourceEndIndex = next;
        }
        token.value = value.slice(pos + 2, next);
        tokens.push(token);
        pos = next + 2;
        code = value.charCodeAt(pos);

        // Operation within calc
      } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
        token = value[pos];
        tokens.push({
          type: "word",
          sourceIndex: pos - before.length,
          sourceEndIndex: pos + token.length,
          value: token
        });
        pos += 1;
        code = value.charCodeAt(pos);

        // Dividers
      } else if (code === slash || code === comma || code === colon) {
        token = value[pos];
        tokens.push({
          type: "div",
          sourceIndex: pos - before.length,
          sourceEndIndex: pos + token.length,
          value: token,
          before: before,
          after: ""
        });
        before = "";
        pos += 1;
        code = value.charCodeAt(pos);

        // Open parentheses
      } else if (openParentheses === code) {
        // Whitespaces after open parentheses
        next = pos;
        do {
          next += 1;
          code = value.charCodeAt(next);
        } while (code <= 32);
        parenthesesOpenPos = pos;
        token = {
          type: "function",
          sourceIndex: pos - name.length,
          value: name,
          before: value.slice(parenthesesOpenPos + 1, next)
        };
        pos = next;
        if (name === "url" && code !== singleQuote && code !== doubleQuote) {
          next -= 1;
          do {
            escape = false;
            next = value.indexOf(")", next + 1);
            if (~next) {
              escapePos = next;
              while (value.charCodeAt(escapePos - 1) === backslash) {
                escapePos -= 1;
                escape = !escape;
              }
            } else {
              value += ")";
              next = value.length - 1;
              token.unclosed = true;
            }
          } while (escape);
          // Whitespaces before closed
          whitespacePos = next;
          do {
            whitespacePos -= 1;
            code = value.charCodeAt(whitespacePos);
          } while (code <= 32);
          if (parenthesesOpenPos < whitespacePos) {
            if (pos !== whitespacePos + 1) {
              token.nodes = [{
                type: "word",
                sourceIndex: pos,
                sourceEndIndex: whitespacePos + 1,
                value: value.slice(pos, whitespacePos + 1)
              }];
            } else {
              token.nodes = [];
            }
            if (token.unclosed && whitespacePos + 1 !== next) {
              token.after = "";
              token.nodes.push({
                type: "space",
                sourceIndex: whitespacePos + 1,
                sourceEndIndex: next,
                value: value.slice(whitespacePos + 1, next)
              });
            } else {
              token.after = value.slice(whitespacePos + 1, next);
              token.sourceEndIndex = next;
            }
          } else {
            token.after = "";
            token.nodes = [];
          }
          pos = next + 1;
          token.sourceEndIndex = token.unclosed ? next : pos;
          code = value.charCodeAt(pos);
          tokens.push(token);
        } else {
          balanced += 1;
          token.after = "";
          token.sourceEndIndex = pos + 1;
          tokens.push(token);
          stack.push(token);
          tokens = token.nodes = [];
          parent = token;
        }
        name = "";

        // Close parentheses
      } else if (closeParentheses === code && balanced) {
        pos += 1;
        code = value.charCodeAt(pos);
        parent.after = after;
        parent.sourceEndIndex += after.length;
        after = "";
        balanced -= 1;
        stack[stack.length - 1].sourceEndIndex = pos;
        stack.pop();
        parent = stack[balanced];
        tokens = parent.nodes;

        // Words
      } else {
        next = pos;
        do {
          if (code === backslash) {
            next += 1;
          }
          next += 1;
          code = value.charCodeAt(next);
        } while (next < max && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced));
        token = value.slice(pos, next);
        if (openParentheses === code) {
          name = token;
        } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
          tokens.push({
            type: "unicode-range",
            sourceIndex: pos,
            sourceEndIndex: next,
            value: token
          });
        } else {
          tokens.push({
            type: "word",
            sourceIndex: pos,
            sourceEndIndex: next,
            value: token
          });
        }
        pos = next;
      }
    }
    for (pos = stack.length - 1; pos; pos -= 1) {
      stack[pos].unclosed = true;
      stack[pos].sourceEndIndex = value.length;
    }
    return stack[0].nodes;
  };
},92,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = function walk(nodes, cb, bubble) {
    var i, max, node, result;
    for (i = 0, max = nodes.length; i < max; i += 1) {
      node = nodes[i];
      if (!bubble) {
        result = cb(node, i, nodes);
      }
      if (result !== false && node.type === "function" && Array.isArray(node.nodes)) {
        walk(node.nodes, cb, bubble);
      }
      if (bubble) {
        cb(node, i, nodes);
      }
    }
  };
},93,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function stringifyNode(node, custom) {
    var type = node.type;
    var value = node.value;
    var buf;
    var customResult;
    if (custom && (customResult = custom(node)) !== undefined) {
      return customResult;
    } else if (type === "word" || type === "space") {
      return value;
    } else if (type === "string") {
      buf = node.quote || "";
      return buf + value + (node.unclosed ? "" : buf);
    } else if (type === "comment") {
      return "/*" + value + (node.unclosed ? "" : "*/");
    } else if (type === "div") {
      return (node.before || "") + value + (node.after || "");
    } else if (Array.isArray(node.nodes)) {
      buf = stringify(node.nodes, custom);
      if (type !== "function") {
        return buf;
      }
      return value + "(" + (node.before || "") + buf + (node.after || "") + (node.unclosed ? "" : ")");
    }
    return value;
  }
  function stringify(nodes, custom) {
    var result, i;
    if (Array.isArray(nodes)) {
      result = "";
      for (i = nodes.length - 1; ~i; i -= 1) {
        result = stringifyNode(nodes[i], custom) + result;
      }
      return result;
    }
    return stringifyNode(nodes, custom);
  }
  module.exports = stringify;
},94,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var minus = "-".charCodeAt(0);
  var plus = "+".charCodeAt(0);
  var dot = ".".charCodeAt(0);
  var exp = "e".charCodeAt(0);
  var EXP = "E".charCodeAt(0);

  // Check if three code points would start a number
  // https://www.w3.org/TR/css-syntax-3/#starts-with-a-number
  function likeNumber(value) {
    var code = value.charCodeAt(0);
    var nextCode;
    if (code === plus || code === minus) {
      nextCode = value.charCodeAt(1);
      if (nextCode >= 48 && nextCode <= 57) {
        return true;
      }
      var nextNextCode = value.charCodeAt(2);
      if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
        return true;
      }
      return false;
    }
    if (code === dot) {
      nextCode = value.charCodeAt(1);
      if (nextCode >= 48 && nextCode <= 57) {
        return true;
      }
      return false;
    }
    if (code >= 48 && code <= 57) {
      return true;
    }
    return false;
  }

  // Consume a number
  // https://www.w3.org/TR/css-syntax-3/#consume-number
  module.exports = function (value) {
    var pos = 0;
    var length = value.length;
    var code;
    var nextCode;
    var nextNextCode;
    if (length === 0 || !likeNumber(value)) {
      return false;
    }
    code = value.charCodeAt(pos);
    if (code === plus || code === minus) {
      pos++;
    }
    while (pos < length) {
      code = value.charCodeAt(pos);
      if (code < 48 || code > 57) {
        break;
      }
      pos += 1;
    }
    code = value.charCodeAt(pos);
    nextCode = value.charCodeAt(pos + 1);
    if (code === dot && nextCode >= 48 && nextCode <= 57) {
      pos += 2;
      while (pos < length) {
        code = value.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
    }
    code = value.charCodeAt(pos);
    nextCode = value.charCodeAt(pos + 1);
    nextNextCode = value.charCodeAt(pos + 2);
    if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
      pos += nextCode === plus || nextCode === minus ? 3 : 2;
      while (pos < length) {
        code = value.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
    }
    return {
      number: value.slice(0, pos),
      unit: value.slice(pos)
    };
  };
},95,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var Platform = {
    OS: 'web',
    select: obj => 'web' in obj ? obj.web : obj.default,
    get isTesting() {
      return false;
    },
    get Version() {
      return '0.0.0';
    }
  };
  var _default = Platform;
},96,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.isRunningInExpoGo = isRunningInExpoGo;
  exports.getExpoGoProjectConfig = getExpoGoProjectConfig;
  function isRunningInExpoGo() {
    return false;
  }
  function getExpoGoProjectConfig() {
    return null;
  }
},97,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "EventEmitter", {
    enumerable: true,
    get: function () {
      return _EventEmitter.EventEmitter;
    }
  });
  Object.defineProperty(exports, "NativeModule", {
    enumerable: true,
    get: function () {
      return _NativeModule.NativeModule;
    }
  });
  Object.defineProperty(exports, "SharedObject", {
    enumerable: true,
    get: function () {
      return _SharedObject.SharedObject;
    }
  });
  Object.defineProperty(exports, "SharedRef", {
    enumerable: true,
    get: function () {
      return _SharedRef.SharedRef;
    }
  });
  Object.defineProperty(exports, "Platform", {
    enumerable: true,
    get: function () {
      return _Platform2.default;
    }
  });
  Object.defineProperty(exports, "uuid", {
    enumerable: true,
    get: function () {
      return _uuid2.default;
    }
  });
  Object.defineProperty(exports, "requireNativeViewManager", {
    enumerable: true,
    get: function () {
      return _NativeViewManagerAdapter.requireNativeViewManager;
    }
  });
  Object.defineProperty(exports, "CodedError", {
    enumerable: true,
    get: function () {
      return _errorsCodedError.CodedError;
    }
  });
  Object.defineProperty(exports, "UnavailabilityError", {
    enumerable: true,
    get: function () {
      return _errorsUnavailabilityError.UnavailabilityError;
    }
  });
  Object.defineProperty(exports, "LegacyEventEmitter", {
    enumerable: true,
    get: function () {
      return _LegacyEventEmitter.LegacyEventEmitter;
    }
  });
  Object.defineProperty(exports, "NativeModulesProxy", {
    enumerable: true,
    get: function () {
      return _NativeModulesProxy2.default;
    }
  });
  require(_dependencyMap[0]);
  require(_dependencyMap[1]);
  var _EventEmitter = require(_dependencyMap[2]);
  var _NativeModule = require(_dependencyMap[3]);
  var _SharedObject = require(_dependencyMap[4]);
  var _SharedRef = require(_dependencyMap[5]);
  var _Platform = require(_dependencyMap[6]);
  var _Platform2 = _interopDefault(_Platform);
  var _uuid = require(_dependencyMap[7]);
  var _uuid2 = _interopDefault(_uuid);
  var _NativeViewManagerAdapter = require(_dependencyMap[8]);
  var _requireNativeModule = require(_dependencyMap[9]);
  Object.keys(_requireNativeModule).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _requireNativeModule[k];
        }
      });
    }
  });
  var _registerWebModule = require(_dependencyMap[10]);
  Object.keys(_registerWebModule).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _registerWebModule[k];
        }
      });
    }
  });
  var _TypedArraysTypes = require(_dependencyMap[11]);
  Object.keys(_TypedArraysTypes).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _TypedArraysTypes[k];
        }
      });
    }
  });
  var _PermissionsInterface = require(_dependencyMap[12]);
  Object.keys(_PermissionsInterface).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _PermissionsInterface[k];
        }
      });
    }
  });
  var _PermissionsHook = require(_dependencyMap[13]);
  Object.keys(_PermissionsHook).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _PermissionsHook[k];
        }
      });
    }
  });
  var _Refs = require(_dependencyMap[14]);
  Object.keys(_Refs).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _Refs[k];
        }
      });
    }
  });
  var _hooksUseReleasingSharedObject = require(_dependencyMap[15]);
  Object.keys(_hooksUseReleasingSharedObject).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _hooksUseReleasingSharedObject[k];
        }
      });
    }
  });
  var _reload = require(_dependencyMap[16]);
  Object.keys(_reload).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _reload[k];
        }
      });
    }
  });
  var _errorsCodedError = require(_dependencyMap[17]);
  var _errorsUnavailabilityError = require(_dependencyMap[18]);
  var _LegacyEventEmitter = require(_dependencyMap[19]);
  var _NativeModulesProxy = require(_dependencyMap[20]);
  var _NativeModulesProxy2 = _interopDefault(_NativeModulesProxy);
},98,[99,100,113,293,294,295,296,103,298,301,302,303,304,305,307,308,309,300,299,310,312]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {},99,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  var _dangerousInternal = require(_dependencyMap[0]);
  (0, _dangerousInternal.installExpoGlobalPolyfill)();
},100,[101]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.installExpoGlobalPolyfill = installExpoGlobalPolyfill;
  var _CoreModule = require(_dependencyMap[0]);
  var _uuidIndexWeb = require(_dependencyMap[1]);
  var uuid = _interopDefault(_uuidIndexWeb);
  var _tsDeclarationsGlobal = require(_dependencyMap[2]);
  Object.keys(_tsDeclarationsGlobal).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) {
      Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
          return _tsDeclarationsGlobal[k];
        }
      });
    }
  });
  // jest-expo imports to this file directly without going through the global types
  // Exporting the types to let jest-expo to know the globalThis types

  function installExpoGlobalPolyfill() {
    if (globalThis.expo) return;
    globalThis.expo = {
      EventEmitter: _CoreModule.EventEmitter,
      NativeModule: _CoreModule.NativeModule,
      SharedObject: _CoreModule.SharedObject,
      SharedRef: _CoreModule.SharedRef,
      modules: globalThis.ExpoDomWebView?.expoModulesProxy ?? {},
      uuidv4: uuid.default.v4,
      uuidv5: uuid.default.v5,
      getViewConfig: () => {
        throw new Error('Method not implemented.');
      },
      reloadAppAsync: async () => {
        window.location.reload();
      },
      expoModulesCoreVersion: undefined,
      cacheDir: undefined,
      documentsDir: undefined
    };
  }
},101,[102,103,108]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "EventEmitter", {
    enumerable: true,
    get: function () {
      return EventEmitter;
    }
  });
  Object.defineProperty(exports, "NativeModule", {
    enumerable: true,
    get: function () {
      return NativeModule;
    }
  });
  Object.defineProperty(exports, "SharedObject", {
    enumerable: true,
    get: function () {
      return SharedObject;
    }
  });
  Object.defineProperty(exports, "SharedRef", {
    enumerable: true,
    get: function () {
      return SharedRef;
    }
  });
  class EventEmitter {
    addListener(eventName, listener) {
      if (!this.listeners) {
        this.listeners = new Map();
      }
      if (!this.listeners?.has(eventName)) {
        this.listeners?.set(eventName, new Set());
      }
      const previousListenerCount = this.listenerCount(eventName);
      this.listeners?.get(eventName)?.add(listener);
      if (previousListenerCount === 0 && this.listenerCount(eventName) === 1) {
        this.startObserving(eventName);
      }
      return {
        remove: () => {
          this.removeListener(eventName, listener);
        }
      };
    }
    removeListener(eventName, listener) {
      const hasRemovedListener = this.listeners?.get(eventName)?.delete(listener);
      if (this.listenerCount(eventName) === 0 && hasRemovedListener) {
        this.stopObserving(eventName);
      }
    }
    removeAllListeners(eventName) {
      const previousListenerCount = this.listenerCount(eventName);
      this.listeners?.get(eventName)?.clear();
      if (previousListenerCount > 0) {
        this.stopObserving(eventName);
      }
    }
    emit(eventName, ...args) {
      const listeners = new Set(this.listeners?.get(eventName));
      listeners.forEach(listener => {
        // When the listener throws an error, don't stop the execution of subsequent listeners and
        // don't propagate the error to the `emit` function. The motivation behind this is that
        // errors thrown from a module or user's code shouldn't affect other modules' behavior.
        try {
          listener(...args);
        } catch (error) {
          console.error(error);
        }
      });
    }
    listenerCount(eventName) {
      return this.listeners?.get(eventName)?.size ?? 0;
    }
    startObserving(eventName) {}
    stopObserving(eventName) {}
  }
  class NativeModule extends EventEmitter {}
  class SharedObject extends EventEmitter {
    release() {
      // no-op on Web, but subclasses can override it if needed.
    }
  }
  class SharedRef extends SharedObject {
    nativeRefType = 'unknown';
  }
},102,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _libSha = require(_dependencyMap[0]);
  var sha1 = _interopDefault(_libSha);
  var _libV = require(_dependencyMap[1]);
  var v35 = _interopDefault(_libV);
  var _uuidTypes = require(_dependencyMap[2]);
  function uuidv4() {
    if (
    // Node.js has supported global crypto since v15.
    // We use this code path in jest-expo.

    typeof crypto === 'undefined' &&
    // Only use abstract imports in server environments.
    typeof window === 'undefined') {
      // NOTE: Metro statically extracts all `require` statements to resolve them for environments
      // that don't support `require` natively. Here we check if we're running in a server environment
      // by using the standard `typeof window` check, then running `eval` to skip Metro's static
      // analysis and keep the `require` statement intact for runtime evaluation.
      // eslint-disable-next-line no-eval
      return eval('require')('node:crypto').randomUUID();
    }
    return crypto.randomUUID();
  }
  const uuid = {
    v4: uuidv4,
    v5: (0, v35.default)('v5', 0x50, sha1.default),
    namespace: _uuidTypes.Uuidv5Namespace
  };
  var _default = uuid;
},103,[104,105,107]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  // Adapted from Chris Veness' SHA1 code at
  // http://www.movable-type.co.uk/scripts/sha1.html
  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  function f(s, x, y, z) {
    switch (s) {
      case 0:
        return x & y ^ ~x & z;
      case 1:
        return x ^ y ^ z;
      case 2:
        return x & y ^ x & z ^ y & z;
      case 3:
        return x ^ y ^ z;
      default:
        return 0;
    }
  }
  function ROTL(x, n) {
    return x << n | x >>> 32 - n;
  }
  function sha1(bytes) {
    const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
    const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
    if (typeof bytes == 'string') {
      const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape
      bytes = new Array(msg.length);
      for (let i = 0; i < msg.length; i++) bytes[i] = msg.charCodeAt(i);
    }
    bytes.push(0x80);
    const l = bytes.length / 4 + 2;
    const N = Math.ceil(l / 16);
    const M = new Array(N);
    for (let i = 0; i < N; i++) {
      M[i] = new Array(16);
      for (let j = 0; j < 16; j++) {
        M[i][j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
      }
    }
    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
    M[N - 1][14] = Math.floor(M[N - 1][14]);
    M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;
    for (let i = 0; i < N; i++) {
      const W = new Array(80);
      for (let t = 0; t < 16; t++) W[t] = M[i][t];
      for (let t = 16; t < 80; t++) {
        W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
      }
      let a = H[0];
      let b = H[1];
      let c = H[2];
      let d = H[3];
      let e = H[4];
      for (let t = 0; t < 80; t++) {
        const s = Math.floor(t / 20);
        const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
        e = d;
        d = c;
        c = ROTL(b, 30) >>> 0;
        b = a;
        a = T;
      }
      H[0] = H[0] + a >>> 0;
      H[1] = H[1] + b >>> 0;
      H[2] = H[2] + c >>> 0;
      H[3] = H[3] + d >>> 0;
      H[4] = H[4] + e >>> 0;
    }
    return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
  }
  var _default = sha1;
},104,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _ref;
    }
  });
  var _bytesToUuid = require(_dependencyMap[0]);
  var bytesToUuid = _interopDefault(_bytesToUuid);
  function uuidToBytes(uuid) {
    // Note: We assume we're being passed a valid uuid string
    const bytes = [];
    uuid.replace(/[a-fA-F0-9]{2}/g, hex => {
      bytes.push(parseInt(hex, 16));
      return '';
    });
    return bytes;
  }
  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str)); // UTF8 escape
    const bytes = new Array(str.length);
    for (let i = 0; i < str.length; i++) {
      bytes[i] = str.charCodeAt(i);
    }
    return bytes;
  }
  function _ref(name, version, hashfunc) {
    const generateUUID = function (value, namespace, buf, offset) {
      const off = buf && offset || 0;
      if (typeof value == 'string') value = stringToBytes(value);
      if (typeof namespace == 'string') namespace = uuidToBytes(namespace);
      if (!Array.isArray(value)) throw TypeError('value must be an array of bytes');
      if (!Array.isArray(namespace) || namespace.length !== 16) throw TypeError('namespace must be uuid string or an Array of 16 byte values');

      // Per 4.3
      const bytes = hashfunc(namespace.concat(value));
      bytes[6] = bytes[6] & 0x0f | version;
      bytes[8] = bytes[8] & 0x3f | 0x80;
      if (buf) {
        for (let idx = 0; idx < 16; ++idx) {
          buf[off + idx] = bytes[idx];
        }
      }
      return (0, bytesToUuid.default)(bytes);
    };

    // Function#name is not settable on some platforms (#270)
    try {
      generateUUID.name = name;
    } catch {}

    // Pre-defined namespaces, per Appendix C
    generateUUID.DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
    generateUUID.URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
    return generateUUID;
  }
},105,[106]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Convert array of 16 byte values to UUID string format of the form:
   * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
   */
  const byteToHex = [];
  for (let i = 0; i < 256; ++i) {
    byteToHex[i] = (i + 0x100).toString(16).substr(1);
  }
  function bytesToUuid(buf, offset) {
    let i = offset || 0;
    const bth = byteToHex;
    // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
    return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');
  }
  var _default = bytesToUuid;
},106,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "Uuidv5Namespace", {
    enumerable: true,
    get: function () {
      return Uuidv5Namespace;
    }
  });
  /**
   * Collection of utilities used for generating Universally Unique Identifiers.
   */
  /**
   * Default namespaces for UUID v5 defined in RFC 4122
   */
  let Uuidv5Namespace = /*#__PURE__*/function (Uuidv5Namespace) {
    // Source of the UUIDs: https://datatracker.ietf.org/doc/html/rfc4122
    Uuidv5Namespace["dns"] = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    Uuidv5Namespace["url"] = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    Uuidv5Namespace["oid"] = "6ba7b812-9dad-11d1-80b4-00c04fd430c8";
    Uuidv5Namespace["x500"] = "6ba7b814-9dad-11d1-80b4-00c04fd430c8";
    return Uuidv5Namespace;
  }({});
},107,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  require(_dependencyMap[0]);
  require(_dependencyMap[1]);
  require(_dependencyMap[2]);
  require(_dependencyMap[3]);
},108,[109,110,111,112]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},109,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},110,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},111,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},112,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "EventEmitter", {
    enumerable: true,
    get: function () {
      return EventEmitter;
    }
  });
  var _ensureNativeModulesAreInstalled = require(_dependencyMap[0]);
  (0, _ensureNativeModulesAreInstalled.ensureNativeModulesAreInstalled)();

  /**
   * A subscription object that allows to conveniently remove an event listener from the emitter.
   */

  const EventEmitter = globalThis.expo.EventEmitter;
},113,[114]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.ensureNativeModulesAreInstalled = ensureNativeModulesAreInstalled;
  var _reactNativeWebDistIndex = require(_dependencyMap[0]);
  require(_dependencyMap[1]);
  // Installs the expo global on web

  /**
   * Ensures that the native modules are installed in the current runtime.
   * Otherwise, it synchronously calls a native function that installs them.
   */
  function ensureNativeModulesAreInstalled() {
    if (globalThis.expo) {
      return;
    }
    try {} catch (error) {
      console.error(`Unable to install Expo modules: ${error}`);
    }
  }
},114,[115,100]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "unstable_createElement", {
    enumerable: true,
    get: function () {
      return _exportsCreateElement2.default;
    }
  });
  Object.defineProperty(exports, "findNodeHandle", {
    enumerable: true,
    get: function () {
      return _exportsFindNodeHandle2.default;
    }
  });
  Object.defineProperty(exports, "processColor", {
    enumerable: true,
    get: function () {
      return _exportsProcessColor2.default;
    }
  });
  Object.defineProperty(exports, "render", {
    enumerable: true,
    get: function () {
      return _exportsRender2.default;
    }
  });
  Object.defineProperty(exports, "unmountComponentAtNode", {
    enumerable: true,
    get: function () {
      return _exportsUnmountComponentAtNode2.default;
    }
  });
  Object.defineProperty(exports, "NativeModules", {
    enumerable: true,
    get: function () {
      return _exportsNativeModules2.default;
    }
  });
  Object.defineProperty(exports, "AccessibilityInfo", {
    enumerable: true,
    get: function () {
      return _exportsAccessibilityInfo2.default;
    }
  });
  Object.defineProperty(exports, "Alert", {
    enumerable: true,
    get: function () {
      return _exportsAlert2.default;
    }
  });
  Object.defineProperty(exports, "Animated", {
    enumerable: true,
    get: function () {
      return _exportsAnimated2.default;
    }
  });
  Object.defineProperty(exports, "Appearance", {
    enumerable: true,
    get: function () {
      return _exportsAppearance2.default;
    }
  });
  Object.defineProperty(exports, "AppRegistry", {
    enumerable: true,
    get: function () {
      return _exportsAppRegistry2.default;
    }
  });
  Object.defineProperty(exports, "AppState", {
    enumerable: true,
    get: function () {
      return _exportsAppState2.default;
    }
  });
  Object.defineProperty(exports, "BackHandler", {
    enumerable: true,
    get: function () {
      return _exportsBackHandler2.default;
    }
  });
  Object.defineProperty(exports, "Clipboard", {
    enumerable: true,
    get: function () {
      return _exportsClipboard2.default;
    }
  });
  Object.defineProperty(exports, "Dimensions", {
    enumerable: true,
    get: function () {
      return _exportsDimensions2.default;
    }
  });
  Object.defineProperty(exports, "Easing", {
    enumerable: true,
    get: function () {
      return _exportsEasing2.default;
    }
  });
  Object.defineProperty(exports, "I18nManager", {
    enumerable: true,
    get: function () {
      return _exportsI18nManager2.default;
    }
  });
  Object.defineProperty(exports, "Keyboard", {
    enumerable: true,
    get: function () {
      return _exportsKeyboard2.default;
    }
  });
  Object.defineProperty(exports, "InteractionManager", {
    enumerable: true,
    get: function () {
      return _exportsInteractionManager2.default;
    }
  });
  Object.defineProperty(exports, "LayoutAnimation", {
    enumerable: true,
    get: function () {
      return _exportsLayoutAnimation2.default;
    }
  });
  Object.defineProperty(exports, "Linking", {
    enumerable: true,
    get: function () {
      return _exportsLinking2.default;
    }
  });
  Object.defineProperty(exports, "NativeEventEmitter", {
    enumerable: true,
    get: function () {
      return _exportsNativeEventEmitter2.default;
    }
  });
  Object.defineProperty(exports, "PanResponder", {
    enumerable: true,
    get: function () {
      return _exportsPanResponder2.default;
    }
  });
  Object.defineProperty(exports, "PixelRatio", {
    enumerable: true,
    get: function () {
      return _exportsPixelRatio2.default;
    }
  });
  Object.defineProperty(exports, "Platform", {
    enumerable: true,
    get: function () {
      return _exportsPlatform2.default;
    }
  });
  Object.defineProperty(exports, "Share", {
    enumerable: true,
    get: function () {
      return _exportsShare2.default;
    }
  });
  Object.defineProperty(exports, "StyleSheet", {
    enumerable: true,
    get: function () {
      return _exportsStyleSheet2.default;
    }
  });
  Object.defineProperty(exports, "UIManager", {
    enumerable: true,
    get: function () {
      return _exportsUIManager2.default;
    }
  });
  Object.defineProperty(exports, "Vibration", {
    enumerable: true,
    get: function () {
      return _exportsVibration2.default;
    }
  });
  Object.defineProperty(exports, "ActivityIndicator", {
    enumerable: true,
    get: function () {
      return _exportsActivityIndicator2.default;
    }
  });
  Object.defineProperty(exports, "Button", {
    enumerable: true,
    get: function () {
      return _exportsButton2.default;
    }
  });
  Object.defineProperty(exports, "CheckBox", {
    enumerable: true,
    get: function () {
      return _exportsCheckBox2.default;
    }
  });
  Object.defineProperty(exports, "FlatList", {
    enumerable: true,
    get: function () {
      return _exportsFlatList2.default;
    }
  });
  Object.defineProperty(exports, "Image", {
    enumerable: true,
    get: function () {
      return _exportsImage2.default;
    }
  });
  Object.defineProperty(exports, "ImageBackground", {
    enumerable: true,
    get: function () {
      return _exportsImageBackground2.default;
    }
  });
  Object.defineProperty(exports, "KeyboardAvoidingView", {
    enumerable: true,
    get: function () {
      return _exportsKeyboardAvoidingView2.default;
    }
  });
  Object.defineProperty(exports, "Modal", {
    enumerable: true,
    get: function () {
      return _exportsModal2.default;
    }
  });
  Object.defineProperty(exports, "Picker", {
    enumerable: true,
    get: function () {
      return _exportsPicker2.default;
    }
  });
  Object.defineProperty(exports, "Pressable", {
    enumerable: true,
    get: function () {
      return _exportsPressable2.default;
    }
  });
  Object.defineProperty(exports, "ProgressBar", {
    enumerable: true,
    get: function () {
      return _exportsProgressBar2.default;
    }
  });
  Object.defineProperty(exports, "RefreshControl", {
    enumerable: true,
    get: function () {
      return _exportsRefreshControl2.default;
    }
  });
  Object.defineProperty(exports, "SafeAreaView", {
    enumerable: true,
    get: function () {
      return _exportsSafeAreaView2.default;
    }
  });
  Object.defineProperty(exports, "ScrollView", {
    enumerable: true,
    get: function () {
      return _exportsScrollView2.default;
    }
  });
  Object.defineProperty(exports, "SectionList", {
    enumerable: true,
    get: function () {
      return _exportsSectionList2.default;
    }
  });
  Object.defineProperty(exports, "StatusBar", {
    enumerable: true,
    get: function () {
      return _exportsStatusBar2.default;
    }
  });
  Object.defineProperty(exports, "Switch", {
    enumerable: true,
    get: function () {
      return _exportsSwitch2.default;
    }
  });
  Object.defineProperty(exports, "Text", {
    enumerable: true,
    get: function () {
      return _exportsText2.default;
    }
  });
  Object.defineProperty(exports, "TextInput", {
    enumerable: true,
    get: function () {
      return _exportsTextInput2.default;
    }
  });
  Object.defineProperty(exports, "Touchable", {
    enumerable: true,
    get: function () {
      return _exportsTouchable2.default;
    }
  });
  Object.defineProperty(exports, "TouchableHighlight", {
    enumerable: true,
    get: function () {
      return _exportsTouchableHighlight2.default;
    }
  });
  Object.defineProperty(exports, "TouchableNativeFeedback", {
    enumerable: true,
    get: function () {
      return _exportsTouchableNativeFeedback2.default;
    }
  });
  Object.defineProperty(exports, "TouchableOpacity", {
    enumerable: true,
    get: function () {
      return _exportsTouchableOpacity2.default;
    }
  });
  Object.defineProperty(exports, "TouchableWithoutFeedback", {
    enumerable: true,
    get: function () {
      return _exportsTouchableWithoutFeedback2.default;
    }
  });
  Object.defineProperty(exports, "View", {
    enumerable: true,
    get: function () {
      return _exportsView2.default;
    }
  });
  Object.defineProperty(exports, "VirtualizedList", {
    enumerable: true,
    get: function () {
      return _exportsVirtualizedList2.default;
    }
  });
  Object.defineProperty(exports, "YellowBox", {
    enumerable: true,
    get: function () {
      return _exportsYellowBox2.default;
    }
  });
  Object.defineProperty(exports, "LogBox", {
    enumerable: true,
    get: function () {
      return _exportsLogBox2.default;
    }
  });
  Object.defineProperty(exports, "DeviceEventEmitter", {
    enumerable: true,
    get: function () {
      return _exportsDeviceEventEmitter2.default;
    }
  });
  Object.defineProperty(exports, "useColorScheme", {
    enumerable: true,
    get: function () {
      return _exportsUseColorScheme2.default;
    }
  });
  Object.defineProperty(exports, "useLocaleContext", {
    enumerable: true,
    get: function () {
      return _exportsUseLocaleContext2.default;
    }
  });
  Object.defineProperty(exports, "useWindowDimensions", {
    enumerable: true,
    get: function () {
      return _exportsUseWindowDimensions2.default;
    }
  });
  var _exportsCreateElement = require(_dependencyMap[0]);
  var _exportsCreateElement2 = _interopDefault(_exportsCreateElement);
  var _exportsFindNodeHandle = require(_dependencyMap[1]);
  var _exportsFindNodeHandle2 = _interopDefault(_exportsFindNodeHandle);
  var _exportsProcessColor = require(_dependencyMap[2]);
  var _exportsProcessColor2 = _interopDefault(_exportsProcessColor);
  var _exportsRender = require(_dependencyMap[3]);
  var _exportsRender2 = _interopDefault(_exportsRender);
  var _exportsUnmountComponentAtNode = require(_dependencyMap[4]);
  var _exportsUnmountComponentAtNode2 = _interopDefault(_exportsUnmountComponentAtNode);
  var _exportsNativeModules = require(_dependencyMap[5]);
  var _exportsNativeModules2 = _interopDefault(_exportsNativeModules);
  var _exportsAccessibilityInfo = require(_dependencyMap[6]);
  var _exportsAccessibilityInfo2 = _interopDefault(_exportsAccessibilityInfo);
  var _exportsAlert = require(_dependencyMap[7]);
  var _exportsAlert2 = _interopDefault(_exportsAlert);
  var _exportsAnimated = require(_dependencyMap[8]);
  var _exportsAnimated2 = _interopDefault(_exportsAnimated);
  var _exportsAppearance = require(_dependencyMap[9]);
  var _exportsAppearance2 = _interopDefault(_exportsAppearance);
  var _exportsAppRegistry = require(_dependencyMap[10]);
  var _exportsAppRegistry2 = _interopDefault(_exportsAppRegistry);
  var _exportsAppState = require(_dependencyMap[11]);
  var _exportsAppState2 = _interopDefault(_exportsAppState);
  var _exportsBackHandler = require(_dependencyMap[12]);
  var _exportsBackHandler2 = _interopDefault(_exportsBackHandler);
  var _exportsClipboard = require(_dependencyMap[13]);
  var _exportsClipboard2 = _interopDefault(_exportsClipboard);
  var _exportsDimensions = require(_dependencyMap[14]);
  var _exportsDimensions2 = _interopDefault(_exportsDimensions);
  var _exportsEasing = require(_dependencyMap[15]);
  var _exportsEasing2 = _interopDefault(_exportsEasing);
  var _exportsI18nManager = require(_dependencyMap[16]);
  var _exportsI18nManager2 = _interopDefault(_exportsI18nManager);
  var _exportsKeyboard = require(_dependencyMap[17]);
  var _exportsKeyboard2 = _interopDefault(_exportsKeyboard);
  var _exportsInteractionManager = require(_dependencyMap[18]);
  var _exportsInteractionManager2 = _interopDefault(_exportsInteractionManager);
  var _exportsLayoutAnimation = require(_dependencyMap[19]);
  var _exportsLayoutAnimation2 = _interopDefault(_exportsLayoutAnimation);
  var _exportsLinking = require(_dependencyMap[20]);
  var _exportsLinking2 = _interopDefault(_exportsLinking);
  var _exportsNativeEventEmitter = require(_dependencyMap[21]);
  var _exportsNativeEventEmitter2 = _interopDefault(_exportsNativeEventEmitter);
  var _exportsPanResponder = require(_dependencyMap[22]);
  var _exportsPanResponder2 = _interopDefault(_exportsPanResponder);
  var _exportsPixelRatio = require(_dependencyMap[23]);
  var _exportsPixelRatio2 = _interopDefault(_exportsPixelRatio);
  var _exportsPlatform = require(_dependencyMap[24]);
  var _exportsPlatform2 = _interopDefault(_exportsPlatform);
  var _exportsShare = require(_dependencyMap[25]);
  var _exportsShare2 = _interopDefault(_exportsShare);
  var _exportsStyleSheet = require(_dependencyMap[26]);
  var _exportsStyleSheet2 = _interopDefault(_exportsStyleSheet);
  var _exportsUIManager = require(_dependencyMap[27]);
  var _exportsUIManager2 = _interopDefault(_exportsUIManager);
  var _exportsVibration = require(_dependencyMap[28]);
  var _exportsVibration2 = _interopDefault(_exportsVibration);
  var _exportsActivityIndicator = require(_dependencyMap[29]);
  var _exportsActivityIndicator2 = _interopDefault(_exportsActivityIndicator);
  var _exportsButton = require(_dependencyMap[30]);
  var _exportsButton2 = _interopDefault(_exportsButton);
  var _exportsCheckBox = require(_dependencyMap[31]);
  var _exportsCheckBox2 = _interopDefault(_exportsCheckBox);
  var _exportsFlatList = require(_dependencyMap[32]);
  var _exportsFlatList2 = _interopDefault(_exportsFlatList);
  var _exportsImage = require(_dependencyMap[33]);
  var _exportsImage2 = _interopDefault(_exportsImage);
  var _exportsImageBackground = require(_dependencyMap[34]);
  var _exportsImageBackground2 = _interopDefault(_exportsImageBackground);
  var _exportsKeyboardAvoidingView = require(_dependencyMap[35]);
  var _exportsKeyboardAvoidingView2 = _interopDefault(_exportsKeyboardAvoidingView);
  var _exportsModal = require(_dependencyMap[36]);
  var _exportsModal2 = _interopDefault(_exportsModal);
  var _exportsPicker = require(_dependencyMap[37]);
  var _exportsPicker2 = _interopDefault(_exportsPicker);
  var _exportsPressable = require(_dependencyMap[38]);
  var _exportsPressable2 = _interopDefault(_exportsPressable);
  var _exportsProgressBar = require(_dependencyMap[39]);
  var _exportsProgressBar2 = _interopDefault(_exportsProgressBar);
  var _exportsRefreshControl = require(_dependencyMap[40]);
  var _exportsRefreshControl2 = _interopDefault(_exportsRefreshControl);
  var _exportsSafeAreaView = require(_dependencyMap[41]);
  var _exportsSafeAreaView2 = _interopDefault(_exportsSafeAreaView);
  var _exportsScrollView = require(_dependencyMap[42]);
  var _exportsScrollView2 = _interopDefault(_exportsScrollView);
  var _exportsSectionList = require(_dependencyMap[43]);
  var _exportsSectionList2 = _interopDefault(_exportsSectionList);
  var _exportsStatusBar = require(_dependencyMap[44]);
  var _exportsStatusBar2 = _interopDefault(_exportsStatusBar);
  var _exportsSwitch = require(_dependencyMap[45]);
  var _exportsSwitch2 = _interopDefault(_exportsSwitch);
  var _exportsText = require(_dependencyMap[46]);
  var _exportsText2 = _interopDefault(_exportsText);
  var _exportsTextInput = require(_dependencyMap[47]);
  var _exportsTextInput2 = _interopDefault(_exportsTextInput);
  var _exportsTouchable = require(_dependencyMap[48]);
  var _exportsTouchable2 = _interopDefault(_exportsTouchable);
  var _exportsTouchableHighlight = require(_dependencyMap[49]);
  var _exportsTouchableHighlight2 = _interopDefault(_exportsTouchableHighlight);
  var _exportsTouchableNativeFeedback = require(_dependencyMap[50]);
  var _exportsTouchableNativeFeedback2 = _interopDefault(_exportsTouchableNativeFeedback);
  var _exportsTouchableOpacity = require(_dependencyMap[51]);
  var _exportsTouchableOpacity2 = _interopDefault(_exportsTouchableOpacity);
  var _exportsTouchableWithoutFeedback = require(_dependencyMap[52]);
  var _exportsTouchableWithoutFeedback2 = _interopDefault(_exportsTouchableWithoutFeedback);
  var _exportsView = require(_dependencyMap[53]);
  var _exportsView2 = _interopDefault(_exportsView);
  var _exportsVirtualizedList = require(_dependencyMap[54]);
  var _exportsVirtualizedList2 = _interopDefault(_exportsVirtualizedList);
  var _exportsYellowBox = require(_dependencyMap[55]);
  var _exportsYellowBox2 = _interopDefault(_exportsYellowBox);
  var _exportsLogBox = require(_dependencyMap[56]);
  var _exportsLogBox2 = _interopDefault(_exportsLogBox);
  var _exportsDeviceEventEmitter = require(_dependencyMap[57]);
  var _exportsDeviceEventEmitter2 = _interopDefault(_exportsDeviceEventEmitter);
  var _exportsUseColorScheme = require(_dependencyMap[58]);
  var _exportsUseColorScheme2 = _interopDefault(_exportsUseColorScheme);
  var _exportsUseLocaleContext = require(_dependencyMap[59]);
  var _exportsUseLocaleContext2 = _interopDefault(_exportsUseLocaleContext);
  var _exportsUseWindowDimensions = require(_dependencyMap[60]);
  var _exportsUseWindowDimensions2 = _interopDefault(_exportsUseWindowDimensions);
},115,[116,124,51,30,26,125,131,132,133,237,19,238,239,240,162,234,241,242,169,243,245,246,247,209,96,250,43,126,251,252,253,257,136,206,258,259,260,265,267,272,160,273,161,212,274,275,216,277,278,282,283,254,285,138,286,287,288,289,290,291,292]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _modulesAccessibilityUtil = require(_dependencyMap[0]);
  var AccessibilityUtil = _interopDefault(_modulesAccessibilityUtil);
  var _modulesCreateDOMProps = require(_dependencyMap[1]);
  var createDOMProps = _interopDefault(_modulesCreateDOMProps);
  var _react = require(_dependencyMap[2]);
  var React = _interopDefault(_react);
  var _modulesUseLocale = require(_dependencyMap[3]);
  var createElement = (component, props, options) => {
    // Use equivalent platform elements where possible.
    var accessibilityComponent;
    if (component && component.constructor === String) {
      accessibilityComponent = AccessibilityUtil.default.propsToAccessibilityComponent(props);
    }
    var Component = accessibilityComponent || component;
    var domProps = (0, createDOMProps.default)(Component, props, options);
    var element = /*#__PURE__*/React.default.createElement(Component, domProps);

    // Update locale context if element's writing direction prop changes
    var elementWithLocaleProvider = domProps.dir ? /*#__PURE__*/React.default.createElement(_modulesUseLocale.LocaleProvider, {
      children: element,
      direction: domProps.dir,
      locale: domProps.lang
    }) : element;
    return elementWithLocaleProvider;
  };
  var _default = createElement;
},116,[117,121,35,122]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _isDisabled = require(_dependencyMap[0]);
  var isDisabled = _interopDefault(_isDisabled);
  var _propsToAccessibilityComponent = require(_dependencyMap[1]);
  var propsToAccessibilityComponent = _interopDefault(_propsToAccessibilityComponent);
  var _propsToAriaRole = require(_dependencyMap[2]);
  var propsToAriaRole = _interopDefault(_propsToAriaRole);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var AccessibilityUtil = {
    isDisabled: isDisabled.default,
    propsToAccessibilityComponent: propsToAccessibilityComponent.default,
    propsToAriaRole: propsToAriaRole.default
  };
  var _default = AccessibilityUtil;
},117,[118,119,120]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var isDisabled = props => props.disabled || Array.isArray(props.accessibilityStates) && props.accessibilityStates.indexOf('disabled') > -1;
  var _default = isDisabled;
},118,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _propsToAriaRole = require(_dependencyMap[0]);
  var propsToAriaRole = _interopDefault(_propsToAriaRole);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var roleComponents = {
    article: 'article',
    banner: 'header',
    blockquote: 'blockquote',
    button: 'button',
    code: 'code',
    complementary: 'aside',
    contentinfo: 'footer',
    deletion: 'del',
    emphasis: 'em',
    figure: 'figure',
    insertion: 'ins',
    form: 'form',
    list: 'ul',
    listitem: 'li',
    main: 'main',
    navigation: 'nav',
    paragraph: 'p',
    region: 'section',
    strong: 'strong'
  };
  var emptyObject = {};
  var propsToAccessibilityComponent = function propsToAccessibilityComponent(props) {
    if (props === undefined) {
      props = emptyObject;
    }
    var roleProp = props.role || props.accessibilityRole;
    // special-case for "label" role which doesn't map to an ARIA role
    if (roleProp === 'label') {
      return 'label';
    }
    var role = (0, propsToAriaRole.default)(props);
    if (role) {
      if (role === 'heading') {
        var level = props.accessibilityLevel || props['aria-level'];
        if (level != null) {
          return "h" + level;
        }
        return 'h1';
      }
      return roleComponents[role];
    }
  };
  var _default = propsToAccessibilityComponent;
},119,[120]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var accessibilityRoleToWebRole = {
    adjustable: 'slider',
    button: 'button',
    header: 'heading',
    image: 'img',
    imagebutton: null,
    keyboardkey: null,
    label: null,
    link: 'link',
    none: 'presentation',
    search: 'search',
    summary: 'region',
    text: null
  };
  var propsToAriaRole = _ref => {
    var accessibilityRole = _ref.accessibilityRole,
      role = _ref.role;
    var _role = role || accessibilityRole;
    if (_role) {
      var inferredRole = accessibilityRoleToWebRole[_role];
      if (inferredRole !== null) {
        // ignore roles that don't map to web
        return inferredRole || _role;
      }
    }
  };
  var _default = propsToAriaRole;
},120,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _AccessibilityUtil = require(_dependencyMap[2]);
  var AccessibilityUtil = _interopDefault(_AccessibilityUtil);
  var _exportsStyleSheet = require(_dependencyMap[3]);
  var StyleSheet = _interopDefault(_exportsStyleSheet);
  var _warnOnce = require(_dependencyMap[4]);
  var _excluded = ["aria-activedescendant", "accessibilityActiveDescendant", "aria-atomic", "accessibilityAtomic", "aria-autocomplete", "accessibilityAutoComplete", "aria-busy", "accessibilityBusy", "aria-checked", "accessibilityChecked", "aria-colcount", "accessibilityColumnCount", "aria-colindex", "accessibilityColumnIndex", "aria-colspan", "accessibilityColumnSpan", "aria-controls", "accessibilityControls", "aria-current", "accessibilityCurrent", "aria-describedby", "accessibilityDescribedBy", "aria-details", "accessibilityDetails", "aria-disabled", "accessibilityDisabled", "aria-errormessage", "accessibilityErrorMessage", "aria-expanded", "accessibilityExpanded", "aria-flowto", "accessibilityFlowTo", "aria-haspopup", "accessibilityHasPopup", "aria-hidden", "accessibilityHidden", "aria-invalid", "accessibilityInvalid", "aria-keyshortcuts", "accessibilityKeyShortcuts", "aria-label", "accessibilityLabel", "aria-labelledby", "accessibilityLabelledBy", "aria-level", "accessibilityLevel", "aria-live", "accessibilityLiveRegion", "aria-modal", "accessibilityModal", "aria-multiline", "accessibilityMultiline", "aria-multiselectable", "accessibilityMultiSelectable", "aria-orientation", "accessibilityOrientation", "aria-owns", "accessibilityOwns", "aria-placeholder", "accessibilityPlaceholder", "aria-posinset", "accessibilityPosInSet", "aria-pressed", "accessibilityPressed", "aria-readonly", "accessibilityReadOnly", "aria-required", "accessibilityRequired", "role", "accessibilityRole", "aria-roledescription", "accessibilityRoleDescription", "aria-rowcount", "accessibilityRowCount", "aria-rowindex", "accessibilityRowIndex", "aria-rowspan", "accessibilityRowSpan", "aria-selected", "accessibilitySelected", "aria-setsize", "accessibilitySetSize", "aria-sort", "accessibilitySort", "aria-valuemax", "accessibilityValueMax", "aria-valuemin", "accessibilityValueMin", "aria-valuenow", "accessibilityValueNow", "aria-valuetext", "accessibilityValueText", "dataSet", "focusable", "id", "nativeID", "pointerEvents", "style", "tabIndex", "testID"];
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var emptyObject = {};
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var isArray = Array.isArray;
  var uppercasePattern = /[A-Z]/g;
  function toHyphenLower(match) {
    return '-' + match.toLowerCase();
  }
  function hyphenateString(str) {
    return str.replace(uppercasePattern, toHyphenLower);
  }
  function processIDRefList(idRefList) {
    return isArray(idRefList) ? idRefList.join(' ') : idRefList;
  }
  var pointerEventsStyles = StyleSheet.default.create({
    auto: {
      pointerEvents: 'auto'
    },
    'box-none': {
      pointerEvents: 'box-none'
    },
    'box-only': {
      pointerEvents: 'box-only'
    },
    none: {
      pointerEvents: 'none'
    }
  });
  var createDOMProps = (elementType, props, options) => {
    if (!props) {
      props = emptyObject;
    }
    var _props = props,
      ariaActiveDescendant = _props['aria-activedescendant'],
      accessibilityActiveDescendant = _props.accessibilityActiveDescendant,
      ariaAtomic = _props['aria-atomic'],
      accessibilityAtomic = _props.accessibilityAtomic,
      ariaAutoComplete = _props['aria-autocomplete'],
      accessibilityAutoComplete = _props.accessibilityAutoComplete,
      ariaBusy = _props['aria-busy'],
      accessibilityBusy = _props.accessibilityBusy,
      ariaChecked = _props['aria-checked'],
      accessibilityChecked = _props.accessibilityChecked,
      ariaColumnCount = _props['aria-colcount'],
      accessibilityColumnCount = _props.accessibilityColumnCount,
      ariaColumnIndex = _props['aria-colindex'],
      accessibilityColumnIndex = _props.accessibilityColumnIndex,
      ariaColumnSpan = _props['aria-colspan'],
      accessibilityColumnSpan = _props.accessibilityColumnSpan,
      ariaControls = _props['aria-controls'],
      accessibilityControls = _props.accessibilityControls,
      ariaCurrent = _props['aria-current'],
      accessibilityCurrent = _props.accessibilityCurrent,
      ariaDescribedBy = _props['aria-describedby'],
      accessibilityDescribedBy = _props.accessibilityDescribedBy,
      ariaDetails = _props['aria-details'],
      accessibilityDetails = _props.accessibilityDetails,
      ariaDisabled = _props['aria-disabled'],
      accessibilityDisabled = _props.accessibilityDisabled,
      ariaErrorMessage = _props['aria-errormessage'],
      accessibilityErrorMessage = _props.accessibilityErrorMessage,
      ariaExpanded = _props['aria-expanded'],
      accessibilityExpanded = _props.accessibilityExpanded,
      ariaFlowTo = _props['aria-flowto'],
      accessibilityFlowTo = _props.accessibilityFlowTo,
      ariaHasPopup = _props['aria-haspopup'],
      accessibilityHasPopup = _props.accessibilityHasPopup,
      ariaHidden = _props['aria-hidden'],
      accessibilityHidden = _props.accessibilityHidden,
      ariaInvalid = _props['aria-invalid'],
      accessibilityInvalid = _props.accessibilityInvalid,
      ariaKeyShortcuts = _props['aria-keyshortcuts'],
      accessibilityKeyShortcuts = _props.accessibilityKeyShortcuts,
      ariaLabel = _props['aria-label'],
      accessibilityLabel = _props.accessibilityLabel,
      ariaLabelledBy = _props['aria-labelledby'],
      accessibilityLabelledBy = _props.accessibilityLabelledBy,
      ariaLevel = _props['aria-level'],
      accessibilityLevel = _props.accessibilityLevel,
      ariaLive = _props['aria-live'],
      accessibilityLiveRegion = _props.accessibilityLiveRegion,
      ariaModal = _props['aria-modal'],
      accessibilityModal = _props.accessibilityModal,
      ariaMultiline = _props['aria-multiline'],
      accessibilityMultiline = _props.accessibilityMultiline,
      ariaMultiSelectable = _props['aria-multiselectable'],
      accessibilityMultiSelectable = _props.accessibilityMultiSelectable,
      ariaOrientation = _props['aria-orientation'],
      accessibilityOrientation = _props.accessibilityOrientation,
      ariaOwns = _props['aria-owns'],
      accessibilityOwns = _props.accessibilityOwns,
      ariaPlaceholder = _props['aria-placeholder'],
      accessibilityPlaceholder = _props.accessibilityPlaceholder,
      ariaPosInSet = _props['aria-posinset'],
      accessibilityPosInSet = _props.accessibilityPosInSet,
      ariaPressed = _props['aria-pressed'],
      accessibilityPressed = _props.accessibilityPressed,
      ariaReadOnly = _props['aria-readonly'],
      accessibilityReadOnly = _props.accessibilityReadOnly,
      ariaRequired = _props['aria-required'],
      accessibilityRequired = _props.accessibilityRequired,
      ariaRole = _props.role,
      accessibilityRole = _props.accessibilityRole,
      ariaRoleDescription = _props['aria-roledescription'],
      accessibilityRoleDescription = _props.accessibilityRoleDescription,
      ariaRowCount = _props['aria-rowcount'],
      accessibilityRowCount = _props.accessibilityRowCount,
      ariaRowIndex = _props['aria-rowindex'],
      accessibilityRowIndex = _props.accessibilityRowIndex,
      ariaRowSpan = _props['aria-rowspan'],
      accessibilityRowSpan = _props.accessibilityRowSpan,
      ariaSelected = _props['aria-selected'],
      accessibilitySelected = _props.accessibilitySelected,
      ariaSetSize = _props['aria-setsize'],
      accessibilitySetSize = _props.accessibilitySetSize,
      ariaSort = _props['aria-sort'],
      accessibilitySort = _props.accessibilitySort,
      ariaValueMax = _props['aria-valuemax'],
      accessibilityValueMax = _props.accessibilityValueMax,
      ariaValueMin = _props['aria-valuemin'],
      accessibilityValueMin = _props.accessibilityValueMin,
      ariaValueNow = _props['aria-valuenow'],
      accessibilityValueNow = _props.accessibilityValueNow,
      ariaValueText = _props['aria-valuetext'],
      accessibilityValueText = _props.accessibilityValueText,
      dataSet = _props.dataSet,
      focusable = _props.focusable,
      id = _props.id,
      nativeID = _props.nativeID,
      pointerEvents = _props.pointerEvents,
      style = _props.style,
      tabIndex = _props.tabIndex,
      testID = _props.testID,
      domProps = (0, _objectWithoutPropertiesLoose.default)(_props, _excluded);

    /*
    if (accessibilityDisabled != null) {
      warnOnce('accessibilityDisabled', `accessibilityDisabled is deprecated.`);
    }
    */
    var disabled = ariaDisabled || accessibilityDisabled;
    var role = AccessibilityUtil.default.propsToAriaRole(props);

    // ACCESSIBILITY
    /*
    if (accessibilityActiveDescendant != null) {
      warnOnce(
        'accessibilityActiveDescendant',
        `accessibilityActiveDescendant is deprecated. Use aria-activedescendant.`
      );
    }
    */
    var _ariaActiveDescendant = ariaActiveDescendant != null ? ariaActiveDescendant : accessibilityActiveDescendant;
    if (_ariaActiveDescendant != null) {
      domProps['aria-activedescendant'] = _ariaActiveDescendant;
    }

    /*
    if (accessibilityAtomic != null) {
      warnOnce(
        'accessibilityAtomic',
        `accessibilityAtomic is deprecated. Use aria-atomic.`
      );
    }
    */
    var _ariaAtomic = ariaAtomic != null ? ariaActiveDescendant : accessibilityAtomic;
    if (_ariaAtomic != null) {
      domProps['aria-atomic'] = _ariaAtomic;
    }

    /*
    if (accessibilityAutoComplete != null) {
      warnOnce(
        'accessibilityAutoComplete',
        `accessibilityAutoComplete is deprecated. Use aria-autocomplete.`
      );
    }
    */
    var _ariaAutoComplete = ariaAutoComplete != null ? ariaAutoComplete : accessibilityAutoComplete;
    if (_ariaAutoComplete != null) {
      domProps['aria-autocomplete'] = _ariaAutoComplete;
    }

    /*
    if (accessibilityBusy != null) {
      warnOnce(
        'accessibilityBusy',
        `accessibilityBusy is deprecated. Use aria-busy.`
      );
    }
    */
    var _ariaBusy = ariaBusy != null ? ariaBusy : accessibilityBusy;
    if (_ariaBusy != null) {
      domProps['aria-busy'] = _ariaBusy;
    }

    /*
    if (accessibilityChecked != null) {
      warnOnce(
        'accessibilityChecked',
        `accessibilityChecked is deprecated. Use aria-checked.`
      );
    }
    */
    var _ariaChecked = ariaChecked != null ? ariaChecked : accessibilityChecked;
    if (_ariaChecked != null) {
      domProps['aria-checked'] = _ariaChecked;
    }

    /*
    if (accessibilityColumnCount != null) {
      warnOnce(
        'accessibilityColumnCount',
        `accessibilityColumnCount is deprecated. Use aria-colcount.`
      );
    }
    */
    var _ariaColumnCount = ariaColumnCount != null ? ariaColumnCount : accessibilityColumnCount;
    if (_ariaColumnCount != null) {
      domProps['aria-colcount'] = _ariaColumnCount;
    }

    /*
    if (accessibilityColumnIndex != null) {
      warnOnce(
        'accessibilityColumnIndex',
        `accessibilityColumnIndex is deprecated. Use aria-colindex.`
      );
    }
    */
    var _ariaColumnIndex = ariaColumnIndex != null ? ariaColumnIndex : accessibilityColumnIndex;
    if (_ariaColumnIndex != null) {
      domProps['aria-colindex'] = _ariaColumnIndex;
    }

    /*
    if (accessibilityColumnSpan != null) {
      warnOnce(
        'accessibilityColumnSpan',
        `accessibilityColumnSpan is deprecated. Use aria-colspan.`
      );
    }
    */
    var _ariaColumnSpan = ariaColumnSpan != null ? ariaColumnSpan : accessibilityColumnSpan;
    if (_ariaColumnSpan != null) {
      domProps['aria-colspan'] = _ariaColumnSpan;
    }

    /*
    if (accessibilityControls != null) {
      warnOnce(
        'accessibilityControls',
        `accessibilityControls is deprecated. Use aria-controls.`
      );
    }
    */
    var _ariaControls = ariaControls != null ? ariaControls : accessibilityControls;
    if (_ariaControls != null) {
      domProps['aria-controls'] = processIDRefList(_ariaControls);
    }

    /*
    if (accessibilityCurrent != null) {
      warnOnce(
        'accessibilityCurrent',
        `accessibilityCurrent is deprecated. Use aria-current.`
      );
    }
    */
    var _ariaCurrent = ariaCurrent != null ? ariaCurrent : accessibilityCurrent;
    if (_ariaCurrent != null) {
      domProps['aria-current'] = _ariaCurrent;
    }

    /*
    if (accessibilityDescribedBy != null) {
      warnOnce(
        'accessibilityDescribedBy',
        `accessibilityDescribedBy is deprecated. Use aria-describedby.`
      );
    }
    */
    var _ariaDescribedBy = ariaDescribedBy != null ? ariaDescribedBy : accessibilityDescribedBy;
    if (_ariaDescribedBy != null) {
      domProps['aria-describedby'] = processIDRefList(_ariaDescribedBy);
    }

    /*
    if (accessibilityDetails != null) {
      warnOnce(
        'accessibilityDetails',
        `accessibilityDetails is deprecated. Use aria-details.`
      );
    }
    */
    var _ariaDetails = ariaDetails != null ? ariaDetails : accessibilityDetails;
    if (_ariaDetails != null) {
      domProps['aria-details'] = _ariaDetails;
    }
    if (disabled === true) {
      domProps['aria-disabled'] = true;
      // Enhance with native semantics
      if (elementType === 'button' || elementType === 'form' || elementType === 'input' || elementType === 'select' || elementType === 'textarea') {
        domProps.disabled = true;
      }
    }

    /*
    if (accessibilityErrorMessage != null) {
      warnOnce(
        'accessibilityErrorMessage',
        `accessibilityErrorMessage is deprecated. Use aria-errormessage.`
      );
    }
    */
    var _ariaErrorMessage = ariaErrorMessage != null ? ariaErrorMessage : accessibilityErrorMessage;
    if (_ariaErrorMessage != null) {
      domProps['aria-errormessage'] = _ariaErrorMessage;
    }

    /*
    if (accessibilityExpanded != null) {
      warnOnce(
        'accessibilityExpanded',
        `accessibilityExpanded is deprecated. Use aria-expanded.`
      );
    }
    */
    var _ariaExpanded = ariaExpanded != null ? ariaExpanded : accessibilityExpanded;
    if (_ariaExpanded != null) {
      domProps['aria-expanded'] = _ariaExpanded;
    }

    /*
    if (accessibilityFlowTo != null) {
      warnOnce(
        'accessibilityFlowTo',
        `accessibilityFlowTo is deprecated. Use aria-flowto.`
      );
    }
    */
    var _ariaFlowTo = ariaFlowTo != null ? ariaFlowTo : accessibilityFlowTo;
    if (_ariaFlowTo != null) {
      domProps['aria-flowto'] = processIDRefList(_ariaFlowTo);
    }

    /*
    if (accessibilityHasPopup != null) {
      warnOnce(
        'accessibilityHasPopup',
        `accessibilityHasPopup is deprecated. Use aria-haspopup.`
      );
    }
    */
    var _ariaHasPopup = ariaHasPopup != null ? ariaHasPopup : accessibilityHasPopup;
    if (_ariaHasPopup != null) {
      domProps['aria-haspopup'] = _ariaHasPopup;
    }

    /*
    if (accessibilityHidden != null) {
      warnOnce(
        'accessibilityHidden',
        `accessibilityHidden is deprecated. Use aria-hidden.`
      );
    }
    */
    var _ariaHidden = ariaHidden != null ? ariaHidden : accessibilityHidden;
    if (_ariaHidden === true) {
      domProps['aria-hidden'] = _ariaHidden;
    }

    /*
    if (accessibilityInvalid != null) {
      warnOnce(
        'accessibilityInvalid',
        `accessibilityInvalid is deprecated. Use aria-invalid.`
      );
    }
    */
    var _ariaInvalid = ariaInvalid != null ? ariaInvalid : accessibilityInvalid;
    if (_ariaInvalid != null) {
      domProps['aria-invalid'] = _ariaInvalid;
    }

    /*
    if (accessibilityKeyShortcuts != null) {
      warnOnce(
        'accessibilityKeyShortcuts',
        `accessibilityKeyShortcuts is deprecated. Use aria-keyshortcuts.`
      );
    }
    */
    var _ariaKeyShortcuts = ariaKeyShortcuts != null ? ariaKeyShortcuts : accessibilityKeyShortcuts;
    if (_ariaKeyShortcuts != null) {
      domProps['aria-keyshortcuts'] = processIDRefList(_ariaKeyShortcuts);
    }

    /*
    if (accessibilityLabel != null) {
      warnOnce(
        'accessibilityLabel',
        `accessibilityLabel is deprecated. Use aria-label.`
      );
    }
    */
    var _ariaLabel = ariaLabel != null ? ariaLabel : accessibilityLabel;
    if (_ariaLabel != null) {
      domProps['aria-label'] = _ariaLabel;
    }

    /*
    if (accessibilityLabelledBy != null) {
      warnOnce(
        'accessibilityLabelledBy',
        `accessibilityLabelledBy is deprecated. Use aria-labelledby.`
      );
    }
    */
    var _ariaLabelledBy = ariaLabelledBy != null ? ariaLabelledBy : accessibilityLabelledBy;
    if (_ariaLabelledBy != null) {
      domProps['aria-labelledby'] = processIDRefList(_ariaLabelledBy);
    }

    /*
    if (accessibilityLevel != null) {
      warnOnce(
        'accessibilityLevel',
        `accessibilityLevel is deprecated. Use aria-level.`
      );
    }
    */
    var _ariaLevel = ariaLevel != null ? ariaLevel : accessibilityLevel;
    if (_ariaLevel != null) {
      domProps['aria-level'] = _ariaLevel;
    }

    /*
    if (accessibilityLiveRegion != null) {
      warnOnce(
        'accessibilityLiveRegion',
        `accessibilityLiveRegion is deprecated. Use aria-live.`
      );
    }
    */
    var _ariaLive = ariaLive != null ? ariaLive : accessibilityLiveRegion;
    if (_ariaLive != null) {
      domProps['aria-live'] = _ariaLive === 'none' ? 'off' : _ariaLive;
    }

    /*
    if (accessibilityModal != null) {
      warnOnce(
        'accessibilityModal',
        `accessibilityModal is deprecated. Use aria-modal.`
      );
    }
    */
    var _ariaModal = ariaModal != null ? ariaModal : accessibilityModal;
    if (_ariaModal != null) {
      domProps['aria-modal'] = _ariaModal;
    }

    /*
    if (accessibilityMultiline != null) {
      warnOnce(
        'accessibilityMultiline',
        `accessibilityMultiline is deprecated. Use aria-multiline.`
      );
    }
    */
    var _ariaMultiline = ariaMultiline != null ? ariaMultiline : accessibilityMultiline;
    if (_ariaMultiline != null) {
      domProps['aria-multiline'] = _ariaMultiline;
    }

    /*
    if (accessibilityMultiSelectable != null) {
      warnOnce(
        'accessibilityMultiSelectable',
        `accessibilityMultiSelectable is deprecated. Use aria-multiselectable.`
      );
    }
    */
    var _ariaMultiSelectable = ariaMultiSelectable != null ? ariaMultiSelectable : accessibilityMultiSelectable;
    if (_ariaMultiSelectable != null) {
      domProps['aria-multiselectable'] = _ariaMultiSelectable;
    }

    /*
    if (accessibilityOrientation != null) {
      warnOnce(
        'accessibilityOrientation',
        `accessibilityOrientation is deprecated. Use aria-orientation.`
      );
    }
    */
    var _ariaOrientation = ariaOrientation != null ? ariaOrientation : accessibilityOrientation;
    if (_ariaOrientation != null) {
      domProps['aria-orientation'] = _ariaOrientation;
    }

    /*
    if (accessibilityOwns != null) {
      warnOnce(
        'accessibilityOwns',
        `accessibilityOwns is deprecated. Use aria-owns.`
      );
    }
    */
    var _ariaOwns = ariaOwns != null ? ariaOwns : accessibilityOwns;
    if (_ariaOwns != null) {
      domProps['aria-owns'] = processIDRefList(_ariaOwns);
    }

    /*
    if (accessibilityPlaceholder != null) {
      warnOnce(
        'accessibilityPlaceholder',
        `accessibilityPlaceholder is deprecated. Use aria-placeholder.`
      );
    }
    */
    var _ariaPlaceholder = ariaPlaceholder != null ? ariaPlaceholder : accessibilityPlaceholder;
    if (_ariaPlaceholder != null) {
      domProps['aria-placeholder'] = _ariaPlaceholder;
    }

    /*
    if (accessibilityPosInSet != null) {
      warnOnce(
        'accessibilityPosInSet',
        `accessibilityPosInSet is deprecated. Use aria-posinset.`
      );
    }
    */
    var _ariaPosInSet = ariaPosInSet != null ? ariaPosInSet : accessibilityPosInSet;
    if (_ariaPosInSet != null) {
      domProps['aria-posinset'] = _ariaPosInSet;
    }

    /*
    if (accessibilityPressed != null) {
      warnOnce(
        'accessibilityPressed',
        `accessibilityPressed is deprecated. Use aria-pressed.`
      );
    }
    */
    var _ariaPressed = ariaPressed != null ? ariaPressed : accessibilityPressed;
    if (_ariaPressed != null) {
      domProps['aria-pressed'] = _ariaPressed;
    }

    /*
    if (accessibilityReadOnly != null) {
      warnOnce(
        'accessibilityReadOnly',
        `accessibilityReadOnly is deprecated. Use aria-readonly.`
      );
    }
    */
    var _ariaReadOnly = ariaReadOnly != null ? ariaReadOnly : accessibilityReadOnly;
    if (_ariaReadOnly != null) {
      domProps['aria-readonly'] = _ariaReadOnly;
      // Enhance with native semantics
      if (elementType === 'input' || elementType === 'select' || elementType === 'textarea') {
        domProps.readOnly = true;
      }
    }

    /*
    if (accessibilityRequired != null) {
      warnOnce(
        'accessibilityRequired',
        `accessibilityRequired is deprecated. Use aria-required.`
      );
    }
    */
    var _ariaRequired = ariaRequired != null ? ariaRequired : accessibilityRequired;
    if (_ariaRequired != null) {
      domProps['aria-required'] = _ariaRequired;
      // Enhance with native semantics
      if (elementType === 'input' || elementType === 'select' || elementType === 'textarea') {
        domProps.required = accessibilityRequired;
      }
    }

    /*
    if (accessibilityRole != null) {
      warnOnce('accessibilityRole', `accessibilityRole is deprecated. Use role.`);
    }
    */
    if (role != null) {
      // 'presentation' synonym has wider browser support
      domProps['role'] = role === 'none' ? 'presentation' : role;
    }

    /*
    if (accessibilityRoleDescription != null) {
      warnOnce(
        'accessibilityRoleDescription',
        `accessibilityRoleDescription is deprecated. Use aria-roledescription.`
      );
    }
    */
    var _ariaRoleDescription = ariaRoleDescription != null ? ariaRoleDescription : accessibilityRoleDescription;
    if (_ariaRoleDescription != null) {
      domProps['aria-roledescription'] = _ariaRoleDescription;
    }

    /*
    if (accessibilityRowCount != null) {
      warnOnce(
        'accessibilityRowCount',
        `accessibilityRowCount is deprecated. Use aria-rowcount.`
      );
    }
    */
    var _ariaRowCount = ariaRowCount != null ? ariaRowCount : accessibilityRowCount;
    if (_ariaRowCount != null) {
      domProps['aria-rowcount'] = _ariaRowCount;
    }

    /*
    if (accessibilityRowIndex != null) {
      warnOnce(
        'accessibilityRowIndex',
        `accessibilityRowIndex is deprecated. Use aria-rowindex.`
      );
    }
    */
    var _ariaRowIndex = ariaRowIndex != null ? ariaRowIndex : accessibilityRowIndex;
    if (_ariaRowIndex != null) {
      domProps['aria-rowindex'] = _ariaRowIndex;
    }

    /*
    if (accessibilityRowSpan != null) {
      warnOnce(
        'accessibilityRowSpan',
        `accessibilityRowSpan is deprecated. Use aria-rowspan.`
      );
    }
    */
    var _ariaRowSpan = ariaRowSpan != null ? ariaRowSpan : accessibilityRowSpan;
    if (_ariaRowSpan != null) {
      domProps['aria-rowspan'] = _ariaRowSpan;
    }

    /*
    if (accessibilitySelected != null) {
      warnOnce(
        'accessibilitySelected',
        `accessibilitySelected is deprecated. Use aria-selected.`
      );
    }
    */
    var _ariaSelected = ariaSelected != null ? ariaSelected : accessibilitySelected;
    if (_ariaSelected != null) {
      domProps['aria-selected'] = _ariaSelected;
    }

    /*
    if (accessibilitySetSize != null) {
      warnOnce(
        'accessibilitySetSize',
        `accessibilitySetSize is deprecated. Use aria-setsize.`
      );
    }
    */
    var _ariaSetSize = ariaSetSize != null ? ariaSetSize : accessibilitySetSize;
    if (_ariaSetSize != null) {
      domProps['aria-setsize'] = _ariaSetSize;
    }

    /*
    if (accessibilitySort != null) {
      warnOnce(
        'accessibilitySort',
        `accessibilitySort is deprecated. Use aria-sort.`
      );
    }
    */
    var _ariaSort = ariaSort != null ? ariaSort : accessibilitySort;
    if (_ariaSort != null) {
      domProps['aria-sort'] = _ariaSort;
    }

    /*
    if (accessibilityValueMax != null) {
      warnOnce(
        'accessibilityValueMax',
        `accessibilityValueMax is deprecated. Use aria-valuemax.`
      );
    }
    */
    var _ariaValueMax = ariaValueMax != null ? ariaValueMax : accessibilityValueMax;
    if (_ariaValueMax != null) {
      domProps['aria-valuemax'] = _ariaValueMax;
    }

    /*
    if (accessibilityValueMin != null) {
      warnOnce(
        'accessibilityValueMin',
        `accessibilityValueMin is deprecated. Use aria-valuemin.`
      );
    }
    */
    var _ariaValueMin = ariaValueMin != null ? ariaValueMin : accessibilityValueMin;
    if (_ariaValueMin != null) {
      domProps['aria-valuemin'] = _ariaValueMin;
    }

    /*
    if (accessibilityValueNow != null) {
      warnOnce(
        'accessibilityValueNow',
        `accessibilityValueNow is deprecated. Use aria-valuenow.`
      );
    }
    */
    var _ariaValueNow = ariaValueNow != null ? ariaValueNow : accessibilityValueNow;
    if (_ariaValueNow != null) {
      domProps['aria-valuenow'] = _ariaValueNow;
    }

    /*
    if (accessibilityValueText != null) {
      warnOnce(
        'accessibilityValueText',
        `accessibilityValueText is deprecated. Use aria-valuetext.`
      );
    }
    */
    var _ariaValueText = ariaValueText != null ? ariaValueText : accessibilityValueText;
    if (_ariaValueText != null) {
      domProps['aria-valuetext'] = _ariaValueText;
    }

    // "dataSet" replaced with "data-*"
    if (dataSet != null) {
      for (var dataProp in dataSet) {
        if (hasOwnProperty.call(dataSet, dataProp)) {
          var dataName = hyphenateString(dataProp);
          var dataValue = dataSet[dataProp];
          if (dataValue != null) {
            domProps["data-" + dataName] = dataValue;
          }
        }
      }
    }

    // FOCUS
    if (tabIndex === 0 || tabIndex === '0' || tabIndex === -1 || tabIndex === '-1') {
      domProps.tabIndex = tabIndex;
    } else {
      /*
      if (focusable != null) {
        warnOnce('focusable', `focusable is deprecated.`);
      }
      */

      // "focusable" indicates that an element may be a keyboard tab-stop.
      if (focusable === false) {
        domProps.tabIndex = '-1';
      }
      if (
      // These native elements are keyboard focusable by default
      elementType === 'a' || elementType === 'button' || elementType === 'input' || elementType === 'select' || elementType === 'textarea') {
        if (focusable === false || accessibilityDisabled === true) {
          domProps.tabIndex = '-1';
        }
      } else if (
      // These roles are made keyboard focusable by default
      role === 'button' || role === 'checkbox' || role === 'link' || role === 'radio' || role === 'textbox' || role === 'switch') {
        if (focusable !== false) {
          domProps.tabIndex = '0';
        }
      } else {
        // Everything else must explicitly set the prop
        if (focusable === true) {
          domProps.tabIndex = '0';
        }
      }
    }

    // Resolve styles
    if (pointerEvents != null) {
      (0, _warnOnce.warnOnce)('pointerEvents', "props.pointerEvents is deprecated. Use style.pointerEvents");
    }
    var _StyleSheet = (0, StyleSheet.default)([style, pointerEvents && pointerEventsStyles[pointerEvents]], (0, _objectSpread.default)({
        writingDirection: 'ltr'
      }, options)),
      className = _StyleSheet[0],
      inlineStyle = _StyleSheet[1];
    if (className) {
      domProps.className = className;
    }
    if (inlineStyle) {
      domProps.style = inlineStyle;
    }

    // OTHER
    // Native element ID
    /*
    if (nativeID != null) {
      warnOnce('nativeID', `nativeID is deprecated. Use id.`);
    }
    */
    var _id = id != null ? id : nativeID;
    if (_id != null) {
      domProps.id = _id;
    }
    // Automated test IDs
    if (testID != null) {
      domProps['data-testid'] = testID;
    }
    if (domProps.type == null && elementType === 'button') {
      domProps.type = 'button';
    }
    return domProps;
  };
  var _default = createDOMProps;
},121,[20,44,117,43,88]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.getLocaleDirection = getLocaleDirection;
  exports.LocaleProvider = LocaleProvider;
  exports.useLocaleContext = useLocaleContext;
  var _react = require(_dependencyMap[0]);
  var React = _interopDefault(_react);
  var _isLocaleRTL = require(_dependencyMap[1]);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var defaultLocale = {
    direction: 'ltr',
    locale: 'en-US'
  };
  var LocaleContext = /*#__PURE__*/(0, _react.createContext)(defaultLocale);
  function getLocaleDirection(locale) {
    return (0, _isLocaleRTL.isLocaleRTL)(locale) ? 'rtl' : 'ltr';
  }
  function LocaleProvider(props) {
    var direction = props.direction,
      locale = props.locale,
      children = props.children;
    var needsContext = direction || locale;
    return needsContext ? /*#__PURE__*/React.default.createElement(LocaleContext.Provider, {
      children: children,
      value: {
        direction: locale ? getLocaleDirection(locale) : direction,
        locale
      }
    }) : children;
  }
  function useLocaleContext() {
    return (0, _react.useContext)(LocaleContext);
  }
},122,[35,123]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.isLocaleRTL = isLocaleRTL;
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var rtlScripts = new Set(['Arab', 'Syrc', 'Samr', 'Mand', 'Thaa', 'Mend', 'Nkoo', 'Adlm', 'Rohg', 'Hebr']);
  var rtlLangs = new Set(['ae',
  // Avestan
  'ar',
  // Arabic
  'arc',
  // Aramaic
  'bcc',
  // Southern Balochi
  'bqi',
  // Bakthiari
  'ckb',
  // Sorani
  'dv',
  // Dhivehi
  'fa', 'far',
  // Persian
  'glk',
  // Gilaki
  'he', 'iw',
  // Hebrew
  'khw',
  // Khowar
  'ks',
  // Kashmiri
  'ku',
  // Kurdish
  'mzn',
  // Mazanderani
  'nqo',
  // N'Ko
  'pnb',
  // Western Punjabi
  'ps',
  // Pashto
  'sd',
  // Sindhi
  'ug',
  // Uyghur
  'ur',
  // Urdu
  'yi' // Yiddish
  ]);
  var cache = new Map();

  /**
   * Determine the writing direction of a locale
   */
  function isLocaleRTL(locale) {
    var cachedRTL = cache.get(locale);
    if (cachedRTL) {
      return cachedRTL;
    }
    var isRTL = false;
    // $FlowFixMe
    if (Intl.Locale) {
      try {
        // $FlowFixMe
        var script = new Intl.Locale(locale).maximize().script;
        isRTL = rtlScripts.has(script);
      } catch (_unused) {
        // RangeError: Incorrect locale information provided
        // Fallback to inferring from language
        var lang = locale.split('-')[0];
        isRTL = rtlLangs.has(lang);
      }
    } else {
      // Fallback to inferring from language
      var _lang = locale.split('-')[0];
      isRTL = rtlLangs.has(_lang);
    }
    cache.set(locale, isRTL);
    return isRTL;
  }
},123,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var findNodeHandle = component => {
    throw new Error("findNodeHandle is not supported on web. Use the ref property on the component instead.");
  };
  var _default = findNodeHandle;
},124,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _UIManager = require(_dependencyMap[0]);
  var UIManager = _interopDefault(_UIManager);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  // NativeModules shim
  var NativeModules = {
    UIManager: UIManager.default
  };
  var _default = NativeModules;
},125,[126]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _modulesGetBoundingClientRect = require(_dependencyMap[0]);
  var getBoundingClientRect = _interopDefault(_modulesGetBoundingClientRect);
  var _modulesSetValueForStyles = require(_dependencyMap[1]);
  var setValueForStyles = _interopDefault(_modulesSetValueForStyles);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var getRect = node => {
    var height = node.offsetHeight;
    var width = node.offsetWidth;
    var left = node.offsetLeft;
    var top = node.offsetTop;
    node = node.offsetParent;
    while (node && node.nodeType === 1 /* Node.ELEMENT_NODE */) {
      left += node.offsetLeft + node.clientLeft - node.scrollLeft;
      top += node.offsetTop + node.clientTop - node.scrollTop;
      node = node.offsetParent;
    }
    top -= window.scrollY;
    left -= window.scrollX;
    return {
      width,
      height,
      top,
      left
    };
  };
  var measureLayout = (node, relativeToNativeNode, callback) => {
    var relativeNode = relativeToNativeNode || node && node.parentNode;
    if (node && relativeNode) {
      setTimeout(() => {
        if (node.isConnected && relativeNode.isConnected) {
          var relativeRect = getRect(relativeNode);
          var _getRect = getRect(node),
            height = _getRect.height,
            left = _getRect.left,
            top = _getRect.top,
            width = _getRect.width;
          var x = left - relativeRect.left;
          var y = top - relativeRect.top;
          callback(x, y, width, height, left, top);
        }
      }, 0);
    }
  };
  var elementsToIgnore = {
    A: true,
    BODY: true,
    INPUT: true,
    SELECT: true,
    TEXTAREA: true
  };
  var UIManager = {
    blur(node) {
      try {
        node.blur();
      } catch (err) {}
    },
    focus(node) {
      try {
        var name = node.nodeName;
        // A tabIndex of -1 allows element to be programmatically focused but
        // prevents keyboard focus. We don't want to set the tabindex value on
        // elements that should not prevent keyboard focus.
        if (node.getAttribute('tabIndex') == null && node.isContentEditable !== true && elementsToIgnore[name] == null) {
          node.setAttribute('tabIndex', '-1');
        }
        node.focus();
      } catch (err) {}
    },
    measure(node, callback) {
      measureLayout(node, null, callback);
    },
    measureInWindow(node, callback) {
      if (node) {
        setTimeout(() => {
          var _getBoundingClientRec = (0, getBoundingClientRect.default)(node),
            height = _getBoundingClientRec.height,
            left = _getBoundingClientRec.left,
            top = _getBoundingClientRec.top,
            width = _getBoundingClientRec.width;
          callback(left, top, width, height);
        }, 0);
      }
    },
    measureLayout(node, relativeToNativeNode, onFail, onSuccess) {
      measureLayout(node, relativeToNativeNode, onSuccess);
    },
    updateView(node, props) {
      for (var prop in props) {
        if (!Object.prototype.hasOwnProperty.call(props, prop)) {
          continue;
        }
        var value = props[prop];
        switch (prop) {
          case 'style':
            {
              (0, setValueForStyles.default)(node, value);
              break;
            }
          case 'class':
          case 'className':
            {
              node.setAttribute('class', value);
              break;
            }
          case 'text':
          case 'value':
            // native platforms use `text` prop to replace text input value
            node.value = value;
            break;
          default:
            node.setAttribute(prop, value);
        }
      }
    },
    configureNextLayoutAnimation(config, onAnimationDidEnd) {
      onAnimationDidEnd();
    },
    // mocks
    setLayoutAnimationEnabledExperimental() {}
  };
  var _default = UIManager;
},126,[127,128]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var getBoundingClientRect = node => {
    if (node != null) {
      var isElement = node.nodeType === 1; /* Node.ELEMENT_NODE */
      if (isElement && typeof node.getBoundingClientRect === 'function') {
        return node.getBoundingClientRect();
      }
    }
  };
  var _default = getBoundingClientRect;
},127,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _dangerousStyleValue = require(_dependencyMap[0]);
  var dangerousStyleValue = _interopDefault(_dangerousStyleValue);
  /* eslint-disable */

  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * From React 16.3.0
   * 
   */

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   */
  function setValueForStyles(node, styles) {
    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var isCustomProperty = styleName.indexOf('--') === 0;
      var styleValue = (0, dangerousStyleValue.default)(styleName, styles[styleName], isCustomProperty);
      if (styleName === 'float') {
        styleName = 'cssFloat';
      }
      if (isCustomProperty) {
        style.setProperty(styleName, styleValue);
      } else {
        style[styleName] = styleValue;
      }
    }
  }
  var _default = setValueForStyles;
},128,[129]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _unitlessNumbers = require(_dependencyMap[0]);
  var isUnitlessNumber = _interopDefault(_unitlessNumbers);
  /* eslint-disable */

  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * From React 16.0.0
   * 
   */

  /**
   * Convert a value into the proper css writable value. The style name `name`
   * should be logical (no hyphens), as specified
   * in `CSSProperty.isUnitlessNumber`.
   *
   * @param {string} name CSS property name such as `topMargin`.
   * @param {*} value CSS property value such as `10px`.
   * @return {string} Normalized style value with dimensions applied.
   */
  function dangerousStyleValue(name, value, isCustomProperty) {
    // Note that we've removed escapeTextForBrowser() calls here since the
    // whole string will be escaped when the attribute is injected into
    // the markup. If you provide unsafe user data here they can inject
    // arbitrary CSS which may be problematic (I couldn't repro this):
    // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
    // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
    // This is not an XSS hole but instead a potential CSS injection issue
    // which has lead to a greater discussion about how we're going to
    // trust URLs moving forward. See #2115901

    var isEmpty = value == null || typeof value === 'boolean' || value === '';
    if (isEmpty) {
      return '';
    }
    if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.default.hasOwnProperty(name) && isUnitlessNumber.default[name])) {
      return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
    }
    return ('' + value).trim();
  }
  var _default = dangerousStyleValue;
},129,[130]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var unitlessNumbers = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexOrder: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    fontWeight: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowGap: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnGap: true,
    gridColumnStart: true,
    lineClamp: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    // SVG-related
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true,
    // transform types
    scale: true,
    scaleX: true,
    scaleY: true,
    scaleZ: true,
    // RN properties
    shadowOpacity: true
  };

  /**
   * Support style names that may come passed in prefixed by adding permutations
   * of vendor prefixes.
   */
  var prefixes = ['ms', 'Moz', 'O', 'Webkit'];
  var prefixKey = (prefix, key) => {
    return prefix + key.charAt(0).toUpperCase() + key.substring(1);
  };
  Object.keys(unitlessNumbers).forEach(prop => {
    prefixes.forEach(prefix => {
      unitlessNumbers[prefixKey(prefix, prop)] = unitlessNumbers[prop];
    });
  });
  var _default = unitlessNumbers;
},130,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _modulesCanUseDom = require(_dependencyMap[0]);
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  function isScreenReaderEnabled() {
    return new Promise((resolve, reject) => {
      resolve(true);
    });
  }
  var prefersReducedMotionMedia = canUseDOM.default && typeof window.matchMedia === 'function' ? window.matchMedia('(prefers-reduced-motion: reduce)') : null;
  function isReduceMotionEnabled() {
    return new Promise((resolve, reject) => {
      resolve(prefersReducedMotionMedia ? prefersReducedMotionMedia.matches : true);
    });
  }
  function addChangeListener(fn) {
    if (prefersReducedMotionMedia != null) {
      prefersReducedMotionMedia.addEventListener != null ? prefersReducedMotionMedia.addEventListener('change', fn) : prefersReducedMotionMedia.addListener(fn);
    }
  }
  function removeChangeListener(fn) {
    if (prefersReducedMotionMedia != null) {
      prefersReducedMotionMedia.removeEventListener != null ? prefersReducedMotionMedia.removeEventListener('change', fn) : prefersReducedMotionMedia.removeListener(fn);
    }
  }
  var handlers = {};
  var AccessibilityInfo = {
    /**
     * Query whether a screen reader is currently enabled.
     *
     * Returns a promise which resolves to a boolean.
     * The result is `true` when a screen reader is enabled and `false` otherwise.
     */
    isScreenReaderEnabled,
    /**
     * Query whether the user prefers reduced motion.
     *
     * Returns a promise which resolves to a boolean.
     * The result is `true` when a screen reader is enabled and `false` otherwise.
     */
    isReduceMotionEnabled,
    /**
     * Deprecated
     */
    fetch: isScreenReaderEnabled,
    /**
     * Add an event handler. Supported events: reduceMotionChanged
     */
    addEventListener: function addEventListener(eventName, handler) {
      if (eventName === 'reduceMotionChanged') {
        if (!prefersReducedMotionMedia) {
          return;
        }
        var listener = event => {
          handler(event.matches);
        };
        addChangeListener(listener);
        handlers[handler] = listener;
      }
      return {
        remove: () => AccessibilityInfo.removeEventListener(eventName, handler)
      };
    },
    /**
     * Set accessibility focus to a react component.
     */
    setAccessibilityFocus: function setAccessibilityFocus(reactTag) {},
    /**
     * Post a string to be announced by the screen reader.
     */
    announceForAccessibility: function announceForAccessibility(announcement) {},
    /**
     * Remove an event handler.
     */
    removeEventListener: function removeEventListener(eventName, handler) {
      if (eventName === 'reduceMotionChanged') {
        var listener = handlers[handler];
        if (!listener || !prefersReducedMotionMedia) {
          return;
        }
        removeChangeListener(listener);
      }
      return;
    }
  };
  var _default = AccessibilityInfo;
},131,[40]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  class Alert {
    static alert() {}
  }
  var _default = Alert;
},132,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativeAnimatedAnimated = require(_dependencyMap[0]);
  var Animated = _interopDefault(_vendorReactNativeAnimatedAnimated);
  var _default = Animated.default;
},133,[134]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _exportsPlatform = require(_dependencyMap[1]);
  var Platform = _interopDefault(_exportsPlatform);
  var _componentsAnimatedFlatList = require(_dependencyMap[2]);
  var FlatList = _interopDefault(_componentsAnimatedFlatList);
  var _componentsAnimatedImage = require(_dependencyMap[3]);
  var Image = _interopDefault(_componentsAnimatedImage);
  var _componentsAnimatedScrollView = require(_dependencyMap[4]);
  var ScrollView = _interopDefault(_componentsAnimatedScrollView);
  var _componentsAnimatedSectionList = require(_dependencyMap[5]);
  var SectionList = _interopDefault(_componentsAnimatedSectionList);
  var _componentsAnimatedText = require(_dependencyMap[6]);
  var Text = _interopDefault(_componentsAnimatedText);
  var _componentsAnimatedView = require(_dependencyMap[7]);
  var View = _interopDefault(_componentsAnimatedView);
  var _AnimatedMock = require(_dependencyMap[8]);
  var AnimatedMock = _interopDefault(_AnimatedMock);
  var _AnimatedImplementation = require(_dependencyMap[9]);
  var AnimatedImplementation = _interopDefault(_AnimatedImplementation);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  var Animated = Platform.default.isTesting ? AnimatedMock.default : AnimatedImplementation.default;
  var _default = (0, _objectSpread.default)({
    FlatList: FlatList.default,
    Image: Image.default,
    ScrollView: ScrollView.default,
    SectionList: SectionList.default,
    Text: Text.default,
    View: View.default
  }, Animated);
},134,[20,96,135,205,210,211,215,217,218,219]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _react = require(_dependencyMap[1]);
  var React = _interopNamespace(_react);
  var _exportsFlatList = require(_dependencyMap[2]);
  var FlatList = _interopDefault(_exportsFlatList);
  var _createAnimatedComponent = require(_dependencyMap[3]);
  var createAnimatedComponent = _interopDefault(_createAnimatedComponent);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * @see https://github.com/facebook/react-native/commit/b8c8562
   */
  var FlatListWithEventThrottle = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(FlatList.default, (0, _extends.default)({
    scrollEventThrottle: 0.0001
  }, props, {
    ref: ref
  })));
  var _default = (0, createAnimatedComponent.default)(FlatListWithEventThrottle);
},135,[28,35,136,185]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativeFlatList = require(_dependencyMap[0]);
  var FlatList = _interopDefault(_vendorReactNativeFlatList);
  var _default = FlatList.default;
},136,[137]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[2]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _exportsView = require(_dependencyMap[3]);
  var View = _interopDefault(_exportsView);
  var _exportsStyleSheet = require(_dependencyMap[4]);
  var StyleSheet = _interopDefault(_exportsStyleSheet);
  var _deepDiffer = require(_dependencyMap[5]);
  var deepDiffer = _interopDefault(_deepDiffer);
  require(_dependencyMap[6]);
  var _fbjsLibInvariant = require(_dependencyMap[7]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _react = require(_dependencyMap[8]);
  var React = _interopNamespace(_react);
  var _VirtualizedList = require(_dependencyMap[9]);
  var VirtualizedList = _interopDefault(_VirtualizedList);
  var _VirtualizeUtils = require(_dependencyMap[10]);
  var _memoizeOne = require(_dependencyMap[11]);
  var memoizeOne = _interopDefault(_memoizeOne);
  var _excluded = ["numColumns", "columnWrapperStyle", "removeClippedSubviews", "strictMode"];
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * Default Props Helper Functions
   * Use the following helper functions for default values
   */

  // removeClippedSubviewsOrDefault(this.props.removeClippedSubviews)
  function removeClippedSubviewsOrDefault(removeClippedSubviews) {
    return removeClippedSubviews !== null && removeClippedSubviews !== undefined ? removeClippedSubviews : false;
  }

  // numColumnsOrDefault(this.props.numColumns)
  function numColumnsOrDefault(numColumns) {
    return numColumns !== null && numColumns !== undefined ? numColumns : 1;
  }
  function isArrayLike(data) {
    // $FlowExpectedError[incompatible-use]
    return typeof Object(data).length === 'number';
  }
  /**
   * A performant interface for rendering simple, flat lists, supporting the most handy features:
   *
   *  - Fully cross-platform.
   *  - Optional horizontal mode.
   *  - Configurable viewability callbacks.
   *  - Header support.
   *  - Footer support.
   *  - Separator support.
   *  - Pull to Refresh.
   *  - Scroll loading.
   *  - ScrollToIndex support.
   *
   * If you need section support, use [`<SectionList>`](docs/sectionlist.html).
   *
   * Minimal Example:
   *
   *     <FlatList
   *       data={[{key: 'a'}, {key: 'b'}]}
   *       renderItem={({item}) => <Text>{item.key}</Text>}
   *     />
   *
   * More complex, multi-select example demonstrating `PureComponent` usage for perf optimization and avoiding bugs.
   *
   * - By binding the `onPressItem` handler, the props will remain `===` and `PureComponent` will
   *   prevent wasteful re-renders unless the actual `id`, `selected`, or `title` props change, even
   *   if the components rendered in `MyListItem` did not have such optimizations.
   * - By passing `extraData={this.state}` to `FlatList` we make sure `FlatList` itself will re-render
   *   when the `state.selected` changes. Without setting this prop, `FlatList` would not know it
   *   needs to re-render any items because it is also a `PureComponent` and the prop comparison will
   *   not show any changes.
   * - `keyExtractor` tells the list to use the `id`s for the react keys instead of the default `key` property.
   *
   *
   *     class MyListItem extends React.PureComponent {
   *       _onPress = () => {
   *         this.props.onPressItem(this.props.id);
   *       };
   *
   *       render() {
   *         const textColor = this.props.selected ? "red" : "black";
   *         return (
   *           <TouchableOpacity onPress={this._onPress}>
   *             <View>
   *               <Text style={{ color: textColor }}>
   *                 {this.props.title}
   *               </Text>
   *             </View>
   *           </TouchableOpacity>
   *         );
   *       }
   *     }
   *
   *     class MultiSelectList extends React.PureComponent {
   *       state = {selected: (new Map(): Map<string, boolean>)};
   *
   *       _keyExtractor = (item, index) => item.id;
   *
   *       _onPressItem = (id: string) => {
   *         // updater functions are preferred for transactional updates
   *         this.setState((state) => {
   *           // copy the map rather than modifying state.
   *           const selected = new Map(state.selected);
   *           selected.set(id, !selected.get(id)); // toggle
   *           return {selected};
   *         });
   *       };
   *
   *       _renderItem = ({item}) => (
   *         <MyListItem
   *           id={item.id}
   *           onPressItem={this._onPressItem}
   *           selected={!!this.state.selected.get(item.id)}
   *           title={item.title}
   *         />
   *       );
   *
   *       render() {
   *         return (
   *           <FlatList
   *             data={this.props.data}
   *             extraData={this.state}
   *             keyExtractor={this._keyExtractor}
   *             renderItem={this._renderItem}
   *           />
   *         );
   *       }
   *     }
   *
   * This is a convenience wrapper around [`<VirtualizedList>`](docs/virtualizedlist.html),
   * and thus inherits its props (as well as those of `ScrollView`) that aren't explicitly listed
   * here, along with the following caveats:
   *
   * - Internal state is not preserved when content scrolls out of the render window. Make sure all
   *   your data is captured in the item data or external stores like Flux, Redux, or Relay.
   * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-
   *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop
   *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on
   *   changes. This includes the `data` prop and parent component state.
   * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously
   *   offscreen. This means it's possible to scroll faster than the fill rate ands momentarily see
   *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,
   *   and we are working on improving it behind the scenes.
   * - By default, the list looks for a `key` prop on each item and uses that for the React key.
   *   Alternatively, you can provide a custom `keyExtractor` prop.
   *
   * Also inherits [ScrollView Props](docs/scrollview.html#props), unless it is nested in another FlatList of same orientation.
   */
  class FlatList extends React.PureComponent {
    /**
     * Scrolls to the end of the content. May be janky without `getItemLayout` prop.
     */
    scrollToEnd(params) {
      if (this._listRef) {
        this._listRef.scrollToEnd(params);
      }
    }

    /**
     * Scrolls to the item at the specified index such that it is positioned in the viewable area
     * such that `viewPosition` 0 places it at the top, 1 at the bottom, and 0.5 centered in the
     * middle. `viewOffset` is a fixed number of pixels to offset the final target position.
     *
     * Note: cannot scroll to locations outside the render window without specifying the
     * `getItemLayout` prop.
     */
    scrollToIndex(params) {
      if (this._listRef) {
        this._listRef.scrollToIndex(params);
      }
    }

    /**
     * Requires linear scan through data - use `scrollToIndex` instead if possible.
     *
     * Note: cannot scroll to locations outside the render window without specifying the
     * `getItemLayout` prop.
     */
    scrollToItem(params) {
      if (this._listRef) {
        this._listRef.scrollToItem(params);
      }
    }

    /**
     * Scroll to a specific content pixel offset in the list.
     *
     * Check out [scrollToOffset](docs/virtualizedlist.html#scrolltooffset) of VirtualizedList
     */
    scrollToOffset(params) {
      if (this._listRef) {
        this._listRef.scrollToOffset(params);
      }
    }

    /**
     * Tells the list an interaction has occurred, which should trigger viewability calculations, e.g.
     * if `waitForInteractions` is true and the user has not scrolled. This is typically called by
     * taps on items or by navigation actions.
     */
    recordInteraction() {
      if (this._listRef) {
        this._listRef.recordInteraction();
      }
    }

    /**
     * Displays the scroll indicators momentarily.
     *
     * @platform ios
     */
    flashScrollIndicators() {
      if (this._listRef) {
        this._listRef.flashScrollIndicators();
      }
    }

    /**
     * Provides a handle to the underlying scroll responder.
     */
    getScrollResponder() {
      if (this._listRef) {
        return this._listRef.getScrollResponder();
      }
    }

    /**
     * Provides a reference to the underlying host component
     */
    getNativeScrollRef() {
      if (this._listRef) {
        /* $FlowFixMe[incompatible-return] Suppresses errors found when fixing
         * TextInput typing */
        return this._listRef.getScrollRef();
      }
    }
    getScrollableNode() {
      if (this._listRef) {
        return this._listRef.getScrollableNode();
      }
    }
    constructor(_props) {
      super(_props);
      this._virtualizedListPairs = [];
      this._captureRef = ref => {
        this._listRef = ref;
      };
      this._getItem = (data, index) => {
        var numColumns = numColumnsOrDefault(this.props.numColumns);
        if (numColumns > 1) {
          var ret = [];
          for (var kk = 0; kk < numColumns; kk++) {
            var itemIndex = index * numColumns + kk;
            if (itemIndex < data.length) {
              var _item = data[itemIndex];
              ret.push(_item);
            }
          }
          return ret;
        } else {
          return data[index];
        }
      };
      this._getItemCount = data => {
        // Legacy behavior of FlatList was to forward "undefined" length if invalid
        // data like a non-arraylike object is passed. VirtualizedList would then
        // coerce this, and the math would work out to no-op. For compatibility, if
        // invalid data is passed, we tell VirtualizedList there are zero items
        // available to prevent it from trying to read from the invalid data
        // (without propagating invalidly typed data).
        if (data != null && isArrayLike(data)) {
          var numColumns = numColumnsOrDefault(this.props.numColumns);
          return numColumns > 1 ? Math.ceil(data.length / numColumns) : data.length;
        } else {
          return 0;
        }
      };
      this._keyExtractor = (items, index) => {
        var _this$props$keyExtrac;
        var numColumns = numColumnsOrDefault(this.props.numColumns);
        var keyExtractor = (_this$props$keyExtrac = this.props.keyExtractor) !== null && _this$props$keyExtrac !== undefined ? _this$props$keyExtrac : _VirtualizeUtils.keyExtractor;
        if (numColumns > 1) {
          (0, invariant.default)(Array.isArray(items), "FlatList: Encountered internal consistency error, expected each item to consist of an array with 1-%s columns; instead, received a single item.", numColumns);
          return items.map((item, kk) => keyExtractor(item, index * numColumns + kk)).join(':');
        }

        // $FlowFixMe[incompatible-call] Can't call keyExtractor with an array
        return keyExtractor(items, index);
      };
      this._renderer = (ListItemComponent, renderItem, columnWrapperStyle, numColumns, extraData
      // $FlowFixMe[missing-local-annot]
      ) => {
        var cols = numColumnsOrDefault(numColumns);
        var render = props => {
          if (ListItemComponent) {
            // $FlowFixMe[not-a-component] Component isn't valid
            // $FlowFixMe[incompatible-type-arg] Component isn't valid
            // $FlowFixMe[incompatible-return] Component isn't valid
            return /*#__PURE__*/React.createElement(ListItemComponent, props);
          } else if (renderItem) {
            // $FlowFixMe[incompatible-call]
            return renderItem(props);
          } else {
            return null;
          }
        };
        var renderProp = info => {
          if (cols > 1) {
            var _item2 = info.item,
              _index = info.index;
            (0, invariant.default)(Array.isArray(_item2), 'Expected array of items with numColumns > 1');
            return /*#__PURE__*/React.createElement(View.default, {
              style: [styles.row, columnWrapperStyle]
            }, _item2.map((it, kk) => {
              var element = render({
                // $FlowFixMe[incompatible-call]
                item: it,
                index: _index * cols + kk,
                separators: info.separators
              });
              return element != null ? /*#__PURE__*/React.createElement(React.Fragment, {
                key: kk
              }, element) : null;
            }));
          } else {
            return render(info);
          }
        };
        return ListItemComponent ? {
          ListItemComponent: renderProp
        } : {
          renderItem: renderProp
        };
      };
      this._memoizedRenderer = (0, memoizeOne.default)(this._renderer);
      this._checkProps(this.props);
      if (this.props.viewabilityConfigCallbackPairs) {
        this._virtualizedListPairs = this.props.viewabilityConfigCallbackPairs.map(pair => ({
          viewabilityConfig: pair.viewabilityConfig,
          onViewableItemsChanged: this._createOnViewableItemsChanged(pair.onViewableItemsChanged)
        }));
      } else if (this.props.onViewableItemsChanged) {
        this._virtualizedListPairs.push({
          /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
           * comment suppresses an error found when Flow v0.63 was deployed. To
           * see the error delete this comment and run Flow. */
          viewabilityConfig: this.props.viewabilityConfig,
          onViewableItemsChanged: this._createOnViewableItemsChanged(this.props.onViewableItemsChanged)
        });
      }
    }

    // $FlowFixMe[missing-local-annot]
    componentDidUpdate(prevProps) {
      (0, invariant.default)(prevProps.numColumns === this.props.numColumns, "Changing numColumns on the fly is not supported. Change the key prop on FlatList when changing the number of columns to force a fresh render of the component.");
      (0, invariant.default)(prevProps.onViewableItemsChanged === this.props.onViewableItemsChanged, 'Changing onViewableItemsChanged on the fly is not supported');
      (0, invariant.default)(!(0, deepDiffer.default)(prevProps.viewabilityConfig, this.props.viewabilityConfig), 'Changing viewabilityConfig on the fly is not supported');
      (0, invariant.default)(prevProps.viewabilityConfigCallbackPairs === this.props.viewabilityConfigCallbackPairs, 'Changing viewabilityConfigCallbackPairs on the fly is not supported');
      this._checkProps(this.props);
    }
    // $FlowFixMe[missing-local-annot]
    _checkProps(props) {
      var getItem = props.getItem,
        getItemCount = props.getItemCount,
        horizontal = props.horizontal,
        columnWrapperStyle = props.columnWrapperStyle,
        onViewableItemsChanged = props.onViewableItemsChanged,
        viewabilityConfigCallbackPairs = props.viewabilityConfigCallbackPairs;
      var numColumns = numColumnsOrDefault(this.props.numColumns);
      (0, invariant.default)(!getItem && !getItemCount, 'FlatList does not support custom data formats.');
      if (numColumns > 1) {
        (0, invariant.default)(!horizontal, 'numColumns does not support horizontal.');
      } else {
        (0, invariant.default)(!columnWrapperStyle, 'columnWrapperStyle not supported for single column lists');
      }
      (0, invariant.default)(!(onViewableItemsChanged && viewabilityConfigCallbackPairs), "FlatList does not support setting both onViewableItemsChanged and viewabilityConfigCallbackPairs.");
    }
    _pushMultiColumnViewable(arr, v) {
      var _this$props$keyExtrac2;
      var numColumns = numColumnsOrDefault(this.props.numColumns);
      var keyExtractor = (_this$props$keyExtrac2 = this.props.keyExtractor) !== null && _this$props$keyExtrac2 !== undefined ? _this$props$keyExtrac2 : _VirtualizeUtils.keyExtractor;
      v.item.forEach((item, ii) => {
        (0, invariant.default)(v.index != null, 'Missing index!');
        var index = v.index * numColumns + ii;
        arr.push((0, _objectSpread.default)((0, _objectSpread.default)({}, v), {}, {
          item,
          key: keyExtractor(item, index),
          index
        }));
      });
    }
    _createOnViewableItemsChanged(onViewableItemsChanged
    // $FlowFixMe[missing-local-annot]
    ) {
      return info => {
        var numColumns = numColumnsOrDefault(this.props.numColumns);
        if (onViewableItemsChanged) {
          if (numColumns > 1) {
            var changed = [];
            var viewableItems = [];
            info.viewableItems.forEach(v => this._pushMultiColumnViewable(viewableItems, v));
            info.changed.forEach(v => this._pushMultiColumnViewable(changed, v));
            onViewableItemsChanged({
              viewableItems,
              changed
            });
          } else {
            onViewableItemsChanged(info);
          }
        }
      };
    }

    // $FlowFixMe[missing-local-annot]

    render() {
      var _this$props = this.props,
        numColumns = _this$props.numColumns,
        columnWrapperStyle = _this$props.columnWrapperStyle,
        _removeClippedSubviews = _this$props.removeClippedSubviews,
        _this$props$strictMod = _this$props.strictMode,
        strictMode = _this$props$strictMod === undefined ? false : _this$props$strictMod,
        restProps = (0, _objectWithoutPropertiesLoose.default)(_this$props, _excluded);
      var renderer = strictMode ? this._memoizedRenderer : this._renderer;
      return (/*#__PURE__*/
        // $FlowFixMe[incompatible-exact] - `restProps` (`Props`) is inexact.
        React.createElement(VirtualizedList.default, (0, _extends.default)({}, restProps, {
          getItem: this._getItem,
          getItemCount: this._getItemCount,
          keyExtractor: this._keyExtractor,
          ref: this._captureRef,
          viewabilityConfigCallbackPairs: this._virtualizedListPairs,
          removeClippedSubviews: removeClippedSubviewsOrDefault(_removeClippedSubviews)
        }, renderer(this.props.ListItemComponent, this.props.renderItem, columnWrapperStyle, numColumns, this.props.extraData)))
      );
    }
  }
  var styles = StyleSheet.default.create({
    row: {
      flexDirection: 'row'
    }
  });
  var _default = FlatList;
},137,[28,44,20,138,43,155,96,25,35,156,182,184]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[1]);
  var React = _interopNamespace(_react);
  var _createElement = require(_dependencyMap[2]);
  var createElement = _interopDefault(_createElement);
  var _modulesForwardedProps = require(_dependencyMap[3]);
  var forwardedProps = _interopNamespace(_modulesForwardedProps);
  var _modulesPick = require(_dependencyMap[4]);
  var pick = _interopDefault(_modulesPick);
  var _modulesUseElementLayout = require(_dependencyMap[5]);
  var useElementLayout = _interopDefault(_modulesUseElementLayout);
  var _modulesUseMergeRefs = require(_dependencyMap[6]);
  var useMergeRefs = _interopDefault(_modulesUseMergeRefs);
  var _modulesUsePlatformMethods = require(_dependencyMap[7]);
  var usePlatformMethods = _interopDefault(_modulesUsePlatformMethods);
  var _modulesUseResponderEvents = require(_dependencyMap[8]);
  var useResponderEvents = _interopDefault(_modulesUseResponderEvents);
  var _StyleSheet = require(_dependencyMap[9]);
  var StyleSheet = _interopDefault(_StyleSheet);
  var _TextTextAncestorContext = require(_dependencyMap[10]);
  var TextAncestorContext = _interopDefault(_TextTextAncestorContext);
  var _modulesUseLocale = require(_dependencyMap[11]);
  var _excluded = ["hrefAttrs", "onLayout", "onMoveShouldSetResponder", "onMoveShouldSetResponderCapture", "onResponderEnd", "onResponderGrant", "onResponderMove", "onResponderReject", "onResponderRelease", "onResponderStart", "onResponderTerminate", "onResponderTerminationRequest", "onScrollShouldSetResponder", "onScrollShouldSetResponderCapture", "onSelectionChangeShouldSetResponder", "onSelectionChangeShouldSetResponderCapture", "onStartShouldSetResponder", "onStartShouldSetResponderCapture"];
  var forwardPropsList = Object.assign({}, forwardedProps.defaultProps, forwardedProps.accessibilityProps, forwardedProps.clickProps, forwardedProps.focusProps, forwardedProps.keyboardProps, forwardedProps.mouseProps, forwardedProps.touchProps, forwardedProps.styleProps, {
    href: true,
    lang: true,
    onScroll: true,
    onWheel: true,
    pointerEvents: true
  });
  var pickProps = props => (0, pick.default)(props, forwardPropsList);
  var View = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var hrefAttrs = props.hrefAttrs,
      onLayout = props.onLayout,
      onMoveShouldSetResponder = props.onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture = props.onMoveShouldSetResponderCapture,
      onResponderEnd = props.onResponderEnd,
      onResponderGrant = props.onResponderGrant,
      onResponderMove = props.onResponderMove,
      onResponderReject = props.onResponderReject,
      onResponderRelease = props.onResponderRelease,
      onResponderStart = props.onResponderStart,
      onResponderTerminate = props.onResponderTerminate,
      onResponderTerminationRequest = props.onResponderTerminationRequest,
      onScrollShouldSetResponder = props.onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture = props.onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder = props.onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture = props.onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder = props.onStartShouldSetResponder,
      onStartShouldSetResponderCapture = props.onStartShouldSetResponderCapture,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    var hasTextAncestor = React.useContext(TextAncestorContext.default);
    var hostRef = React.useRef(null);
    var _useLocaleContext = (0, _modulesUseLocale.useLocaleContext)(),
      contextDirection = _useLocaleContext.direction;
    (0, useElementLayout.default)(hostRef, onLayout);
    (0, useResponderEvents.default)(hostRef, {
      onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture,
      onResponderEnd,
      onResponderGrant,
      onResponderMove,
      onResponderReject,
      onResponderRelease,
      onResponderStart,
      onResponderTerminate,
      onResponderTerminationRequest,
      onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder,
      onStartShouldSetResponderCapture
    });
    var component = 'div';
    var langDirection = props.lang != null ? (0, _modulesUseLocale.getLocaleDirection)(props.lang) : null;
    var componentDirection = props.dir || langDirection;
    var writingDirection = componentDirection || contextDirection;
    var supportedProps = pickProps(rest);
    supportedProps.dir = componentDirection;
    supportedProps.style = [styles.view$raw, hasTextAncestor && styles.inline, props.style];
    if (props.href != null) {
      component = 'a';
      if (hrefAttrs != null) {
        var download = hrefAttrs.download,
          rel = hrefAttrs.rel,
          target = hrefAttrs.target;
        if (download != null) {
          supportedProps.download = download;
        }
        if (rel != null) {
          supportedProps.rel = rel;
        }
        if (typeof target === 'string') {
          supportedProps.target = target.charAt(0) !== '_' ? '_' + target : target;
        }
      }
    }
    var platformMethodsRef = (0, usePlatformMethods.default)(supportedProps);
    var setRef = (0, useMergeRefs.default)(hostRef, platformMethodsRef, forwardedRef);
    supportedProps.ref = setRef;
    return (0, createElement.default)(component, supportedProps, {
      writingDirection
    });
  });
  View.displayName = 'View';
  var styles = StyleSheet.default.create({
    view$raw: {
      alignContent: 'flex-start',
      alignItems: 'stretch',
      backgroundColor: 'transparent',
      border: '0 solid black',
      boxSizing: 'border-box',
      display: 'flex',
      flexBasis: 'auto',
      flexDirection: 'column',
      flexShrink: 0,
      listStyle: 'none',
      margin: 0,
      minHeight: 0,
      minWidth: 0,
      padding: 0,
      position: 'relative',
      textDecoration: 'none',
      zIndex: 0
    },
    inline: {
      display: 'inline-flex'
    }
  });
  var _default = View;
},138,[44,35,116,139,140,141,143,145,147,43,154,122]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "defaultProps", {
    enumerable: true,
    get: function () {
      return defaultProps;
    }
  });
  Object.defineProperty(exports, "accessibilityProps", {
    enumerable: true,
    get: function () {
      return accessibilityProps;
    }
  });
  Object.defineProperty(exports, "clickProps", {
    enumerable: true,
    get: function () {
      return clickProps;
    }
  });
  Object.defineProperty(exports, "focusProps", {
    enumerable: true,
    get: function () {
      return focusProps;
    }
  });
  Object.defineProperty(exports, "keyboardProps", {
    enumerable: true,
    get: function () {
      return keyboardProps;
    }
  });
  Object.defineProperty(exports, "mouseProps", {
    enumerable: true,
    get: function () {
      return mouseProps;
    }
  });
  Object.defineProperty(exports, "touchProps", {
    enumerable: true,
    get: function () {
      return touchProps;
    }
  });
  Object.defineProperty(exports, "styleProps", {
    enumerable: true,
    get: function () {
      return styleProps;
    }
  });
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var defaultProps = {
    children: true,
    dataSet: true,
    dir: true,
    id: true,
    ref: true,
    suppressHydrationWarning: true,
    tabIndex: true,
    testID: true,
    // @deprecated
    focusable: true,
    nativeID: true
  };
  var accessibilityProps = {
    'aria-activedescendant': true,
    'aria-atomic': true,
    'aria-autocomplete': true,
    'aria-busy': true,
    'aria-checked': true,
    'aria-colcount': true,
    'aria-colindex': true,
    'aria-colspan': true,
    'aria-controls': true,
    'aria-current': true,
    'aria-describedby': true,
    'aria-details': true,
    'aria-disabled': true,
    'aria-errormessage': true,
    'aria-expanded': true,
    'aria-flowto': true,
    'aria-haspopup': true,
    'aria-hidden': true,
    'aria-invalid': true,
    'aria-keyshortcuts': true,
    'aria-label': true,
    'aria-labelledby': true,
    'aria-level': true,
    'aria-live': true,
    'aria-modal': true,
    'aria-multiline': true,
    'aria-multiselectable': true,
    'aria-orientation': true,
    'aria-owns': true,
    'aria-placeholder': true,
    'aria-posinset': true,
    'aria-pressed': true,
    'aria-readonly': true,
    'aria-required': true,
    role: true,
    'aria-roledescription': true,
    'aria-rowcount': true,
    'aria-rowindex': true,
    'aria-rowspan': true,
    'aria-selected': true,
    'aria-setsize': true,
    'aria-sort': true,
    'aria-valuemax': true,
    'aria-valuemin': true,
    'aria-valuenow': true,
    'aria-valuetext': true,
    // @deprecated
    accessibilityActiveDescendant: true,
    accessibilityAtomic: true,
    accessibilityAutoComplete: true,
    accessibilityBusy: true,
    accessibilityChecked: true,
    accessibilityColumnCount: true,
    accessibilityColumnIndex: true,
    accessibilityColumnSpan: true,
    accessibilityControls: true,
    accessibilityCurrent: true,
    accessibilityDescribedBy: true,
    accessibilityDetails: true,
    accessibilityDisabled: true,
    accessibilityErrorMessage: true,
    accessibilityExpanded: true,
    accessibilityFlowTo: true,
    accessibilityHasPopup: true,
    accessibilityHidden: true,
    accessibilityInvalid: true,
    accessibilityKeyShortcuts: true,
    accessibilityLabel: true,
    accessibilityLabelledBy: true,
    accessibilityLevel: true,
    accessibilityLiveRegion: true,
    accessibilityModal: true,
    accessibilityMultiline: true,
    accessibilityMultiSelectable: true,
    accessibilityOrientation: true,
    accessibilityOwns: true,
    accessibilityPlaceholder: true,
    accessibilityPosInSet: true,
    accessibilityPressed: true,
    accessibilityReadOnly: true,
    accessibilityRequired: true,
    accessibilityRole: true,
    accessibilityRoleDescription: true,
    accessibilityRowCount: true,
    accessibilityRowIndex: true,
    accessibilityRowSpan: true,
    accessibilitySelected: true,
    accessibilitySetSize: true,
    accessibilitySort: true,
    accessibilityValueMax: true,
    accessibilityValueMin: true,
    accessibilityValueNow: true,
    accessibilityValueText: true
  };
  var clickProps = {
    onClick: true,
    onAuxClick: true,
    onContextMenu: true,
    onGotPointerCapture: true,
    onLostPointerCapture: true,
    onPointerCancel: true,
    onPointerDown: true,
    onPointerEnter: true,
    onPointerMove: true,
    onPointerLeave: true,
    onPointerOut: true,
    onPointerOver: true,
    onPointerUp: true
  };
  var focusProps = {
    onBlur: true,
    onFocus: true
  };
  var keyboardProps = {
    onKeyDown: true,
    onKeyDownCapture: true,
    onKeyUp: true,
    onKeyUpCapture: true
  };
  var mouseProps = {
    onMouseDown: true,
    onMouseEnter: true,
    onMouseLeave: true,
    onMouseMove: true,
    onMouseOver: true,
    onMouseOut: true,
    onMouseUp: true
  };
  var touchProps = {
    onTouchCancel: true,
    onTouchCancelCapture: true,
    onTouchEnd: true,
    onTouchEndCapture: true,
    onTouchMove: true,
    onTouchMoveCapture: true,
    onTouchStart: true,
    onTouchStartCapture: true
  };
  var styleProps = {
    style: true
  };
},139,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return pick;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function pick(obj, list) {
    var nextObj = {};
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        if (list[key] === true) {
          nextObj[key] = obj[key];
        }
      }
    }
    return nextObj;
  }
},140,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useElementLayout;
    }
  });
  var _useLayoutEffect = require(_dependencyMap[0]);
  var useLayoutEffect = _interopDefault(_useLayoutEffect);
  var _exportsUIManager = require(_dependencyMap[1]);
  var UIManager = _interopDefault(_exportsUIManager);
  var _canUseDom = require(_dependencyMap[2]);
  var canUseDOM = _interopDefault(_canUseDom);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var DOM_LAYOUT_HANDLER_NAME = '__reactLayoutHandler';
  var didWarn = !canUseDOM.default;
  var resizeObserver = null;
  function getResizeObserver() {
    if (canUseDOM.default && typeof window.ResizeObserver !== 'undefined') {
      if (resizeObserver == null) {
        resizeObserver = new window.ResizeObserver(function (entries) {
          entries.forEach(entry => {
            var node = entry.target;
            var onLayout = node[DOM_LAYOUT_HANDLER_NAME];
            if (typeof onLayout === 'function') {
              // We still need to measure the view because browsers don't yet provide
              // border-box dimensions in the entry
              UIManager.default.measure(node, (x, y, width, height, left, top) => {
                var event = {
                  // $FlowFixMe
                  nativeEvent: {
                    layout: {
                      x,
                      y,
                      width,
                      height,
                      left,
                      top
                    }
                  },
                  timeStamp: Date.now()
                };
                Object.defineProperty(event.nativeEvent, 'target', {
                  enumerable: true,
                  get: () => entry.target
                });
                onLayout(event);
              });
            }
          });
        });
      }
    } else if (!didWarn) {}
    return resizeObserver;
  }
  function useElementLayout(ref, onLayout) {
    var observer = getResizeObserver();
    (0, useLayoutEffect.default)(() => {
      var node = ref.current;
      if (node != null) {
        node[DOM_LAYOUT_HANDLER_NAME] = onLayout;
      }
    }, [ref, onLayout]);

    // Observing is done in a separate effect to avoid this effect running
    // when 'onLayout' changes.
    (0, useLayoutEffect.default)(() => {
      var node = ref.current;
      if (node != null && observer != null) {
        if (typeof node[DOM_LAYOUT_HANDLER_NAME] === 'function') {
          observer.observe(node);
        } else {
          observer.unobserve(node);
        }
      }
      return () => {
        if (node != null && observer != null) {
          observer.unobserve(node);
        }
      };
    }, [ref, observer]);
  }
},141,[142,126,40]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _react = require(_dependencyMap[0]);
  var _canUseDom = require(_dependencyMap[1]);
  var canUseDOM = _interopDefault(_canUseDom);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * useLayoutEffect throws an error on the server. On the few occasions where is
   * problematic, use this hook.
   *
   * 
   */

  var useLayoutEffectImpl = canUseDOM.default ? _react.useLayoutEffect : _react.useEffect;
  var _default = useLayoutEffectImpl;
},142,[35,40]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useMergeRefs;
    }
  });
  var _react = require(_dependencyMap[0]);
  var React = _interopNamespace(_react);
  var _mergeRefs = require(_dependencyMap[1]);
  var mergeRefs = _interopDefault(_mergeRefs);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function useMergeRefs() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return React.useMemo(() => (0, mergeRefs.default)(...args),
    // eslint-disable-next-line
    [...args]);
  }
},143,[35,144]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return mergeRefs;
    }
  });
  require(_dependencyMap[0]);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function mergeRefs() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return function forwardRef(node) {
      args.forEach(ref => {
        if (ref == null) {
          return;
        }
        if (typeof ref === 'function') {
          ref(node);
          return;
        }
        if (typeof ref === 'object') {
          ref.current = node;
          return;
        }
        console.error("mergeRefs cannot handle Refs of type boolean, number or string, received ref " + String(ref));
      });
    };
  }
},144,[35]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return usePlatformMethods;
    }
  });
  var _exportsUIManager = require(_dependencyMap[0]);
  var UIManager = _interopDefault(_exportsUIManager);
  var _useStable = require(_dependencyMap[1]);
  var useStable = _interopDefault(_useStable);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * Adds non-standard methods to the hode element. This is temporarily until an
   * API like `ReactNative.measure(hostRef, callback)` is added to React Native.
   */
  function usePlatformMethods(_ref) {
    var pointerEvents = _ref.pointerEvents,
      style = _ref.style;
    // Avoid creating a new ref on every render.
    var ref = (0, useStable.default)(() => hostNode => {
      if (hostNode != null) {
        hostNode.measure = callback => UIManager.default.measure(hostNode, callback);
        hostNode.measureLayout = (relativeToNode, success, failure) => UIManager.default.measureLayout(hostNode, relativeToNode, failure, success);
        hostNode.measureInWindow = callback => UIManager.default.measureInWindow(hostNode, callback);
      }
    });
    return ref;
  }
},145,[126,146]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useStable;
    }
  });
  var _react = require(_dependencyMap[0]);
  var React = _interopNamespace(_react);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var UNINITIALIZED = typeof Symbol === 'function' && typeof Symbol() === 'symbol' ? Symbol() : Object.freeze({});
  function useStable(getInitialValue) {
    var ref = React.useRef(UNINITIALIZED);
    if (ref.current === UNINITIALIZED) {
      ref.current = getInitialValue();
    }
    // $FlowFixMe (#64650789) Trouble refining types where `Symbol` is concerned.
    return ref.current;
  }
},146,[35]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useResponderEvents;
    }
  });
  var _react = require(_dependencyMap[0]);
  var React = _interopNamespace(_react);
  var _ResponderSystem = require(_dependencyMap[1]);
  var ResponderSystem = _interopNamespace(_ResponderSystem);
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * Hook for integrating the Responder System into React
   *
   *   function SomeComponent({ onStartShouldSetResponder }) {
   *     const ref = useRef(null);
   *     useResponderEvents(ref, { onStartShouldSetResponder });
   *     return <div ref={ref} />
   *   }
   */

  var emptyObject = {};
  var idCounter = 0;
  function useStable(getInitialValue) {
    var ref = React.useRef(null);
    if (ref.current == null) {
      ref.current = getInitialValue();
    }
    return ref.current;
  }
  function useResponderEvents(hostRef, config) {
    if (config === undefined) {
      config = emptyObject;
    }
    var id = useStable(() => idCounter++);
    var isAttachedRef = React.useRef(false);

    // This is a separate effects so it doesn't run when the config changes.
    // On initial mount, attach global listeners if needed.
    // On unmount, remove node potentially attached to the Responder System.
    React.useEffect(() => {
      ResponderSystem.attachListeners();
      return () => {
        ResponderSystem.removeNode(id);
      };
    }, [id]);

    // Register and unregister with the Responder System as necessary
    React.useEffect(() => {
      var _config = config,
        onMoveShouldSetResponder = _config.onMoveShouldSetResponder,
        onMoveShouldSetResponderCapture = _config.onMoveShouldSetResponderCapture,
        onScrollShouldSetResponder = _config.onScrollShouldSetResponder,
        onScrollShouldSetResponderCapture = _config.onScrollShouldSetResponderCapture,
        onSelectionChangeShouldSetResponder = _config.onSelectionChangeShouldSetResponder,
        onSelectionChangeShouldSetResponderCapture = _config.onSelectionChangeShouldSetResponderCapture,
        onStartShouldSetResponder = _config.onStartShouldSetResponder,
        onStartShouldSetResponderCapture = _config.onStartShouldSetResponderCapture;
      var requiresResponderSystem = onMoveShouldSetResponder != null || onMoveShouldSetResponderCapture != null || onScrollShouldSetResponder != null || onScrollShouldSetResponderCapture != null || onSelectionChangeShouldSetResponder != null || onSelectionChangeShouldSetResponderCapture != null || onStartShouldSetResponder != null || onStartShouldSetResponderCapture != null;
      var node = hostRef.current;
      if (requiresResponderSystem) {
        ResponderSystem.addNode(id, node, config);
        isAttachedRef.current = true;
      } else if (isAttachedRef.current) {
        ResponderSystem.removeNode(id);
        isAttachedRef.current = false;
      }
    }, [config, hostRef, id]);
    React.useDebugValue({
      isResponder: hostRef.current === ResponderSystem.getResponderNode()
    });
    React.useDebugValue(config);
  }
},147,[35,148]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.attachListeners = attachListeners;
  exports.addNode = addNode;
  exports.removeNode = removeNode;
  exports.terminateResponder = terminateResponder;
  exports.getResponderNode = getResponderNode;
  var _createResponderEvent = require(_dependencyMap[0]);
  var createResponderEvent = _interopDefault(_createResponderEvent);
  var _ResponderEventTypes = require(_dependencyMap[1]);
  var _utils = require(_dependencyMap[2]);
  var _ResponderTouchHistoryStore = require(_dependencyMap[3]);
  var _canUseDom = require(_dependencyMap[4]);
  var canUseDOM = _interopDefault(_canUseDom);
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * RESPONDER EVENT SYSTEM
   *
   * A single, global "interaction lock" on views. For a view to be the "responder" means
   * that pointer interactions are exclusive to that view and none other. The "interaction
   * lock" can be transferred (only) to ancestors of the current "responder" as long as
   * pointers continue to be active.
   *
   * Responder being granted:
   *
   * A view can become the "responder" after the following events:
   *  * "pointerdown" (implemented using "touchstart", "mousedown")
   *  * "pointermove" (implemented using "touchmove", "mousemove")
   *  * "scroll" (while a pointer is down)
   *  * "selectionchange" (while a pointer is down)
   *
   * If nothing is already the "responder", the event propagates to (capture) and from
   * (bubble) the event target until a view returns `true` for
   * `on*ShouldSetResponder(Capture)`.
   *
   * If something is already the responder, the event propagates to (capture) and from
   * (bubble) the lowest common ancestor of the event target and the current "responder".
   * Then negotiation happens between the current "responder" and a view that wants to
   * become the "responder": see the timing diagram below.
   *
   * (NOTE: Scrolled views either automatically become the "responder" or release the
   * "interaction lock". A native scroll view that isn't built on top of the responder
   * system must result in the current "responder" being notified that it no longer has
   * the "interaction lock" - the native system has taken over.
   *
   * Responder being released:
   *
   * As soon as there are no more active pointers that *started* inside descendants
   * of the *current* "responder", an `onResponderRelease` event is dispatched to the
   * current "responder", and the responder lock is released.
   *
   * Typical sequence of events:
   *  * startShouldSetResponder
   *  * responderGrant/Reject
   *  * responderStart
   *  * responderMove
   *  * responderEnd
   *  * responderRelease
   */

  /*                                             Negotiation Performed
                                               +-----------------------+
                                              /                         \
  Process low level events to    +     Current Responder      +   wantsResponderID
  determine who to perform negot-|   (if any exists at all)   |
  iation/transition              | Otherwise just pass through|
  -------------------------------+----------------------------+------------------+
  Bubble to find first ID        |                            |
  to return true:wantsResponderID|                            |
                                 |                            |
       +--------------+          |                            |
       | onTouchStart |          |                            |
       +------+-------+    none  |                            |
              |            return|                            |
  +-----------v-------------+true| +------------------------+ |
  |onStartShouldSetResponder|----->| onResponderStart (cur) |<-----------+
  +-----------+-------------+    | +------------------------+ |          |
              |                  |                            | +--------+-------+
              | returned true for|       false:REJECT +-------->|onResponderReject
              | wantsResponderID |                    |       | +----------------+
              | (now attempt     | +------------------+-----+ |
              |  handoff)        | | onResponder            | |
              +------------------->|    TerminationRequest  | |
                                 | +------------------+-----+ |
                                 |                    |       | +----------------+
                                 |         true:GRANT +-------->|onResponderGrant|
                                 |                            | +--------+-------+
                                 | +------------------------+ |          |
                                 | | onResponderTerminate   |<-----------+
                                 | +------------------+-----+ |
                                 |                    |       | +----------------+
                                 |                    +-------->|onResponderStart|
                                 |                            | +----------------+
  Bubble to find first ID        |                            |
  to return true:wantsResponderID|                            |
                                 |                            |
       +-------------+           |                            |
       | onTouchMove |           |                            |
       +------+------+     none  |                            |
              |            return|                            |
  +-----------v-------------+true| +------------------------+ |
  |onMoveShouldSetResponder |----->| onResponderMove (cur)  |<-----------+
  +-----------+-------------+    | +------------------------+ |          |
              |                  |                            | +--------+-------+
              | returned true for|       false:REJECT +-------->|onResponderReject
              | wantsResponderID |                    |       | +----------------+
              | (now attempt     | +------------------+-----+ |
              |  handoff)        | |   onResponder          | |
              +------------------->|      TerminationRequest| |
                                 | +------------------+-----+ |
                                 |                    |       | +----------------+
                                 |         true:GRANT +-------->|onResponderGrant|
                                 |                            | +--------+-------+
                                 | +------------------------+ |          |
                                 | |   onResponderTerminate |<-----------+
                                 | +------------------+-----+ |
                                 |                    |       | +----------------+
                                 |                    +-------->|onResponderMove |
                                 |                            | +----------------+
                                 |                            |
                                 |                            |
        Some active touch started|                            |
        inside current responder | +------------------------+ |
        +------------------------->|      onResponderEnd    | |
        |                        | +------------------------+ |
    +---+---------+              |                            |
    | onTouchEnd  |              |                            |
    +---+---------+              |                            |
        |                        | +------------------------+ |
        +------------------------->|     onResponderEnd     | |
        No active touches started| +-----------+------------+ |
        inside current responder |             |              |
                                 |             v              |
                                 | +------------------------+ |
                                 | |    onResponderRelease  | |
                                 | +------------------------+ |
                                 |                            |
                                 +                            + */

  /* ------------ TYPES ------------ */

  var emptyObject = {};

  /* ------------ IMPLEMENTATION ------------ */

  var startRegistration = ['onStartShouldSetResponderCapture', 'onStartShouldSetResponder', {
    bubbles: true
  }];
  var moveRegistration = ['onMoveShouldSetResponderCapture', 'onMoveShouldSetResponder', {
    bubbles: true
  }];
  var scrollRegistration = ['onScrollShouldSetResponderCapture', 'onScrollShouldSetResponder', {
    bubbles: false
  }];
  var shouldSetResponderEvents = {
    touchstart: startRegistration,
    mousedown: startRegistration,
    touchmove: moveRegistration,
    mousemove: moveRegistration,
    scroll: scrollRegistration
  };
  var emptyResponder = {
    id: null,
    idPath: null,
    node: null
  };
  var responderListenersMap = new Map();
  var isEmulatingMouseEvents = false;
  var trackedTouchCount = 0;
  var currentResponder = {
    id: null,
    node: null,
    idPath: null
  };
  var responderTouchHistoryStore = new _ResponderTouchHistoryStore.ResponderTouchHistoryStore();
  function changeCurrentResponder(responder) {
    currentResponder = responder;
  }
  function getResponderConfig(id) {
    var config = responderListenersMap.get(id);
    return config != null ? config : emptyObject;
  }

  /**
   * Process native events
   *
   * A single event listener is used to manage the responder system.
   * All pointers are tracked in the ResponderTouchHistoryStore. Native events
   * are interpreted in terms of the Responder System and checked to see if
   * the responder should be transferred. Each host node that is attached to
   * the Responder System has an ID, which is used to look up its associated
   * callbacks.
   */
  function eventListener(domEvent) {
    var eventType = domEvent.type;
    var eventTarget = domEvent.target;

    /**
     * Manage emulated events and early bailout.
     * Since PointerEvent is not used yet (lack of support in older Safari), it's
     * necessary to manually manage the mess of browser touch/mouse events.
     * And bailout early for termination events when there is no active responder.
     */

    // Flag when browser may produce emulated events
    if (eventType === 'touchstart') {
      isEmulatingMouseEvents = true;
    }
    // Remove flag when browser will not produce emulated events
    if (eventType === 'touchmove' || trackedTouchCount > 1) {
      isEmulatingMouseEvents = false;
    }
    // Ignore various events in particular circumstances
    if (
    // Ignore browser emulated mouse events
    eventType === 'mousedown' && isEmulatingMouseEvents || eventType === 'mousemove' && isEmulatingMouseEvents ||
    // Ignore mousemove if a mousedown didn't occur first
    eventType === 'mousemove' && trackedTouchCount < 1) {
      return;
    }
    // Remove flag after emulated events are finished
    if (isEmulatingMouseEvents && eventType === 'mouseup') {
      if (trackedTouchCount === 0) {
        isEmulatingMouseEvents = false;
      }
      return;
    }
    var isStartEvent = (0, _ResponderEventTypes.isStartish)(eventType) && (0, _utils.isPrimaryPointerDown)(domEvent);
    var isMoveEvent = (0, _ResponderEventTypes.isMoveish)(eventType);
    var isEndEvent = (0, _ResponderEventTypes.isEndish)(eventType);
    var isScrollEvent = (0, _ResponderEventTypes.isScroll)(eventType);
    var isSelectionChangeEvent = (0, _ResponderEventTypes.isSelectionChange)(eventType);
    var responderEvent = (0, createResponderEvent.default)(domEvent, responderTouchHistoryStore);

    /**
     * Record the state of active pointers
     */

    if (isStartEvent || isMoveEvent || isEndEvent) {
      if (domEvent.touches) {
        trackedTouchCount = domEvent.touches.length;
      } else {
        if (isStartEvent) {
          trackedTouchCount = 1;
        } else if (isEndEvent) {
          trackedTouchCount = 0;
        }
      }
      responderTouchHistoryStore.recordTouchTrack(eventType, responderEvent.nativeEvent);
    }

    /**
     * Responder System logic
     */

    var eventPaths = (0, _utils.getResponderPaths)(domEvent);
    var wasNegotiated = false;
    var wantsResponder;

    // If an event occured that might change the current responder...
    if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {
      // If there is already a responder, prune the event paths to the lowest common ancestor
      // of the existing responder and deepest target of the event.
      var currentResponderIdPath = currentResponder.idPath;
      var eventIdPath = eventPaths.idPath;
      if (currentResponderIdPath != null && eventIdPath != null) {
        var lowestCommonAncestor = (0, _utils.getLowestCommonAncestor)(currentResponderIdPath, eventIdPath);
        if (lowestCommonAncestor != null) {
          var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor);
          // Skip the current responder so it doesn't receive unexpected "shouldSet" events.
          var index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);
          eventPaths = {
            idPath: eventIdPath.slice(index),
            nodePath: eventPaths.nodePath.slice(index)
          };
        } else {
          eventPaths = null;
        }
      }
      if (eventPaths != null) {
        // If a node wants to become the responder, attempt to transfer.
        wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);
        if (wantsResponder != null) {
          // Sets responder if none exists, or negotates with existing responder.
          attemptTransfer(responderEvent, wantsResponder);
          wasNegotiated = true;
        }
      }
    }

    // If there is now a responder, invoke its callbacks for the lifecycle of the gesture.
    if (currentResponder.id != null && currentResponder.node != null) {
      var _currentResponder = currentResponder,
        id = _currentResponder.id,
        node = _currentResponder.node;
      var _getResponderConfig = getResponderConfig(id),
        onResponderStart = _getResponderConfig.onResponderStart,
        onResponderMove = _getResponderConfig.onResponderMove,
        onResponderEnd = _getResponderConfig.onResponderEnd,
        onResponderRelease = _getResponderConfig.onResponderRelease,
        onResponderTerminate = _getResponderConfig.onResponderTerminate,
        onResponderTerminationRequest = _getResponderConfig.onResponderTerminationRequest;
      responderEvent.bubbles = false;
      responderEvent.cancelable = false;
      responderEvent.currentTarget = node;

      // Start
      if (isStartEvent) {
        if (onResponderStart != null) {
          responderEvent.dispatchConfig.registrationName = 'onResponderStart';
          onResponderStart(responderEvent);
        }
      }
      // Move
      else if (isMoveEvent) {
        if (onResponderMove != null) {
          responderEvent.dispatchConfig.registrationName = 'onResponderMove';
          onResponderMove(responderEvent);
        }
      } else {
        var isTerminateEvent = (0, _ResponderEventTypes.isCancelish)(eventType) ||
        // native context menu
        eventType === 'contextmenu' ||
        // window blur
        eventType === 'blur' && eventTarget === window ||
        // responder (or ancestors) blur
        eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node ||
        // native scroll without using a pointer
        isScrollEvent && trackedTouchCount === 0 ||
        // native scroll on node that is parent of the responder (allow siblings to scroll)
        isScrollEvent && eventTarget.contains(node) && eventTarget !== node ||
        // native select/selectionchange on node
        isSelectionChangeEvent && (0, _utils.hasValidSelection)(domEvent);
        var isReleaseEvent = isEndEvent && !isTerminateEvent && !(0, _utils.hasTargetTouches)(node, domEvent.touches);

        // End
        if (isEndEvent) {
          if (onResponderEnd != null) {
            responderEvent.dispatchConfig.registrationName = 'onResponderEnd';
            onResponderEnd(responderEvent);
          }
        }
        // Release
        if (isReleaseEvent) {
          if (onResponderRelease != null) {
            responderEvent.dispatchConfig.registrationName = 'onResponderRelease';
            onResponderRelease(responderEvent);
          }
          changeCurrentResponder(emptyResponder);
        }
        // Terminate
        if (isTerminateEvent) {
          var shouldTerminate = true;

          // Responders can still avoid termination but only for these events.
          if (eventType === 'contextmenu' || eventType === 'scroll' || eventType === 'selectionchange') {
            // Only call this function is it wasn't already called during negotiation.
            if (wasNegotiated) {
              shouldTerminate = false;
            } else if (onResponderTerminationRequest != null) {
              responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';
              if (onResponderTerminationRequest(responderEvent) === false) {
                shouldTerminate = false;
              }
            }
          }
          if (shouldTerminate) {
            if (onResponderTerminate != null) {
              responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';
              onResponderTerminate(responderEvent);
            }
            changeCurrentResponder(emptyResponder);
            isEmulatingMouseEvents = false;
            trackedTouchCount = 0;
          }
        }
      }
    }
  }

  /**
   * Walk the event path to/from the target node. At each node, stop and call the
   * relevant "shouldSet" functions for the given event type. If any of those functions
   * call "stopPropagation" on the event, stop searching for a responder.
   */
  function findWantsResponder(eventPaths, domEvent, responderEvent) {
    var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type]; // for Flow

    if (shouldSetCallbacks != null) {
      var idPath = eventPaths.idPath,
        nodePath = eventPaths.nodePath;
      var shouldSetCallbackCaptureName = shouldSetCallbacks[0];
      var shouldSetCallbackBubbleName = shouldSetCallbacks[1];
      var bubbles = shouldSetCallbacks[2].bubbles;
      var check = function check(id, node, callbackName) {
        var config = getResponderConfig(id);
        var shouldSetCallback = config[callbackName];
        if (shouldSetCallback != null) {
          responderEvent.currentTarget = node;
          if (shouldSetCallback(responderEvent) === true) {
            // Start the path from the potential responder
            var prunedIdPath = idPath.slice(idPath.indexOf(id));
            return {
              id,
              node,
              idPath: prunedIdPath
            };
          }
        }
      };

      // capture
      for (var i = idPath.length - 1; i >= 0; i--) {
        var id = idPath[i];
        var node = nodePath[i];
        var result = check(id, node, shouldSetCallbackCaptureName);
        if (result != null) {
          return result;
        }
        if (responderEvent.isPropagationStopped() === true) {
          return;
        }
      }

      // bubble
      if (bubbles) {
        for (var _i = 0; _i < idPath.length; _i++) {
          var _id = idPath[_i];
          var _node = nodePath[_i];
          var _result = check(_id, _node, shouldSetCallbackBubbleName);
          if (_result != null) {
            return _result;
          }
          if (responderEvent.isPropagationStopped() === true) {
            return;
          }
        }
      } else {
        var _id2 = idPath[0];
        var _node2 = nodePath[0];
        var target = domEvent.target;
        if (target === _node2) {
          return check(_id2, _node2, shouldSetCallbackBubbleName);
        }
      }
    }
  }

  /**
   * Attempt to transfer the responder.
   */
  function attemptTransfer(responderEvent, wantsResponder) {
    var _currentResponder2 = currentResponder,
      currentId = _currentResponder2.id,
      currentNode = _currentResponder2.node;
    var id = wantsResponder.id,
      node = wantsResponder.node;
    var _getResponderConfig2 = getResponderConfig(id),
      onResponderGrant = _getResponderConfig2.onResponderGrant,
      onResponderReject = _getResponderConfig2.onResponderReject;
    responderEvent.bubbles = false;
    responderEvent.cancelable = false;
    responderEvent.currentTarget = node;

    // Set responder
    if (currentId == null) {
      if (onResponderGrant != null) {
        responderEvent.currentTarget = node;
        responderEvent.dispatchConfig.registrationName = 'onResponderGrant';
        onResponderGrant(responderEvent);
      }
      changeCurrentResponder(wantsResponder);
    }
    // Negotiate with current responder
    else {
      var _getResponderConfig3 = getResponderConfig(currentId),
        onResponderTerminate = _getResponderConfig3.onResponderTerminate,
        onResponderTerminationRequest = _getResponderConfig3.onResponderTerminationRequest;
      var allowTransfer = true;
      if (onResponderTerminationRequest != null) {
        responderEvent.currentTarget = currentNode;
        responderEvent.dispatchConfig.registrationName = 'onResponderTerminationRequest';
        if (onResponderTerminationRequest(responderEvent) === false) {
          allowTransfer = false;
        }
      }
      if (allowTransfer) {
        // Terminate existing responder
        if (onResponderTerminate != null) {
          responderEvent.currentTarget = currentNode;
          responderEvent.dispatchConfig.registrationName = 'onResponderTerminate';
          onResponderTerminate(responderEvent);
        }
        // Grant next responder
        if (onResponderGrant != null) {
          responderEvent.currentTarget = node;
          responderEvent.dispatchConfig.registrationName = 'onResponderGrant';
          onResponderGrant(responderEvent);
        }
        changeCurrentResponder(wantsResponder);
      } else {
        // Reject responder request
        if (onResponderReject != null) {
          responderEvent.currentTarget = node;
          responderEvent.dispatchConfig.registrationName = 'onResponderReject';
          onResponderReject(responderEvent);
        }
      }
    }
  }

  /* ------------ PUBLIC API ------------ */

  /**
   * Attach Listeners
   *
   * Use native events as ReactDOM doesn't have a non-plugin API to implement
   * this system.
   */
  var documentEventsCapturePhase = ['blur', 'scroll'];
  var documentEventsBubblePhase = [
  // mouse
  'mousedown', 'mousemove', 'mouseup', 'dragstart',
  // touch
  'touchstart', 'touchmove', 'touchend', 'touchcancel',
  // other
  'contextmenu', 'select', 'selectionchange'];
  function attachListeners() {
    if (canUseDOM.default && window.__reactResponderSystemActive == null) {
      window.addEventListener('blur', eventListener);
      documentEventsBubblePhase.forEach(eventType => {
        document.addEventListener(eventType, eventListener);
      });
      documentEventsCapturePhase.forEach(eventType => {
        document.addEventListener(eventType, eventListener, true);
      });
      window.__reactResponderSystemActive = true;
    }
  }

  /**
   * Register a node with the ResponderSystem.
   */
  function addNode(id, node, config) {
    (0, _utils.setResponderId)(node, id);
    responderListenersMap.set(id, config);
  }

  /**
   * Unregister a node with the ResponderSystem.
   */
  function removeNode(id) {
    if (currentResponder.id === id) {
      terminateResponder();
    }
    if (responderListenersMap.has(id)) {
      responderListenersMap.delete(id);
    }
  }

  /**
   * Allow the current responder to be terminated from within components to support
   * more complex requirements, such as use with other React libraries for working
   * with scroll views, input views, etc.
   */
  function terminateResponder() {
    var _currentResponder3 = currentResponder,
      id = _currentResponder3.id,
      node = _currentResponder3.node;
    if (id != null && node != null) {
      var _getResponderConfig4 = getResponderConfig(id),
        onResponderTerminate = _getResponderConfig4.onResponderTerminate;
      if (onResponderTerminate != null) {
        var event = (0, createResponderEvent.default)({}, responderTouchHistoryStore);
        event.currentTarget = node;
        onResponderTerminate(event);
      }
      changeCurrentResponder(emptyResponder);
    }
    isEmulatingMouseEvents = false;
    trackedTouchCount = 0;
  }

  /**
   * Allow unit tests to inspect the current responder in the system.
   * FOR TESTING ONLY.
   */
  function getResponderNode() {
    return currentResponder.node;
  }
},148,[149,150,151,153,40]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return createResponderEvent;
    }
  });
  var _modulesGetBoundingClientRect = require(_dependencyMap[0]);
  var getBoundingClientRect = _interopDefault(_modulesGetBoundingClientRect);
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var emptyFunction = () => {};
  var emptyObject = {};
  var emptyArray = [];

  /**
   * Safari produces very large identifiers that would cause the `touchBank` array
   * length to be so large as to crash the browser, if not normalized like this.
   * In the future the `touchBank` should use an object/map instead.
   */
  function normalizeIdentifier(identifier) {
    return identifier > 20 ? identifier % 20 : identifier;
  }

  /**
   * Converts a native DOM event to a ResponderEvent.
   * Mouse events are transformed into fake touch events.
   */
  function createResponderEvent(domEvent, responderTouchHistoryStore) {
    var rect;
    var propagationWasStopped = false;
    var changedTouches;
    var touches;
    var domEventChangedTouches = domEvent.changedTouches;
    var domEventType = domEvent.type;
    var metaKey = domEvent.metaKey === true;
    var shiftKey = domEvent.shiftKey === true;
    var force = domEventChangedTouches && domEventChangedTouches[0].force || 0;
    var identifier = normalizeIdentifier(domEventChangedTouches && domEventChangedTouches[0].identifier || 0);
    var clientX = domEventChangedTouches && domEventChangedTouches[0].clientX || domEvent.clientX;
    var clientY = domEventChangedTouches && domEventChangedTouches[0].clientY || domEvent.clientY;
    var pageX = domEventChangedTouches && domEventChangedTouches[0].pageX || domEvent.pageX;
    var pageY = domEventChangedTouches && domEventChangedTouches[0].pageY || domEvent.pageY;
    var preventDefault = typeof domEvent.preventDefault === 'function' ? domEvent.preventDefault.bind(domEvent) : emptyFunction;
    var timestamp = domEvent.timeStamp;
    function normalizeTouches(touches) {
      return Array.prototype.slice.call(touches).map(touch => {
        return {
          force: touch.force,
          identifier: normalizeIdentifier(touch.identifier),
          get locationX() {
            return locationX(touch.clientX);
          },
          get locationY() {
            return locationY(touch.clientY);
          },
          pageX: touch.pageX,
          pageY: touch.pageY,
          target: touch.target,
          timestamp
        };
      });
    }
    if (domEventChangedTouches != null) {
      changedTouches = normalizeTouches(domEventChangedTouches);
      touches = normalizeTouches(domEvent.touches);
    } else {
      var emulatedTouches = [{
        force,
        identifier,
        get locationX() {
          return locationX(clientX);
        },
        get locationY() {
          return locationY(clientY);
        },
        pageX,
        pageY,
        target: domEvent.target,
        timestamp
      }];
      changedTouches = emulatedTouches;
      touches = domEventType === 'mouseup' || domEventType === 'dragstart' ? emptyArray : emulatedTouches;
    }
    var responderEvent = {
      bubbles: true,
      cancelable: true,
      // `currentTarget` is set before dispatch
      currentTarget: null,
      defaultPrevented: domEvent.defaultPrevented,
      dispatchConfig: emptyObject,
      eventPhase: domEvent.eventPhase,
      isDefaultPrevented() {
        return domEvent.defaultPrevented;
      },
      isPropagationStopped() {
        return propagationWasStopped;
      },
      isTrusted: domEvent.isTrusted,
      nativeEvent: {
        altKey: false,
        ctrlKey: false,
        metaKey,
        shiftKey,
        changedTouches,
        force,
        identifier,
        get locationX() {
          return locationX(clientX);
        },
        get locationY() {
          return locationY(clientY);
        },
        pageX,
        pageY,
        target: domEvent.target,
        timestamp,
        touches,
        type: domEventType
      },
      persist: emptyFunction,
      preventDefault,
      stopPropagation() {
        propagationWasStopped = true;
      },
      target: domEvent.target,
      timeStamp: timestamp,
      touchHistory: responderTouchHistoryStore.touchHistory
    };

    // Using getters and functions serves two purposes:
    // 1) The value of `currentTarget` is not initially available.
    // 2) Measuring the clientRect may cause layout jank and should only be done on-demand.
    function locationX(x) {
      rect = rect || (0, getBoundingClientRect.default)(responderEvent.currentTarget);
      if (rect) {
        return x - rect.left;
      }
    }
    function locationY(y) {
      rect = rect || (0, getBoundingClientRect.default)(responderEvent.currentTarget);
      if (rect) {
        return y - rect.top;
      }
    }
    return responderEvent;
  }
},149,[127]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "BLUR", {
    enumerable: true,
    get: function () {
      return BLUR;
    }
  });
  Object.defineProperty(exports, "CONTEXT_MENU", {
    enumerable: true,
    get: function () {
      return CONTEXT_MENU;
    }
  });
  Object.defineProperty(exports, "FOCUS_OUT", {
    enumerable: true,
    get: function () {
      return FOCUS_OUT;
    }
  });
  Object.defineProperty(exports, "MOUSE_DOWN", {
    enumerable: true,
    get: function () {
      return MOUSE_DOWN;
    }
  });
  Object.defineProperty(exports, "MOUSE_MOVE", {
    enumerable: true,
    get: function () {
      return MOUSE_MOVE;
    }
  });
  Object.defineProperty(exports, "MOUSE_UP", {
    enumerable: true,
    get: function () {
      return MOUSE_UP;
    }
  });
  Object.defineProperty(exports, "MOUSE_CANCEL", {
    enumerable: true,
    get: function () {
      return MOUSE_CANCEL;
    }
  });
  Object.defineProperty(exports, "TOUCH_START", {
    enumerable: true,
    get: function () {
      return TOUCH_START;
    }
  });
  Object.defineProperty(exports, "TOUCH_MOVE", {
    enumerable: true,
    get: function () {
      return TOUCH_MOVE;
    }
  });
  Object.defineProperty(exports, "TOUCH_END", {
    enumerable: true,
    get: function () {
      return TOUCH_END;
    }
  });
  Object.defineProperty(exports, "TOUCH_CANCEL", {
    enumerable: true,
    get: function () {
      return TOUCH_CANCEL;
    }
  });
  Object.defineProperty(exports, "SCROLL", {
    enumerable: true,
    get: function () {
      return SCROLL;
    }
  });
  Object.defineProperty(exports, "SELECT", {
    enumerable: true,
    get: function () {
      return SELECT;
    }
  });
  Object.defineProperty(exports, "SELECTION_CHANGE", {
    enumerable: true,
    get: function () {
      return SELECTION_CHANGE;
    }
  });
  exports.isStartish = isStartish;
  exports.isMoveish = isMoveish;
  exports.isEndish = isEndish;
  exports.isCancelish = isCancelish;
  exports.isScroll = isScroll;
  exports.isSelectionChange = isSelectionChange;
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var BLUR = 'blur';
  var CONTEXT_MENU = 'contextmenu';
  var FOCUS_OUT = 'focusout';
  var MOUSE_DOWN = 'mousedown';
  var MOUSE_MOVE = 'mousemove';
  var MOUSE_UP = 'mouseup';
  var MOUSE_CANCEL = 'dragstart';
  var TOUCH_START = 'touchstart';
  var TOUCH_MOVE = 'touchmove';
  var TOUCH_END = 'touchend';
  var TOUCH_CANCEL = 'touchcancel';
  var SCROLL = 'scroll';
  var SELECT = 'select';
  var SELECTION_CHANGE = 'selectionchange';
  function isStartish(eventType) {
    return eventType === TOUCH_START || eventType === MOUSE_DOWN;
  }
  function isMoveish(eventType) {
    return eventType === TOUCH_MOVE || eventType === MOUSE_MOVE;
  }
  function isEndish(eventType) {
    return eventType === TOUCH_END || eventType === MOUSE_UP || isCancelish(eventType);
  }
  function isCancelish(eventType) {
    return eventType === TOUCH_CANCEL || eventType === MOUSE_CANCEL;
  }
  function isScroll(eventType) {
    return eventType === SCROLL;
  }
  function isSelectionChange(eventType) {
    return eventType === SELECT || eventType === SELECTION_CHANGE;
  }
},150,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.setResponderId = setResponderId;
  exports.getResponderPaths = getResponderPaths;
  exports.getLowestCommonAncestor = getLowestCommonAncestor;
  exports.hasTargetTouches = hasTargetTouches;
  exports.hasValidSelection = hasValidSelection;
  exports.isPrimaryPointerDown = isPrimaryPointerDown;
  var _modulesIsSelectionValid = require(_dependencyMap[0]);
  var isSelectionValid = _interopDefault(_modulesIsSelectionValid);
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var keyName = '__reactResponderId';
  function getEventPath(domEvent) {
    // The 'selectionchange' event always has the 'document' as the target.
    // Use the anchor node as the initial target to reconstruct a path.
    // (We actually only need the first "responder" node in practice.)
    if (domEvent.type === 'selectionchange') {
      var target = window.getSelection().anchorNode;
      return composedPathFallback(target);
    } else {
      var path = domEvent.composedPath != null ? domEvent.composedPath() : composedPathFallback(domEvent.target);
      return path;
    }
  }
  function composedPathFallback(target) {
    var path = [];
    while (target != null && target !== document.body) {
      path.push(target);
      target = target.parentNode;
    }
    return path;
  }

  /**
   * Retrieve the responderId from a host node
   */
  function getResponderId(node) {
    if (node != null) {
      return node[keyName];
    }
    return null;
  }

  /**
   * Store the responderId on a host node
   */
  function setResponderId(node, id) {
    if (node != null) {
      node[keyName] = id;
    }
  }

  /**
   * Filter the event path to contain only the nodes attached to the responder system
   */
  function getResponderPaths(domEvent) {
    var idPath = [];
    var nodePath = [];
    var eventPath = getEventPath(domEvent);
    for (var i = 0; i < eventPath.length; i++) {
      var node = eventPath[i];
      var id = getResponderId(node);
      if (id != null) {
        idPath.push(id);
        nodePath.push(node);
      }
    }
    return {
      idPath,
      nodePath
    };
  }

  /**
   * Walk the paths and find the first common ancestor
   */
  function getLowestCommonAncestor(pathA, pathB) {
    var pathALength = pathA.length;
    var pathBLength = pathB.length;
    if (
    // If either path is empty
    pathALength === 0 || pathBLength === 0 ||
    // If the last elements aren't the same there can't be a common ancestor
    // that is connected to the responder system
    pathA[pathALength - 1] !== pathB[pathBLength - 1]) {
      return null;
    }
    var itemA = pathA[0];
    var indexA = 0;
    var itemB = pathB[0];
    var indexB = 0;

    // If A is deeper, skip indices that can't match.
    if (pathALength - pathBLength > 0) {
      indexA = pathALength - pathBLength;
      itemA = pathA[indexA];
      pathALength = pathBLength;
    }

    // If B is deeper, skip indices that can't match
    if (pathBLength - pathALength > 0) {
      indexB = pathBLength - pathALength;
      itemB = pathB[indexB];
      pathBLength = pathALength;
    }

    // Walk in lockstep until a match is found
    var depth = pathALength;
    while (depth--) {
      if (itemA === itemB) {
        return itemA;
      }
      itemA = pathA[indexA++];
      itemB = pathB[indexB++];
    }
    return null;
  }

  /**
   * Determine whether any of the active touches are within the current responder.
   * This cannot rely on W3C `targetTouches`, as neither IE11 nor Safari implement it.
   */
  function hasTargetTouches(target, touches) {
    if (!touches || touches.length === 0) {
      return false;
    }
    for (var i = 0; i < touches.length; i++) {
      var node = touches[i].target;
      if (node != null) {
        if (target.contains(node)) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Ignore 'selectionchange' events that don't correspond with a person's intent to
   * select text.
   */
  function hasValidSelection(domEvent) {
    if (domEvent.type === 'selectionchange') {
      return (0, isSelectionValid.default)();
    }
    return domEvent.type === 'select';
  }

  /**
   * Events are only valid if the primary button was used without specific modifier keys.
   */
  function isPrimaryPointerDown(domEvent) {
    var altKey = domEvent.altKey,
      button = domEvent.button,
      buttons = domEvent.buttons,
      ctrlKey = domEvent.ctrlKey,
      type = domEvent.type;
    var isTouch = type === 'touchstart' || type === 'touchmove';
    var isPrimaryMouseDown = type === 'mousedown' && (button === 0 || buttons === 1);
    var isPrimaryMouseMove = type === 'mousemove' && buttons === 1;
    var noModifiers = altKey === false && ctrlKey === false;
    if (isTouch || isPrimaryMouseDown && noModifiers || isPrimaryMouseMove && noModifiers) {
      return true;
    }
    return false;
  }
},151,[152]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return isSelectionValid;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function isSelectionValid() {
    var selection = window.getSelection();
    var string = selection.toString();
    var anchorNode = selection.anchorNode;
    var focusNode = selection.focusNode;
    var isTextNode = anchorNode && anchorNode.nodeType === window.Node.TEXT_NODE || focusNode && focusNode.nodeType === window.Node.TEXT_NODE;
    return string.length >= 1 && string !== '\n' && isTextNode;
  }
},152,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "ResponderTouchHistoryStore", {
    enumerable: true,
    get: function () {
      return ResponderTouchHistoryStore;
    }
  });
  var _ResponderEventTypes = require(_dependencyMap[0]);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * Tracks the position and time of each active touch by `touch.identifier`. We
   * should typically only see IDs in the range of 1-20 because IDs get recycled
   * when touches end and start again.
   */

  var __DEV__ = false;
  var MAX_TOUCH_BANK = 20;
  function timestampForTouch(touch) {
    // The legacy internal implementation provides "timeStamp", which has been
    // renamed to "timestamp".
    return touch.timeStamp || touch.timestamp;
  }

  /**
   * TODO: Instead of making gestures recompute filtered velocity, we could
   * include a built in velocity computation that can be reused globally.
   */
  function createTouchRecord(touch) {
    return {
      touchActive: true,
      startPageX: touch.pageX,
      startPageY: touch.pageY,
      startTimeStamp: timestampForTouch(touch),
      currentPageX: touch.pageX,
      currentPageY: touch.pageY,
      currentTimeStamp: timestampForTouch(touch),
      previousPageX: touch.pageX,
      previousPageY: touch.pageY,
      previousTimeStamp: timestampForTouch(touch)
    };
  }
  function resetTouchRecord(touchRecord, touch) {
    touchRecord.touchActive = true;
    touchRecord.startPageX = touch.pageX;
    touchRecord.startPageY = touch.pageY;
    touchRecord.startTimeStamp = timestampForTouch(touch);
    touchRecord.currentPageX = touch.pageX;
    touchRecord.currentPageY = touch.pageY;
    touchRecord.currentTimeStamp = timestampForTouch(touch);
    touchRecord.previousPageX = touch.pageX;
    touchRecord.previousPageY = touch.pageY;
    touchRecord.previousTimeStamp = timestampForTouch(touch);
  }
  function getTouchIdentifier(_ref) {
    var identifier = _ref.identifier;
    if (identifier == null) {
      console.error('Touch object is missing identifier.');
    }
    return identifier;
  }
  function recordTouchStart(touch, touchHistory) {
    var identifier = getTouchIdentifier(touch);
    var touchRecord = touchHistory.touchBank[identifier];
    if (touchRecord) {
      resetTouchRecord(touchRecord, touch);
    } else {
      touchHistory.touchBank[identifier] = createTouchRecord(touch);
    }
    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
  }
  function recordTouchMove(touch, touchHistory) {
    var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];
    if (touchRecord) {
      touchRecord.touchActive = true;
      touchRecord.previousPageX = touchRecord.currentPageX;
      touchRecord.previousPageY = touchRecord.currentPageY;
      touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
      touchRecord.currentPageX = touch.pageX;
      touchRecord.currentPageY = touch.pageY;
      touchRecord.currentTimeStamp = timestampForTouch(touch);
      touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
    } else {
      console.warn('Cannot record touch move without a touch start.\n', "Touch Move: " + printTouch(touch) + "\n", "Touch Bank: " + printTouchBank(touchHistory));
    }
  }
  function recordTouchEnd(touch, touchHistory) {
    var touchRecord = touchHistory.touchBank[getTouchIdentifier(touch)];
    if (touchRecord) {
      touchRecord.touchActive = false;
      touchRecord.previousPageX = touchRecord.currentPageX;
      touchRecord.previousPageY = touchRecord.currentPageY;
      touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
      touchRecord.currentPageX = touch.pageX;
      touchRecord.currentPageY = touch.pageY;
      touchRecord.currentTimeStamp = timestampForTouch(touch);
      touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
    } else {
      console.warn('Cannot record touch end without a touch start.\n', "Touch End: " + printTouch(touch) + "\n", "Touch Bank: " + printTouchBank(touchHistory));
    }
  }
  function printTouch(touch) {
    return JSON.stringify({
      identifier: touch.identifier,
      pageX: touch.pageX,
      pageY: touch.pageY,
      timestamp: timestampForTouch(touch)
    });
  }
  function printTouchBank(touchHistory) {
    var touchBank = touchHistory.touchBank;
    var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));
    if (touchBank.length > MAX_TOUCH_BANK) {
      printed += ' (original size: ' + touchBank.length + ')';
    }
    return printed;
  }
  class ResponderTouchHistoryStore {
    constructor() {
      this._touchHistory = {
        touchBank: [],
        //Array<TouchRecord>
        numberActiveTouches: 0,
        // If there is only one active touch, we remember its location. This prevents
        // us having to loop through all of the touches all the time in the most
        // common case.
        indexOfSingleActiveTouch: -1,
        mostRecentTimeStamp: 0
      };
    }
    recordTouchTrack(topLevelType, nativeEvent) {
      var touchHistory = this._touchHistory;
      if ((0, _ResponderEventTypes.isMoveish)(topLevelType)) {
        nativeEvent.changedTouches.forEach(touch => recordTouchMove(touch, touchHistory));
      } else if ((0, _ResponderEventTypes.isStartish)(topLevelType)) {
        nativeEvent.changedTouches.forEach(touch => recordTouchStart(touch, touchHistory));
        touchHistory.numberActiveTouches = nativeEvent.touches.length;
        if (touchHistory.numberActiveTouches === 1) {
          touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;
        }
      } else if ((0, _ResponderEventTypes.isEndish)(topLevelType)) {
        nativeEvent.changedTouches.forEach(touch => recordTouchEnd(touch, touchHistory));
        touchHistory.numberActiveTouches = nativeEvent.touches.length;
        if (touchHistory.numberActiveTouches === 1) {
          var touchBank = touchHistory.touchBank;
          for (var i = 0; i < touchBank.length; i++) {
            var touchTrackToCheck = touchBank[i];
            if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {
              touchHistory.indexOfSingleActiveTouch = i;
              break;
            }
          }
        }
      }
    }
    get touchHistory() {
      return this._touchHistory;
    }
  }
},153,[150]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _react = require(_dependencyMap[0]);
  var TextAncestorContext = /*#__PURE__*/(0, _react.createContext)(false);
  var _default = TextAncestorContext;
},154,[35]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  /*
   * @returns {bool} true if different, false if equal
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var deepDiffer = function deepDiffer(one, two, maxDepth) {
    if (maxDepth === undefined) {
      maxDepth = -1;
    }
    if (maxDepth === 0) {
      return true;
    }
    if (one === two) {
      // Short circuit on identical object references instead of traversing them.
      return false;
    }
    if (typeof one === 'function' && typeof two === 'function') {
      // We consider all functions equal
      return false;
    }
    if (typeof one !== 'object' || one === null) {
      // Primitives can be directly compared
      return one !== two;
    }
    if (typeof two !== 'object' || two === null) {
      // We know they are different because the previous case would have triggered
      // otherwise.
      return true;
    }
    if (one.constructor !== two.constructor) {
      return true;
    }
    if (Array.isArray(one)) {
      // We know two is also an array because the constructors are equal
      var len = one.length;
      if (two.length !== len) {
        return true;
      }
      for (var ii = 0; ii < len; ii++) {
        if (deepDiffer(one[ii], two[ii], maxDepth - 1)) {
          return true;
        }
      }
    } else {
      for (var key in one) {
        if (deepDiffer(one[key], two[key], maxDepth - 1)) {
          return true;
        }
      }
      for (var twoKey in two) {
        // The only case we haven't checked yet is keys that are in two but aren't
        // in one, which means they are different.
        if (one[twoKey] === undefined && two[twoKey] !== undefined) {
          return true;
        }
      }
    }
    return false;
  };
  var _default = deepDiffer;
},155,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersCreateForOfIteratorHelperLoose = require(_dependencyMap[0]);
  var _createForOfIteratorHelperLoose = _interopDefault(_babelRuntimeHelpersCreateForOfIteratorHelperLoose);
  var _babelRuntimeHelpersExtends = require(_dependencyMap[1]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[2]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _exportsRefreshControl = require(_dependencyMap[3]);
  var RefreshControl = _interopDefault(_exportsRefreshControl);
  var _exportsScrollView = require(_dependencyMap[4]);
  var ScrollView = _interopDefault(_exportsScrollView);
  var _exportsView = require(_dependencyMap[5]);
  var View = _interopDefault(_exportsView);
  var _exportsStyleSheet = require(_dependencyMap[6]);
  var StyleSheet = _interopDefault(_exportsStyleSheet);
  var _Batchinator = require(_dependencyMap[7]);
  var Batchinator = _interopDefault(_Batchinator);
  var _UtilitiesClamp = require(_dependencyMap[8]);
  var clamp = _interopDefault(_UtilitiesClamp);
  var _infoLog = require(_dependencyMap[9]);
  var infoLog = _interopDefault(_infoLog);
  var _CellRenderMask = require(_dependencyMap[10]);
  var _ChildListCollection = require(_dependencyMap[11]);
  var ChildListCollection = _interopDefault(_ChildListCollection);
  var _FillRateHelper = require(_dependencyMap[12]);
  var FillRateHelper = _interopDefault(_FillRateHelper);
  var _StateSafePureComponent = require(_dependencyMap[13]);
  var StateSafePureComponent = _interopDefault(_StateSafePureComponent);
  var _ViewabilityHelper = require(_dependencyMap[14]);
  var ViewabilityHelper = _interopDefault(_ViewabilityHelper);
  var _VirtualizedListCellRenderer = require(_dependencyMap[15]);
  var CellRenderer = _interopDefault(_VirtualizedListCellRenderer);
  var _VirtualizedListContextJs = require(_dependencyMap[16]);
  var _VirtualizeUtils = require(_dependencyMap[17]);
  var _fbjsLibInvariant = require(_dependencyMap[18]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _nullthrows = require(_dependencyMap[19]);
  var nullthrows = _interopDefault(_nullthrows);
  var _react = require(_dependencyMap[20]);
  var React = _interopNamespace(_react);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  var __DEV__ = false;
  var ON_EDGE_REACHED_EPSILON = 0.001;
  var _usedIndexForKey = false;
  var _keylessItemComponentName = '';
  /**
   * Default Props Helper Functions
   * Use the following helper functions for default values
   */

  // horizontalOrDefault(this.props.horizontal)
  function horizontalOrDefault(horizontal) {
    return horizontal !== null && horizontal !== undefined ? horizontal : false;
  }

  // initialNumToRenderOrDefault(this.props.initialNumToRender)
  function initialNumToRenderOrDefault(initialNumToRender) {
    return initialNumToRender !== null && initialNumToRender !== undefined ? initialNumToRender : 10;
  }

  // maxToRenderPerBatchOrDefault(this.props.maxToRenderPerBatch)
  function maxToRenderPerBatchOrDefault(maxToRenderPerBatch) {
    return maxToRenderPerBatch !== null && maxToRenderPerBatch !== undefined ? maxToRenderPerBatch : 10;
  }

  // onStartReachedThresholdOrDefault(this.props.onStartReachedThreshold)
  function onStartReachedThresholdOrDefault(onStartReachedThreshold) {
    return onStartReachedThreshold !== null && onStartReachedThreshold !== undefined ? onStartReachedThreshold : 2;
  }

  // onEndReachedThresholdOrDefault(this.props.onEndReachedThreshold)
  function onEndReachedThresholdOrDefault(onEndReachedThreshold) {
    return onEndReachedThreshold !== null && onEndReachedThreshold !== undefined ? onEndReachedThreshold : 2;
  }

  // getScrollingThreshold(visibleLength, onEndReachedThreshold)
  function getScrollingThreshold(threshold, visibleLength) {
    return threshold * visibleLength / 2;
  }

  // scrollEventThrottleOrDefault(this.props.scrollEventThrottle)
  function scrollEventThrottleOrDefault(scrollEventThrottle) {
    return scrollEventThrottle !== null && scrollEventThrottle !== undefined ? scrollEventThrottle : 50;
  }

  // windowSizeOrDefault(this.props.windowSize)
  function windowSizeOrDefault(windowSize) {
    return windowSize !== null && windowSize !== undefined ? windowSize : 21;
  }
  function findLastWhere(arr, predicate) {
    for (var i = arr.length - 1; i >= 0; i--) {
      if (predicate(arr[i])) {
        return arr[i];
      }
    }
    return null;
  }

  /**
   * Base implementation for the more convenient [`<FlatList>`](https://reactnative.dev/docs/flatlist)
   * and [`<SectionList>`](https://reactnative.dev/docs/sectionlist) components, which are also better
   * documented. In general, this should only really be used if you need more flexibility than
   * `FlatList` provides, e.g. for use with immutable data instead of plain arrays.
   *
   * Virtualization massively improves memory consumption and performance of large lists by
   * maintaining a finite render window of active items and replacing all items outside of the render
   * window with appropriately sized blank space. The window adapts to scrolling behavior, and items
   * are rendered incrementally with low-pri (after any running interactions) if they are far from the
   * visible area, or with hi-pri otherwise to minimize the potential of seeing blank space.
   *
   * Some caveats:
   *
   * - Internal state is not preserved when content scrolls out of the render window. Make sure all
   *   your data is captured in the item data or external stores like Flux, Redux, or Relay.
   * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-
   *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop
   *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on
   *   changes. This includes the `data` prop and parent component state.
   * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously
   *   offscreen. This means it's possible to scroll faster than the fill rate ands momentarily see
   *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,
   *   and we are working on improving it behind the scenes.
   * - By default, the list looks for a `key` or `id` prop on each item and uses that for the React key.
   *   Alternatively, you can provide a custom `keyExtractor` prop.
   * - As an effort to remove defaultProps, use helper functions when referencing certain props
   *
   */
  class VirtualizedList extends StateSafePureComponent.default {
    // scrollToEnd may be janky without getItemLayout prop
    scrollToEnd(params) {
      var animated = params ? params.animated : true;
      var veryLast = this.props.getItemCount(this.props.data) - 1;
      if (veryLast < 0) {
        return;
      }
      var frame = this.__getFrameMetricsApprox(veryLast, this.props);
      var offset = Math.max(0, frame.offset + frame.length + this._footerLength - this._scrollMetrics.visibleLength);
      if (this._scrollRef == null) {
        return;
      }
      if (this._scrollRef.scrollTo == null) {
        console.warn("No scrollTo method provided. This may be because you have two nested VirtualizedLists with the same orientation, or because you are using a custom component that does not implement scrollTo.");
        return;
      }
      this._scrollRef.scrollTo(horizontalOrDefault(this.props.horizontal) ? {
        x: offset,
        animated
      } : {
        y: offset,
        animated
      });
    }

    // scrollToIndex may be janky without getItemLayout prop
    scrollToIndex(params) {
      var _this$props = this.props,
        data = _this$props.data,
        horizontal = _this$props.horizontal,
        getItemCount = _this$props.getItemCount,
        getItemLayout = _this$props.getItemLayout,
        onScrollToIndexFailed = _this$props.onScrollToIndexFailed;
      var animated = params.animated,
        index = params.index,
        viewOffset = params.viewOffset,
        viewPosition = params.viewPosition;
      (0, invariant.default)(index >= 0, "scrollToIndex out of range: requested index " + index + " but minimum is 0");
      (0, invariant.default)(getItemCount(data) >= 1, "scrollToIndex out of range: item length " + getItemCount(data) + " but minimum is 1");
      (0, invariant.default)(index < getItemCount(data), "scrollToIndex out of range: requested index " + index + " is out of 0 to " + (getItemCount(data) - 1));
      if (!getItemLayout && index > this._highestMeasuredFrameIndex) {
        (0, invariant.default)(!!onScrollToIndexFailed, "scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, otherwise there is no way to know the location of offscreen indices or handle failures.");
        onScrollToIndexFailed({
          averageItemLength: this._averageCellLength,
          highestMeasuredFrameIndex: this._highestMeasuredFrameIndex,
          index
        });
        return;
      }
      var frame = this.__getFrameMetricsApprox(Math.floor(index), this.props);
      var offset = Math.max(0, this._getOffsetApprox(index, this.props) - (viewPosition || 0) * (this._scrollMetrics.visibleLength - frame.length)) - (viewOffset || 0);
      if (this._scrollRef == null) {
        return;
      }
      if (this._scrollRef.scrollTo == null) {
        console.warn("No scrollTo method provided. This may be because you have two nested VirtualizedLists with the same orientation, or because you are using a custom component that does not implement scrollTo.");
        return;
      }
      this._scrollRef.scrollTo(horizontal ? {
        x: offset,
        animated
      } : {
        y: offset,
        animated
      });
    }

    // scrollToItem may be janky without getItemLayout prop. Required linear scan through items -
    // use scrollToIndex instead if possible.
    scrollToItem(params) {
      var item = params.item;
      var _this$props2 = this.props,
        data = _this$props2.data,
        getItem = _this$props2.getItem,
        getItemCount = _this$props2.getItemCount;
      var itemCount = getItemCount(data);
      for (var _index = 0; _index < itemCount; _index++) {
        if (getItem(data, _index) === item) {
          this.scrollToIndex((0, _objectSpread.default)((0, _objectSpread.default)({}, params), {}, {
            index: _index
          }));
          break;
        }
      }
    }

    /**
     * Scroll to a specific content pixel offset in the list.
     *
     * Param `offset` expects the offset to scroll to.
     * In case of `horizontal` is true, the offset is the x-value,
     * in any other case the offset is the y-value.
     *
     * Param `animated` (`true` by default) defines whether the list
     * should do an animation while scrolling.
     */
    scrollToOffset(params) {
      var animated = params.animated,
        offset = params.offset;
      if (this._scrollRef == null) {
        return;
      }
      if (this._scrollRef.scrollTo == null) {
        console.warn("No scrollTo method provided. This may be because you have two nested VirtualizedLists with the same orientation, or because you are using a custom component that does not implement scrollTo.");
        return;
      }
      this._scrollRef.scrollTo(horizontalOrDefault(this.props.horizontal) ? {
        x: offset,
        animated
      } : {
        y: offset,
        animated
      });
    }
    recordInteraction() {
      this._nestedChildLists.forEach(childList => {
        childList.recordInteraction();
      });
      this._viewabilityTuples.forEach(t => {
        t.viewabilityHelper.recordInteraction();
      });
      this._updateViewableItems(this.props, this.state.cellsAroundViewport);
    }
    flashScrollIndicators() {
      if (this._scrollRef == null) {
        return;
      }
      this._scrollRef.flashScrollIndicators();
    }

    /**
     * Provides a handle to the underlying scroll responder.
     * Note that `this._scrollRef` might not be a `ScrollView`, so we
     * need to check that it responds to `getScrollResponder` before calling it.
     */
    getScrollResponder() {
      if (this._scrollRef && this._scrollRef.getScrollResponder) {
        return this._scrollRef.getScrollResponder();
      }
    }
    getScrollableNode() {
      if (this._scrollRef && this._scrollRef.getScrollableNode) {
        return this._scrollRef.getScrollableNode();
      } else {
        return this._scrollRef;
      }
    }
    getScrollRef() {
      if (this._scrollRef && this._scrollRef.getScrollRef) {
        return this._scrollRef.getScrollRef();
      } else {
        return this._scrollRef;
      }
    }
    _getCellKey() {
      var _this$context;
      return ((_this$context = this.context) == null ? undefined : _this$context.cellKey) || 'rootList';
    }

    // $FlowFixMe[missing-local-annot]

    hasMore() {
      return this._hasMore;
    }

    // $FlowFixMe[missing-local-annot]

    // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.

    constructor(_props) {
      var _this$props$updateCel;
      super(_props);
      this._getScrollMetrics = () => {
        return this._scrollMetrics;
      };
      this._getOutermostParentListRef = () => {
        if (this._isNestedWithSameOrientation()) {
          return this.context.getOutermostParentListRef();
        } else {
          return this;
        }
      };
      this._registerAsNestedChild = childList => {
        this._nestedChildLists.add(childList.ref, childList.cellKey);
        if (this._hasInteracted) {
          childList.ref.recordInteraction();
        }
      };
      this._unregisterAsNestedChild = childList => {
        this._nestedChildLists.remove(childList.ref);
      };
      this._onUpdateSeparators = (keys, newProps) => {
        keys.forEach(key => {
          var ref = key != null && this._cellRefs[key];
          ref && ref.updateSeparatorProps(newProps);
        });
      };
      this._getSpacerKey = isVertical => isVertical ? 'height' : 'width';
      this._averageCellLength = 0;
      this._cellRefs = {};
      this._frames = {};
      this._footerLength = 0;
      this._hasTriggeredInitialScrollToIndex = false;
      this._hasInteracted = false;
      this._hasMore = false;
      this._hasWarned = {};
      this._headerLength = 0;
      this._hiPriInProgress = false;
      this._highestMeasuredFrameIndex = 0;
      this._indicesToKeys = new Map();
      this._lastFocusedCellKey = null;
      this._nestedChildLists = new ChildListCollection.default();
      this._offsetFromParentVirtualizedList = 0;
      this._prevParentOffset = 0;
      this._scrollMetrics = {
        contentLength: 0,
        dOffset: 0,
        dt: 10,
        offset: 0,
        timestamp: 0,
        velocity: 0,
        visibleLength: 0,
        zoomScale: 1
      };
      this._scrollRef = null;
      this._sentStartForContentLength = 0;
      this._sentEndForContentLength = 0;
      this._totalCellLength = 0;
      this._totalCellsMeasured = 0;
      this._viewabilityTuples = [];
      this._captureScrollRef = ref => {
        this._scrollRef = ref;
      };
      this._defaultRenderScrollComponent = props => {
        var onRefresh = props.onRefresh;
        if (this._isNestedWithSameOrientation()) {
          // $FlowFixMe[prop-missing] - Typing ReactNativeComponent revealed errors
          return /*#__PURE__*/React.createElement(View.default, props);
        } else if (onRefresh) {
          var _props$refreshing;
          (0, invariant.default)(typeof props.refreshing === 'boolean', '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' + JSON.stringify((_props$refreshing = props.refreshing) !== null && _props$refreshing !== undefined ? _props$refreshing : 'undefined') + '`');
          return (/*#__PURE__*/
            // $FlowFixMe[prop-missing] Invalid prop usage
            // $FlowFixMe[incompatible-use]
            React.createElement(ScrollView.default, (0, _extends.default)({}, props, {
              refreshControl: props.refreshControl == null ? /*#__PURE__*/React.createElement(RefreshControl.default // $FlowFixMe[incompatible-type]
              , {
                refreshing: props.refreshing,
                onRefresh: onRefresh,
                progressViewOffset: props.progressViewOffset
              }) : props.refreshControl
            }))
          );
        } else {
          // $FlowFixMe[prop-missing] Invalid prop usage
          // $FlowFixMe[incompatible-use]
          return /*#__PURE__*/React.createElement(ScrollView.default, props);
        }
      };
      this._onCellLayout = (e, cellKey, index) => {
        var layout = e.nativeEvent.layout;
        var next = {
          offset: this._selectOffset(layout),
          length: this._selectLength(layout),
          index,
          inLayout: true
        };
        var curr = this._frames[cellKey];
        if (!curr || next.offset !== curr.offset || next.length !== curr.length || index !== curr.index) {
          this._totalCellLength += next.length - (curr ? curr.length : 0);
          this._totalCellsMeasured += curr ? 0 : 1;
          this._averageCellLength = this._totalCellLength / this._totalCellsMeasured;
          this._frames[cellKey] = next;
          this._highestMeasuredFrameIndex = Math.max(this._highestMeasuredFrameIndex, index);
          this._scheduleCellsToRenderUpdate();
        } else {
          this._frames[cellKey].inLayout = true;
        }
        this._triggerRemeasureForChildListsInCell(cellKey);
        this._computeBlankness();
        this._updateViewableItems(this.props, this.state.cellsAroundViewport);
      };
      this._onCellUnmount = cellKey => {
        delete this._cellRefs[cellKey];
        var curr = this._frames[cellKey];
        if (curr) {
          this._frames[cellKey] = (0, _objectSpread.default)((0, _objectSpread.default)({}, curr), {}, {
            inLayout: false
          });
        }
      };
      this._onLayout = e => {
        if (this._isNestedWithSameOrientation()) {
          // Need to adjust our scroll metrics to be relative to our containing
          // VirtualizedList before we can make claims about list item viewability
          this.measureLayoutRelativeToContainingList();
        } else {
          this._scrollMetrics.visibleLength = this._selectLength(e.nativeEvent.layout);
        }
        this.props.onLayout && this.props.onLayout(e);
        this._scheduleCellsToRenderUpdate();
        this._maybeCallOnEdgeReached();
      };
      this._onLayoutEmpty = e => {
        this.props.onLayout && this.props.onLayout(e);
      };
      this._onLayoutFooter = e => {
        this._triggerRemeasureForChildListsInCell(this._getFooterCellKey());
        this._footerLength = this._selectLength(e.nativeEvent.layout);
      };
      this._onLayoutHeader = e => {
        this._headerLength = this._selectLength(e.nativeEvent.layout);
      };
      this._onContentSizeChange = (width, height) => {
        if (width > 0 && height > 0 && this.props.initialScrollIndex != null && this.props.initialScrollIndex > 0 && !this._hasTriggeredInitialScrollToIndex) {
          if (this.props.contentOffset == null) {
            if (this.props.initialScrollIndex < this.props.getItemCount(this.props.data)) {
              this.scrollToIndex({
                animated: false,
                index: (0, nullthrows.default)(this.props.initialScrollIndex)
              });
            } else {
              this.scrollToEnd({
                animated: false
              });
            }
          }
          this._hasTriggeredInitialScrollToIndex = true;
        }
        if (this.props.onContentSizeChange) {
          this.props.onContentSizeChange(width, height);
        }
        this._scrollMetrics.contentLength = this._selectLength({
          height,
          width
        });
        this._scheduleCellsToRenderUpdate();
        this._maybeCallOnEdgeReached();
      };
      this._convertParentScrollMetrics = metrics => {
        // Offset of the top of the nested list relative to the top of its parent's viewport
        var offset = metrics.offset - this._offsetFromParentVirtualizedList;
        // Child's visible length is the same as its parent's
        var visibleLength = metrics.visibleLength;
        var dOffset = offset - this._scrollMetrics.offset;
        var contentLength = this._scrollMetrics.contentLength;
        return {
          visibleLength,
          contentLength,
          offset,
          dOffset
        };
      };
      this._onScroll = e => {
        this._nestedChildLists.forEach(childList => {
          childList._onScroll(e);
        });
        if (this.props.onScroll) {
          this.props.onScroll(e);
        }
        var timestamp = e.timeStamp;
        var visibleLength = this._selectLength(e.nativeEvent.layoutMeasurement);
        var contentLength = this._selectLength(e.nativeEvent.contentSize);
        var offset = this._selectOffset(e.nativeEvent.contentOffset);
        var dOffset = offset - this._scrollMetrics.offset;
        if (this._isNestedWithSameOrientation()) {
          if (this._scrollMetrics.contentLength === 0) {
            // Ignore scroll events until onLayout has been called and we
            // know our offset from our offset from our parent
            return;
          }
          var _this$_convertParentS = this._convertParentScrollMetrics({
            visibleLength,
            offset
          });
          visibleLength = _this$_convertParentS.visibleLength;
          contentLength = _this$_convertParentS.contentLength;
          offset = _this$_convertParentS.offset;
          dOffset = _this$_convertParentS.dOffset;
        }
        var dt = this._scrollMetrics.timestamp ? Math.max(1, timestamp - this._scrollMetrics.timestamp) : 1;
        var velocity = dOffset / dt;
        if (dt > 500 && this._scrollMetrics.dt > 500 && contentLength > 5 * visibleLength && !this._hasWarned.perf) {
          (0, infoLog.default)("VirtualizedList: You have a large list that is slow to update - make sure your renderItem function renders components that follow React performance best practices like PureComponent, shouldComponentUpdate, etc.", {
            dt,
            prevDt: this._scrollMetrics.dt,
            contentLength
          });
          this._hasWarned.perf = true;
        }

        // For invalid negative values (w/ RTL), set this to 1.
        var zoomScale = e.nativeEvent.zoomScale < 0 ? 1 : e.nativeEvent.zoomScale;
        this._scrollMetrics = {
          contentLength,
          dt,
          dOffset,
          offset,
          timestamp,
          velocity,
          visibleLength,
          zoomScale
        };
        this._updateViewableItems(this.props, this.state.cellsAroundViewport);
        if (!this.props) {
          return;
        }
        this._maybeCallOnEdgeReached();
        if (velocity !== 0) {
          this._fillRateHelper.activate();
        }
        this._computeBlankness();
        this._scheduleCellsToRenderUpdate();
      };
      this._onScrollBeginDrag = e => {
        this._nestedChildLists.forEach(childList => {
          childList._onScrollBeginDrag(e);
        });
        this._viewabilityTuples.forEach(tuple => {
          tuple.viewabilityHelper.recordInteraction();
        });
        this._hasInteracted = true;
        this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);
      };
      this._onScrollEndDrag = e => {
        this._nestedChildLists.forEach(childList => {
          childList._onScrollEndDrag(e);
        });
        var velocity = e.nativeEvent.velocity;
        if (velocity) {
          this._scrollMetrics.velocity = this._selectOffset(velocity);
        }
        this._computeBlankness();
        this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);
      };
      this._onMomentumScrollBegin = e => {
        this._nestedChildLists.forEach(childList => {
          childList._onMomentumScrollBegin(e);
        });
        this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);
      };
      this._onMomentumScrollEnd = e => {
        this._nestedChildLists.forEach(childList => {
          childList._onMomentumScrollEnd(e);
        });
        this._scrollMetrics.velocity = 0;
        this._computeBlankness();
        this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);
      };
      this._updateCellsToRender = () => {
        this._updateViewableItems(this.props, this.state.cellsAroundViewport);
        this.setState((state, props) => {
          var cellsAroundViewport = this._adjustCellsAroundViewport(props, state.cellsAroundViewport);
          var renderMask = VirtualizedList._createRenderMask(props, cellsAroundViewport, this._getNonViewportRenderRegions(props));
          if (cellsAroundViewport.first === state.cellsAroundViewport.first && cellsAroundViewport.last === state.cellsAroundViewport.last && renderMask.equals(state.renderMask)) {
            return null;
          }
          return {
            cellsAroundViewport,
            renderMask
          };
        });
      };
      this._createViewToken = (index, isViewable, props
      // $FlowFixMe[missing-local-annot]
      ) => {
        var data = props.data,
          getItem = props.getItem;
        var item = getItem(data, index);
        return {
          index,
          item,
          key: this._keyExtractor(item, index, props),
          isViewable
        };
      };
      this._getOffsetApprox = (index, props) => {
        if (Number.isInteger(index)) {
          return this.__getFrameMetricsApprox(index, props).offset;
        } else {
          var frameMetrics = this.__getFrameMetricsApprox(Math.floor(index), props);
          var remainder = index - Math.floor(index);
          return frameMetrics.offset + remainder * frameMetrics.length;
        }
      };
      this.__getFrameMetricsApprox = (index, props) => {
        var frame = this._getFrameMetrics(index, props);
        if (frame && frame.index === index) {
          // check for invalid frames due to row re-ordering
          return frame;
        } else {
          var data = props.data,
            getItemCount = props.getItemCount,
            getItemLayout = props.getItemLayout;
          (0, invariant.default)(index >= 0 && index < getItemCount(data), 'Tried to get frame for out of range index ' + index);
          (0, invariant.default)(!getItemLayout, 'Should not have to estimate frames when a measurement metrics function is provided');
          return {
            length: this._averageCellLength,
            offset: this._averageCellLength * index
          };
        }
      };
      this._getFrameMetrics = (index, props) => {
        var data = props.data,
          getItem = props.getItem,
          getItemCount = props.getItemCount,
          getItemLayout = props.getItemLayout;
        (0, invariant.default)(index >= 0 && index < getItemCount(data), 'Tried to get frame for out of range index ' + index);
        var item = getItem(data, index);
        var frame = this._frames[this._keyExtractor(item, index, props)];
        if (!frame || frame.index !== index) {
          if (getItemLayout) {
            /* $FlowFixMe[prop-missing] (>=0.63.0 site=react_native_fb) This comment
             * suppresses an error found when Flow v0.63 was deployed. To see the error
             * delete this comment and run Flow. */
            return getItemLayout(data, index);
          }
        }
        return frame;
      };
      this._getNonViewportRenderRegions = props => {
        // Keep a viewport's worth of content around the last focused cell to allow
        // random navigation around it without any blanking. E.g. tabbing from one
        // focused item out of viewport to another.
        if (!(this._lastFocusedCellKey && this._cellRefs[this._lastFocusedCellKey])) {
          return [];
        }
        var lastFocusedCellRenderer = this._cellRefs[this._lastFocusedCellKey];
        var focusedCellIndex = lastFocusedCellRenderer.props.index;
        var itemCount = props.getItemCount(props.data);

        // The last cell we rendered may be at a new index. Bail if we don't know
        // where it is.
        if (focusedCellIndex >= itemCount || this._keyExtractor(props.getItem(props.data, focusedCellIndex), focusedCellIndex, props) !== this._lastFocusedCellKey) {
          return [];
        }
        var first = focusedCellIndex;
        var heightOfCellsBeforeFocused = 0;
        for (var i = first - 1; i >= 0 && heightOfCellsBeforeFocused < this._scrollMetrics.visibleLength; i--) {
          first--;
          heightOfCellsBeforeFocused += this.__getFrameMetricsApprox(i, props).length;
        }
        var last = focusedCellIndex;
        var heightOfCellsAfterFocused = 0;
        for (var _i = last + 1; _i < itemCount && heightOfCellsAfterFocused < this._scrollMetrics.visibleLength; _i++) {
          last++;
          heightOfCellsAfterFocused += this.__getFrameMetricsApprox(_i, props).length;
        }
        return [{
          first,
          last
        }];
      };
      this._checkProps(_props);
      this._fillRateHelper = new FillRateHelper.default(this._getFrameMetrics);
      this._updateCellsToRenderBatcher = new Batchinator.default(this._updateCellsToRender, (_this$props$updateCel = this.props.updateCellsBatchingPeriod) !== null && _this$props$updateCel !== undefined ? _this$props$updateCel : 50);
      if (this.props.viewabilityConfigCallbackPairs) {
        this._viewabilityTuples = this.props.viewabilityConfigCallbackPairs.map(pair => ({
          viewabilityHelper: new ViewabilityHelper.default(pair.viewabilityConfig),
          onViewableItemsChanged: pair.onViewableItemsChanged
        }));
      } else {
        var _this$props3 = this.props,
          onViewableItemsChanged = _this$props3.onViewableItemsChanged,
          viewabilityConfig = _this$props3.viewabilityConfig;
        if (onViewableItemsChanged) {
          this._viewabilityTuples.push({
            viewabilityHelper: new ViewabilityHelper.default(viewabilityConfig),
            onViewableItemsChanged: onViewableItemsChanged
          });
        }
      }
      var initialRenderRegion = VirtualizedList._initialRenderRegion(_props);
      this.state = {
        cellsAroundViewport: initialRenderRegion,
        renderMask: VirtualizedList._createRenderMask(_props, initialRenderRegion)
      };

      // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
      // For issue https://github.com/necolas/react-native-web/issues/995
      this.invertedWheelEventHandler = ev => {
        var scrollOffset = this.props.horizontal ? ev.target.scrollLeft : ev.target.scrollTop;
        var scrollLength = this.props.horizontal ? ev.target.scrollWidth : ev.target.scrollHeight;
        var clientLength = this.props.horizontal ? ev.target.clientWidth : ev.target.clientHeight;
        var isEventTargetScrollable = scrollLength > clientLength;
        var delta = this.props.horizontal ? ev.deltaX || ev.wheelDeltaX : ev.deltaY || ev.wheelDeltaY;
        var leftoverDelta = delta;
        if (isEventTargetScrollable) {
          leftoverDelta = delta < 0 ? Math.min(delta + scrollOffset, 0) : Math.max(delta - (scrollLength - clientLength - scrollOffset), 0);
        }
        var targetDelta = delta - leftoverDelta;
        if (this.props.inverted && this._scrollRef && this._scrollRef.getScrollableNode) {
          var node = this._scrollRef.getScrollableNode();
          if (this.props.horizontal) {
            ev.target.scrollLeft += targetDelta;
            var nextScrollLeft = node.scrollLeft - leftoverDelta;
            node.scrollLeft = !this.props.getItemLayout ? Math.min(nextScrollLeft, this._totalCellLength) : nextScrollLeft;
          } else {
            ev.target.scrollTop += targetDelta;
            var nextScrollTop = node.scrollTop - leftoverDelta;
            node.scrollTop = !this.props.getItemLayout ? Math.min(nextScrollTop, this._totalCellLength) : nextScrollTop;
          }
          ev.preventDefault();
        }
      };
    }
    _checkProps(props) {
      var onScroll = props.onScroll,
        windowSize = props.windowSize,
        getItemCount = props.getItemCount,
        data = props.data,
        initialScrollIndex = props.initialScrollIndex;
      (0, invariant.default)(
      // $FlowFixMe[prop-missing]
      !onScroll || !onScroll.__isNative, "Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent to support native onScroll events with useNativeDriver");
      (0, invariant.default)(windowSizeOrDefault(windowSize) > 0, 'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.');
      (0, invariant.default)(getItemCount, 'VirtualizedList: The "getItemCount" prop must be provided');
      var itemCount = getItemCount(data);
      if (initialScrollIndex != null && !this._hasTriggeredInitialScrollToIndex && (initialScrollIndex < 0 || itemCount > 0 && initialScrollIndex >= itemCount) && !this._hasWarned.initialScrollIndex) {
        console.warn("initialScrollIndex \"" + initialScrollIndex + "\" is not valid (list has " + itemCount + " items)");
        this._hasWarned.initialScrollIndex = true;
      }
    }
    static _createRenderMask(props, cellsAroundViewport, additionalRegions) {
      var itemCount = props.getItemCount(props.data);
      (0, invariant.default)(cellsAroundViewport.first >= 0 && cellsAroundViewport.last >= cellsAroundViewport.first - 1 && cellsAroundViewport.last < itemCount, "Invalid cells around viewport \"[" + cellsAroundViewport.first + ", " + cellsAroundViewport.last + "]\" was passed to VirtualizedList._createRenderMask");
      var renderMask = new _CellRenderMask.CellRenderMask(itemCount);
      if (itemCount > 0) {
        var allRegions = [cellsAroundViewport, ...(additionalRegions !== null && additionalRegions !== undefined ? additionalRegions : [])];
        for (var _i2 = 0, _allRegions = allRegions; _i2 < _allRegions.length; _i2++) {
          var region = _allRegions[_i2];
          renderMask.addCells(region);
        }

        // The initially rendered cells are retained as part of the
        // "scroll-to-top" optimization
        if (props.initialScrollIndex == null || props.initialScrollIndex <= 0) {
          var initialRegion = VirtualizedList._initialRenderRegion(props);
          renderMask.addCells(initialRegion);
        }

        // The layout coordinates of sticker headers may be off-screen while the
        // actual header is on-screen. Keep the most recent before the viewport
        // rendered, even if its layout coordinates are not in viewport.
        var stickyIndicesSet = new Set(props.stickyHeaderIndices);
        VirtualizedList._ensureClosestStickyHeader(props, stickyIndicesSet, renderMask, cellsAroundViewport.first);
      }
      return renderMask;
    }
    static _initialRenderRegion(props) {
      var _props$initialScrollI;
      var itemCount = props.getItemCount(props.data);
      var firstCellIndex = Math.max(0, Math.min(itemCount - 1, Math.floor((_props$initialScrollI = props.initialScrollIndex) !== null && _props$initialScrollI !== undefined ? _props$initialScrollI : 0)));
      var lastCellIndex = Math.min(itemCount, firstCellIndex + initialNumToRenderOrDefault(props.initialNumToRender)) - 1;
      return {
        first: firstCellIndex,
        last: lastCellIndex
      };
    }
    static _ensureClosestStickyHeader(props, stickyIndicesSet, renderMask, cellIdx) {
      var stickyOffset = props.ListHeaderComponent ? 1 : 0;
      for (var itemIdx = cellIdx - 1; itemIdx >= 0; itemIdx--) {
        if (stickyIndicesSet.has(itemIdx + stickyOffset)) {
          renderMask.addCells({
            first: itemIdx,
            last: itemIdx
          });
          break;
        }
      }
    }
    _adjustCellsAroundViewport(props, cellsAroundViewport) {
      var data = props.data,
        getItemCount = props.getItemCount;
      var onEndReachedThreshold = onEndReachedThresholdOrDefault(props.onEndReachedThreshold);
      var _this$_scrollMetrics = this._scrollMetrics,
        contentLength = _this$_scrollMetrics.contentLength,
        offset = _this$_scrollMetrics.offset,
        visibleLength = _this$_scrollMetrics.visibleLength;
      var distanceFromEnd = contentLength - visibleLength - offset;

      // Wait until the scroll view metrics have been set up. And until then,
      // we will trust the initialNumToRender suggestion
      if (visibleLength <= 0 || contentLength <= 0) {
        return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;
      }
      var newCellsAroundViewport;
      if (props.disableVirtualization) {
        var renderAhead = distanceFromEnd < onEndReachedThreshold * visibleLength ? maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch) : 0;
        newCellsAroundViewport = {
          first: 0,
          last: Math.min(cellsAroundViewport.last + renderAhead, getItemCount(data) - 1)
        };
      } else {
        // If we have a non-zero initialScrollIndex and run this before we've scrolled,
        // we'll wipe out the initialNumToRender rendered elements starting at initialScrollIndex.
        // So let's wait until we've scrolled the view to the right place. And until then,
        // we will trust the initialScrollIndex suggestion.

        // Thus, we want to recalculate the windowed render limits if any of the following hold:
        // - initialScrollIndex is undefined or is 0
        // - initialScrollIndex > 0 AND scrolling is complete
        // - initialScrollIndex > 0 AND the end of the list is visible (this handles the case
        //   where the list is shorter than the visible area)
        if (props.initialScrollIndex && !this._scrollMetrics.offset && Math.abs(distanceFromEnd) >= Number.EPSILON) {
          return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;
        }
        newCellsAroundViewport = (0, _VirtualizeUtils.computeWindowedRenderLimits)(props, maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch), windowSizeOrDefault(props.windowSize), cellsAroundViewport, this.__getFrameMetricsApprox, this._scrollMetrics);
        (0, invariant.default)(newCellsAroundViewport.last < getItemCount(data), 'computeWindowedRenderLimits() should return range in-bounds');
      }
      if (this._nestedChildLists.size() > 0) {
        // If some cell in the new state has a child list in it, we should only render
        // up through that item, so that we give that list a chance to render.
        // Otherwise there's churn from multiple child lists mounting and un-mounting
        // their items.

        // Will this prevent rendering if the nested list doesn't realize the end?
        var childIdx = this._findFirstChildWithMore(newCellsAroundViewport.first, newCellsAroundViewport.last);
        newCellsAroundViewport.last = childIdx !== null && childIdx !== undefined ? childIdx : newCellsAroundViewport.last;
      }
      return newCellsAroundViewport;
    }
    _findFirstChildWithMore(first, last) {
      for (var ii = first; ii <= last; ii++) {
        var cellKeyForIndex = this._indicesToKeys.get(ii);
        if (cellKeyForIndex != null && this._nestedChildLists.anyInCell(cellKeyForIndex, childList => childList.hasMore())) {
          return ii;
        }
      }
      return null;
    }
    componentDidMount() {
      if (this._isNestedWithSameOrientation()) {
        this.context.registerAsNestedChild({
          ref: this,
          cellKey: this.context.cellKey
        });
      }

      // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
      this.setupWebWheelHandler();
    }
    componentWillUnmount() {
      if (this._isNestedWithSameOrientation()) {
        this.context.unregisterAsNestedChild({
          ref: this
        });
      }
      this._updateCellsToRenderBatcher.dispose({
        abort: true
      });
      this._viewabilityTuples.forEach(tuple => {
        tuple.viewabilityHelper.dispose();
      });
      this._fillRateHelper.deactivateAndFlush();

      // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
      this.teardownWebWheelHandler();
    }

    // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
    setupWebWheelHandler() {
      if (this._scrollRef && this._scrollRef.getScrollableNode) {
        this._scrollRef.getScrollableNode().addEventListener('wheel', this.invertedWheelEventHandler);
      } else {
        setTimeout(() => this.setupWebWheelHandler(), 50);
        return;
      }
    }

    // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
    teardownWebWheelHandler() {
      if (this._scrollRef && this._scrollRef.getScrollableNode) {
        this._scrollRef.getScrollableNode().removeEventListener('wheel', this.invertedWheelEventHandler);
      }
    }
    static getDerivedStateFromProps(newProps, prevState) {
      // first and last could be stale (e.g. if a new, shorter items props is passed in), so we make
      // sure we're rendering a reasonable range here.
      var itemCount = newProps.getItemCount(newProps.data);
      if (itemCount === prevState.renderMask.numCells()) {
        return prevState;
      }
      var constrainedCells = VirtualizedList._constrainToItemCount(prevState.cellsAroundViewport, newProps);
      return {
        cellsAroundViewport: constrainedCells,
        renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells)
      };
    }
    _pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, first, last, inversionStyle) {
      var _this = this;
      var _this$props4 = this.props,
        CellRendererComponent = _this$props4.CellRendererComponent,
        ItemSeparatorComponent = _this$props4.ItemSeparatorComponent,
        ListHeaderComponent = _this$props4.ListHeaderComponent,
        ListItemComponent = _this$props4.ListItemComponent,
        data = _this$props4.data,
        debug = _this$props4.debug,
        getItem = _this$props4.getItem,
        getItemCount = _this$props4.getItemCount,
        getItemLayout = _this$props4.getItemLayout,
        horizontal = _this$props4.horizontal,
        renderItem = _this$props4.renderItem;
      var stickyOffset = ListHeaderComponent ? 1 : 0;
      var end = getItemCount(data) - 1;
      var prevCellKey;
      last = Math.min(end, last);
      var _loop = function _loop() {
        var item = getItem(data, ii);
        var key = _this._keyExtractor(item, ii, _this.props);
        _this._indicesToKeys.set(ii, key);
        if (stickyIndicesFromProps.has(ii + stickyOffset)) {
          stickyHeaderIndices.push(cells.length);
        }
        var shouldListenForLayout = getItemLayout == null || debug || _this._fillRateHelper.enabled();
        cells.push(/*#__PURE__*/React.createElement(CellRenderer.default, (0, _extends.default)({
          CellRendererComponent: CellRendererComponent,
          ItemSeparatorComponent: ii < end ? ItemSeparatorComponent : undefined,
          ListItemComponent: ListItemComponent,
          cellKey: key,
          horizontal: horizontal,
          index: ii,
          inversionStyle: inversionStyle,
          item: item,
          key: key,
          prevCellKey: prevCellKey,
          onUpdateSeparators: _this._onUpdateSeparators,
          onCellFocusCapture: e => _this._onCellFocusCapture(key),
          onUnmount: _this._onCellUnmount,
          ref: _ref => {
            _this._cellRefs[key] = _ref;
          },
          renderItem: renderItem
        }, shouldListenForLayout && {
          onCellLayout: _this._onCellLayout
        })));
        prevCellKey = key;
      };
      for (var ii = first; ii <= last; ii++) {
        _loop();
      }
    }
    static _constrainToItemCount(cells, props) {
      var itemCount = props.getItemCount(props.data);
      var last = Math.min(itemCount - 1, cells.last);
      var maxToRenderPerBatch = maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch);
      return {
        first: (0, clamp.default)(0, itemCount - 1 - maxToRenderPerBatch, cells.first),
        last
      };
    }
    _isNestedWithSameOrientation() {
      var nestedContext = this.context;
      return !!(nestedContext && !!nestedContext.horizontal === horizontalOrDefault(this.props.horizontal));
    }
    _keyExtractor(item, index, props
    // $FlowFixMe[missing-local-annot]
    ) {
      if (props.keyExtractor != null) {
        return props.keyExtractor(item, index);
      }
      var key = (0, _VirtualizeUtils.keyExtractor)(item, index);
      if (key === String(index)) {
        _usedIndexForKey = true;
        if (item.type && item.type.displayName) {
          _keylessItemComponentName = item.type.displayName;
        }
      }
      return key;
    }
    render() {
      this._checkProps(this.props);
      var _this$props5 = this.props,
        ListEmptyComponent = _this$props5.ListEmptyComponent,
        ListFooterComponent = _this$props5.ListFooterComponent,
        ListHeaderComponent = _this$props5.ListHeaderComponent;
      var _this$props6 = this.props,
        data = _this$props6.data,
        horizontal = _this$props6.horizontal;
      var inversionStyle = this.props.inverted ? horizontalOrDefault(this.props.horizontal) ? styles.horizontallyInverted : styles.verticallyInverted : null;
      var cells = [];
      var stickyIndicesFromProps = new Set(this.props.stickyHeaderIndices);
      var stickyHeaderIndices = [];

      // 1. Add cell for ListHeaderComponent
      if (ListHeaderComponent) {
        if (stickyIndicesFromProps.has(0)) {
          stickyHeaderIndices.push(0);
        }
        var _element = /*#__PURE__*/ /*#__PURE__*/React.isValidElement(ListHeaderComponent) ? ListHeaderComponent : /*#__PURE__*/
        // $FlowFixMe[not-a-component]
        // $FlowFixMe[incompatible-type-arg]
        React.createElement(ListHeaderComponent, null);
        cells.push(/*#__PURE__*/React.createElement(_VirtualizedListContextJs.VirtualizedListCellContextProvider, {
          cellKey: this._getCellKey() + '-header',
          key: "$header"
        }, /*#__PURE__*/React.createElement(View.default, {
          onLayout: this._onLayoutHeader,
          style: [inversionStyle, this.props.ListHeaderComponentStyle]
        },
        // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors
        _element)));
      }

      // 2a. Add a cell for ListEmptyComponent if applicable
      var itemCount = this.props.getItemCount(data);
      if (itemCount === 0 && ListEmptyComponent) {
        var _element2 = /*#__PURE__*/ /*#__PURE__*/React.isValidElement(ListEmptyComponent) ? ListEmptyComponent : /*#__PURE__*/
        // $FlowFixMe[not-a-component]
        // $FlowFixMe[incompatible-type-arg]
        React.createElement(ListEmptyComponent, null);
        cells.push(/*#__PURE__*/React.createElement(_VirtualizedListContextJs.VirtualizedListCellContextProvider, {
          cellKey: this._getCellKey() + '-empty',
          key: "$empty"
        }, /*#__PURE__*/React.cloneElement(_element2, {
          onLayout: event => {
            this._onLayoutEmpty(event);
            if (_element2.props.onLayout) {
              _element2.props.onLayout(event);
            }
          },
          style: [inversionStyle, _element2.props.style]
        })));
      }

      // 2b. Add cells and spacers for each item
      if (itemCount > 0) {
        _usedIndexForKey = false;
        _keylessItemComponentName = '';
        var spacerKey = this._getSpacerKey(!horizontal);
        var renderRegions = this.state.renderMask.enumerateRegions();
        var lastSpacer = findLastWhere(renderRegions, r => r.isSpacer);
        for (var _iterator = (0, _createForOfIteratorHelperLoose.default)(renderRegions), _step; !(_step = _iterator()).done;) {
          var section = _step.value;
          if (section.isSpacer) {
            // Legacy behavior is to avoid spacers when virtualization is
            // disabled (including head spacers on initial render).
            if (this.props.disableVirtualization) {
              continue;
            }

            // Without getItemLayout, we limit our tail spacer to the _highestMeasuredFrameIndex to
            // prevent the user for hyperscrolling into un-measured area because otherwise content will
            // likely jump around as it renders in above the viewport.
            var isLastSpacer = section === lastSpacer;
            var constrainToMeasured = isLastSpacer && !this.props.getItemLayout;
            var last = constrainToMeasured ? (0, clamp.default)(section.first - 1, section.last, this._highestMeasuredFrameIndex) : section.last;
            var firstMetrics = this.__getFrameMetricsApprox(section.first, this.props);
            var lastMetrics = this.__getFrameMetricsApprox(last, this.props);
            var spacerSize = lastMetrics.offset + lastMetrics.length - firstMetrics.offset;
            cells.push(/*#__PURE__*/React.createElement(View.default, {
              key: "$spacer-" + section.first,
              style: {
                [spacerKey]: spacerSize
              }
            }));
          } else {
            this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, section.first, section.last, inversionStyle);
          }
        }
        if (!this._hasWarned.keys && _usedIndexForKey) {
          console.warn("VirtualizedList: missing keys for items, make sure to specify a key or id property on each item or provide a custom keyExtractor.", _keylessItemComponentName);
          this._hasWarned.keys = true;
        }
      }

      // 3. Add cell for ListFooterComponent
      if (ListFooterComponent) {
        var _element3 = /*#__PURE__*/ /*#__PURE__*/React.isValidElement(ListFooterComponent) ? ListFooterComponent : /*#__PURE__*/
        // $FlowFixMe[not-a-component]
        // $FlowFixMe[incompatible-type-arg]
        React.createElement(ListFooterComponent, null);
        cells.push(/*#__PURE__*/React.createElement(_VirtualizedListContextJs.VirtualizedListCellContextProvider, {
          cellKey: this._getFooterCellKey(),
          key: "$footer"
        }, /*#__PURE__*/React.createElement(View.default, {
          onLayout: this._onLayoutFooter,
          style: [inversionStyle, this.props.ListFooterComponentStyle]
        },
        // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors
        _element3)));
      }

      // 4. Render the ScrollView
      var scrollProps = (0, _objectSpread.default)((0, _objectSpread.default)({}, this.props), {}, {
        onContentSizeChange: this._onContentSizeChange,
        onLayout: this._onLayout,
        onScroll: this._onScroll,
        onScrollBeginDrag: this._onScrollBeginDrag,
        onScrollEndDrag: this._onScrollEndDrag,
        onMomentumScrollBegin: this._onMomentumScrollBegin,
        onMomentumScrollEnd: this._onMomentumScrollEnd,
        scrollEventThrottle: scrollEventThrottleOrDefault(this.props.scrollEventThrottle),
        // TODO: Android support
        invertStickyHeaders: this.props.invertStickyHeaders !== undefined ? this.props.invertStickyHeaders : this.props.inverted,
        stickyHeaderIndices,
        style: inversionStyle ? [inversionStyle, this.props.style] : this.props.style
      });
      this._hasMore = this.state.cellsAroundViewport.last < itemCount - 1;
      var innerRet = /*#__PURE__*/React.createElement(_VirtualizedListContextJs.VirtualizedListContextProvider, {
        value: {
          cellKey: null,
          getScrollMetrics: this._getScrollMetrics,
          horizontal: horizontalOrDefault(this.props.horizontal),
          getOutermostParentListRef: this._getOutermostParentListRef,
          registerAsNestedChild: this._registerAsNestedChild,
          unregisterAsNestedChild: this._unregisterAsNestedChild
        }
      }, /*#__PURE__*/React.cloneElement((this.props.renderScrollComponent || this._defaultRenderScrollComponent)(scrollProps), {
        ref: this._captureScrollRef
      }, cells));
      var ret = innerRet;
      /* https://github.com/necolas/react-native-web/issues/2239: Re-enable when ScrollView.Context.Consumer is available.
      if (__DEV__) {
        ret = (
          <ScrollView.Context.Consumer>
            {scrollContext => {
              if (
                scrollContext != null &&
                !scrollContext.horizontal ===
                  !horizontalOrDefault(this.props.horizontal) &&
                !this._hasWarned.nesting &&
                this.context == null &&
                this.props.scrollEnabled !== false
              ) {
                // TODO (T46547044): use React.warn once 16.9 is sync'd: https://github.com/facebook/react/pull/15170
                console.error(
                  'VirtualizedLists should never be nested inside plain ScrollViews with the same ' +
                    'orientation because it can break windowing and other functionality - use another ' +
                    'VirtualizedList-backed container instead.',
                );
                this._hasWarned.nesting = true;
              }
              return innerRet;
            }}
          </ScrollView.Context.Consumer>
        );
      }*/
      if (this.props.debug) {
        return /*#__PURE__*/React.createElement(View.default, {
          style: styles.debug
        }, ret, this._renderDebugOverlay());
      } else {
        return ret;
      }
    }
    componentDidUpdate(prevProps) {
      var _this$props7 = this.props,
        data = _this$props7.data,
        extraData = _this$props7.extraData;
      if (data !== prevProps.data || extraData !== prevProps.extraData) {
        // clear the viewableIndices cache to also trigger
        // the onViewableItemsChanged callback with the new data
        this._viewabilityTuples.forEach(tuple => {
          tuple.viewabilityHelper.resetViewableIndices();
        });
      }
      // The `this._hiPriInProgress` is guaranteeing a hiPri cell update will only happen
      // once per fiber update. The `_scheduleCellsToRenderUpdate` will set it to true
      // if a hiPri update needs to perform. If `componentDidUpdate` is triggered with
      // `this._hiPriInProgress=true`, means it's triggered by the hiPri update. The
      // `_scheduleCellsToRenderUpdate` will check this condition and not perform
      // another hiPri update.
      var hiPriInProgress = this._hiPriInProgress;
      this._scheduleCellsToRenderUpdate();
      // Make sure setting `this._hiPriInProgress` back to false after `componentDidUpdate`
      // is triggered with `this._hiPriInProgress = true`
      if (hiPriInProgress) {
        this._hiPriInProgress = false;
      }
    }

    // Used for preventing scrollToIndex from being called multiple times for initialScrollIndex

    // flag to prevent infinite hiPri cell limit update

    // $FlowFixMe[missing-local-annot]

    /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's
     * LTI update could not be added via codemod */

    _computeBlankness() {
      this._fillRateHelper.computeBlankness(this.props, this.state.cellsAroundViewport, this._scrollMetrics);
    }

    /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's
     * LTI update could not be added via codemod */

    _onCellFocusCapture(cellKey) {
      this._lastFocusedCellKey = cellKey;
      this._updateCellsToRender();
    }
    _triggerRemeasureForChildListsInCell(cellKey) {
      this._nestedChildLists.forEachInCell(cellKey, childList => {
        childList.measureLayoutRelativeToContainingList();
      });
    }
    measureLayoutRelativeToContainingList() {
      // TODO (T35574538): findNodeHandle sometimes crashes with "Unable to find
      // node on an unmounted component" during scrolling
      try {
        if (!this._scrollRef) {
          return;
        }
        // We are assuming that getOutermostParentListRef().getScrollRef()
        // is a non-null reference to a ScrollView
        this._scrollRef.measureLayout(this.context.getOutermostParentListRef().getScrollRef(), (x, y, width, height) => {
          this._offsetFromParentVirtualizedList = this._selectOffset({
            x,
            y
          });
          this._scrollMetrics.contentLength = this._selectLength({
            width,
            height
          });
          var scrollMetrics = this._convertParentScrollMetrics(this.context.getScrollMetrics());
          var metricsChanged = this._scrollMetrics.visibleLength !== scrollMetrics.visibleLength || this._scrollMetrics.offset !== scrollMetrics.offset;
          if (metricsChanged) {
            this._scrollMetrics.visibleLength = scrollMetrics.visibleLength;
            this._scrollMetrics.offset = scrollMetrics.offset;

            // If metrics of the scrollView changed, then we triggered remeasure for child list
            // to ensure VirtualizedList has the right information.
            this._nestedChildLists.forEach(childList => {
              childList.measureLayoutRelativeToContainingList();
            });
          }
        }, error => {
          console.warn("VirtualizedList: Encountered an error while measuring a list's offset from its containing VirtualizedList.");
        });
      } catch (error) {
        console.warn('measureLayoutRelativeToContainingList threw an error', error.stack);
      }
    }
    _getFooterCellKey() {
      return this._getCellKey() + '-footer';
    }
    // $FlowFixMe[missing-local-annot]
    _renderDebugOverlay() {
      var normalize = this._scrollMetrics.visibleLength / (this._scrollMetrics.contentLength || 1);
      var framesInLayout = [];
      var itemCount = this.props.getItemCount(this.props.data);
      for (var ii = 0; ii < itemCount; ii++) {
        var frame = this.__getFrameMetricsApprox(ii, this.props);
        /* $FlowFixMe[prop-missing] (>=0.68.0 site=react_native_fb) This comment
         * suppresses an error found when Flow v0.68 was deployed. To see the
         * error delete this comment and run Flow. */
        if (frame.inLayout) {
          framesInLayout.push(frame);
        }
      }
      var windowTop = this.__getFrameMetricsApprox(this.state.cellsAroundViewport.first, this.props).offset;
      var frameLast = this.__getFrameMetricsApprox(this.state.cellsAroundViewport.last, this.props);
      var windowLen = frameLast.offset + frameLast.length - windowTop;
      var visTop = this._scrollMetrics.offset;
      var visLen = this._scrollMetrics.visibleLength;
      return /*#__PURE__*/React.createElement(View.default, {
        style: [styles.debugOverlayBase, styles.debugOverlay]
      }, framesInLayout.map((f, ii) => /*#__PURE__*/React.createElement(View.default, {
        key: 'f' + ii,
        style: [styles.debugOverlayBase, styles.debugOverlayFrame, {
          top: f.offset * normalize,
          height: f.length * normalize
        }]
      })), /*#__PURE__*/React.createElement(View.default, {
        style: [styles.debugOverlayBase, styles.debugOverlayFrameLast, {
          top: windowTop * normalize,
          height: windowLen * normalize
        }]
      }), /*#__PURE__*/React.createElement(View.default, {
        style: [styles.debugOverlayBase, styles.debugOverlayFrameVis, {
          top: visTop * normalize,
          height: visLen * normalize
        }]
      }));
    }
    _selectLength(metrics) {
      return !horizontalOrDefault(this.props.horizontal) ? metrics.height : metrics.width;
    }
    _selectOffset(metrics) {
      return !horizontalOrDefault(this.props.horizontal) ? metrics.y : metrics.x;
    }
    _maybeCallOnEdgeReached() {
      var _this$props8 = this.props,
        data = _this$props8.data,
        getItemCount = _this$props8.getItemCount,
        onStartReached = _this$props8.onStartReached,
        onStartReachedThreshold = _this$props8.onStartReachedThreshold,
        onEndReached = _this$props8.onEndReached,
        onEndReachedThreshold = _this$props8.onEndReachedThreshold,
        initialScrollIndex = _this$props8.initialScrollIndex;
      var _this$_scrollMetrics2 = this._scrollMetrics,
        contentLength = _this$_scrollMetrics2.contentLength,
        visibleLength = _this$_scrollMetrics2.visibleLength,
        offset = _this$_scrollMetrics2.offset;
      var distanceFromStart = offset;
      var distanceFromEnd = contentLength - visibleLength - offset;

      // Especially when oERT is zero it's necessary to 'floor' very small distance values to be 0
      // since debouncing causes us to not fire this event for every single "pixel" we scroll and can thus
      // be at the edge of the list with a distance approximating 0 but not quite there.
      if (distanceFromStart < ON_EDGE_REACHED_EPSILON) {
        distanceFromStart = 0;
      }
      if (distanceFromEnd < ON_EDGE_REACHED_EPSILON) {
        distanceFromEnd = 0;
      }

      // TODO: T121172172 Look into why we're "defaulting" to a threshold of 2px
      // when oERT is not present (different from 2 viewports used elsewhere)
      var DEFAULT_THRESHOLD_PX = 2;
      var startThreshold = onStartReachedThreshold != null ? onStartReachedThreshold * visibleLength : DEFAULT_THRESHOLD_PX;
      var endThreshold = onEndReachedThreshold != null ? onEndReachedThreshold * visibleLength : DEFAULT_THRESHOLD_PX;
      var isWithinStartThreshold = distanceFromStart <= startThreshold;
      var isWithinEndThreshold = distanceFromEnd <= endThreshold;

      // First check if the user just scrolled within the end threshold
      // and call onEndReached only once for a given content length,
      // and only if onStartReached is not being executed
      if (onEndReached && this.state.cellsAroundViewport.last === getItemCount(data) - 1 && isWithinEndThreshold && this._scrollMetrics.contentLength !== this._sentEndForContentLength) {
        this._sentEndForContentLength = this._scrollMetrics.contentLength;
        onEndReached({
          distanceFromEnd
        });
      }

      // Next check if the user just scrolled within the start threshold
      // and call onStartReached only once for a given content length,
      // and only if onEndReached is not being executed
      else if (onStartReached != null && this.state.cellsAroundViewport.first === 0 && isWithinStartThreshold && this._scrollMetrics.contentLength !== this._sentStartForContentLength) {
        // On initial mount when using initialScrollIndex the offset will be 0 initially
        // and will trigger an unexpected onStartReached. To avoid this we can use
        // timestamp to differentiate between the initial scroll metrics and when we actually
        // received the first scroll event.
        if (!initialScrollIndex || this._scrollMetrics.timestamp !== 0) {
          this._sentStartForContentLength = this._scrollMetrics.contentLength;
          onStartReached({
            distanceFromStart
          });
        }
      }

      // If the user scrolls away from the start or end and back again,
      // cause onStartReached or onEndReached to be triggered again
      else {
        this._sentStartForContentLength = isWithinStartThreshold ? this._sentStartForContentLength : 0;
        this._sentEndForContentLength = isWithinEndThreshold ? this._sentEndForContentLength : 0;
      }
    }

    /* Translates metrics from a scroll event in a parent VirtualizedList into
     * coordinates relative to the child list.
     */

    _scheduleCellsToRenderUpdate() {
      var _this$state$cellsArou = this.state.cellsAroundViewport,
        first = _this$state$cellsArou.first,
        last = _this$state$cellsArou.last;
      var _this$_scrollMetrics3 = this._scrollMetrics,
        offset = _this$_scrollMetrics3.offset,
        visibleLength = _this$_scrollMetrics3.visibleLength,
        velocity = _this$_scrollMetrics3.velocity;
      var itemCount = this.props.getItemCount(this.props.data);
      var hiPri = false;
      var onStartReachedThreshold = onStartReachedThresholdOrDefault(this.props.onStartReachedThreshold);
      var onEndReachedThreshold = onEndReachedThresholdOrDefault(this.props.onEndReachedThreshold);
      // Mark as high priority if we're close to the start of the first item
      // But only if there are items before the first rendered item
      if (first > 0) {
        var distTop = offset - this.__getFrameMetricsApprox(first, this.props).offset;
        hiPri = distTop < 0 || velocity < -2 && distTop < getScrollingThreshold(onStartReachedThreshold, visibleLength);
      }
      // Mark as high priority if we're close to the end of the last item
      // But only if there are items after the last rendered item
      if (!hiPri && last >= 0 && last < itemCount - 1) {
        var distBottom = this.__getFrameMetricsApprox(last, this.props).offset - (offset + visibleLength);
        hiPri = distBottom < 0 || velocity > 2 && distBottom < getScrollingThreshold(onEndReachedThreshold, visibleLength);
      }
      // Only trigger high-priority updates if we've actually rendered cells,
      // and with that size estimate, accurately compute how many cells we should render.
      // Otherwise, it would just render as many cells as it can (of zero dimension),
      // each time through attempting to render more (limited by maxToRenderPerBatch),
      // starving the renderer from actually laying out the objects and computing _averageCellLength.
      // If this is triggered in an `componentDidUpdate` followed by a hiPri cellToRenderUpdate
      // We shouldn't do another hipri cellToRenderUpdate
      if (hiPri && (this._averageCellLength || this.props.getItemLayout) && !this._hiPriInProgress) {
        this._hiPriInProgress = true;
        // Don't worry about interactions when scrolling quickly; focus on filling content as fast
        // as possible.
        this._updateCellsToRenderBatcher.dispose({
          abort: true
        });
        this._updateCellsToRender();
        return;
      } else {
        this._updateCellsToRenderBatcher.schedule();
      }
    }

    /**
     * Gets an approximate offset to an item at a given index. Supports
     * fractional indices.
     */

    _updateViewableItems(props, cellsAroundViewport) {
      this._viewabilityTuples.forEach(tuple => {
        tuple.viewabilityHelper.onUpdate(props, this._scrollMetrics.offset, this._scrollMetrics.visibleLength, this._getFrameMetrics, this._createViewToken, tuple.onViewableItemsChanged, cellsAroundViewport);
      });
    }
  }
  VirtualizedList.contextType = _VirtualizedListContextJs.VirtualizedListContext;
  var styles = StyleSheet.default.create({
    verticallyInverted: {
      transform: 'scaleY(-1)'
    },
    horizontallyInverted: {
      transform: 'scaleX(-1)'
    },
    debug: {
      flex: 1
    },
    debugOverlayBase: {
      position: 'absolute',
      top: 0,
      right: 0
    },
    debugOverlay: {
      bottom: 0,
      width: 20,
      borderColor: 'blue',
      borderWidth: 1
    },
    debugOverlayFrame: {
      left: 0,
      backgroundColor: 'orange'
    },
    debugOverlayFrameLast: {
      left: 0,
      borderColor: 'green',
      borderWidth: 2
    },
    debugOverlayFrameVis: {
      left: 0,
      borderColor: 'red',
      borderWidth: 2
    }
  });
  var _default = VirtualizedList;
},156,[157,28,20,160,161,138,43,168,173,174,175,176,177,178,179,180,181,182,25,183,35]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _createForOfIteratorHelperLoose;
    }
  });
  var _unsupportedIterableToArrayJs = require(_dependencyMap[0]);
  var unsupportedIterableToArray = _interopDefault(_unsupportedIterableToArrayJs);
  function _createForOfIteratorHelperLoose(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (t) return (t = t.call(r)).next.bind(t);
    if (Array.isArray(r) || (t = (0, unsupportedIterableToArray.default)(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var o = 0;
      return function () {
        return o >= r.length ? {
          done: true
        } : {
          done: false,
          value: r[o++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
},157,[158]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _unsupportedIterableToArray;
    }
  });
  var _arrayLikeToArrayJs = require(_dependencyMap[0]);
  var arrayLikeToArray = _interopDefault(_arrayLikeToArrayJs);
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) return (0, arrayLikeToArray.default)(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? (0, arrayLikeToArray.default)(r, a) : undefined;
    }
  }
},158,[159]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _arrayLikeToArray;
    }
  });
  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
},159,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _View = require(_dependencyMap[1]);
  var View = _interopDefault(_View);
  var _react = require(_dependencyMap[2]);
  var React = _interopDefault(_react);
  var _excluded = ["colors", "enabled", "onRefresh", "progressBackgroundColor", "progressViewOffset", "refreshing", "size", "tintColor", "title", "titleColor"];
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function RefreshControl(props) {
    var colors = props.colors,
      enabled = props.enabled,
      onRefresh = props.onRefresh,
      progressBackgroundColor = props.progressBackgroundColor,
      progressViewOffset = props.progressViewOffset,
      refreshing = props.refreshing,
      size = props.size,
      tintColor = props.tintColor,
      title = props.title,
      titleColor = props.titleColor,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    return /*#__PURE__*/React.default.createElement(View.default, rest);
  }
  var _default = RefreshControl;
},160,[44,138,35]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _babelRuntimeHelpersExtends = require(_dependencyMap[1]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[2]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _Dimensions = require(_dependencyMap[3]);
  var Dimensions = _interopDefault(_Dimensions);
  var _modulesDismissKeyboard = require(_dependencyMap[4]);
  var dismissKeyboard = _interopDefault(_modulesDismissKeyboard);
  var _fbjsLibInvariant = require(_dependencyMap[5]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _modulesMergeRefs = require(_dependencyMap[6]);
  var mergeRefs = _interopDefault(_modulesMergeRefs);
  require(_dependencyMap[7]);
  var _ScrollViewBase = require(_dependencyMap[8]);
  var ScrollViewBase = _interopDefault(_ScrollViewBase);
  var _StyleSheet = require(_dependencyMap[9]);
  var StyleSheet = _interopDefault(_StyleSheet);
  var _modulesTextInputState = require(_dependencyMap[10]);
  var TextInputState = _interopDefault(_modulesTextInputState);
  var _UIManager = require(_dependencyMap[11]);
  var UIManager = _interopDefault(_UIManager);
  var _View = require(_dependencyMap[12]);
  var View = _interopDefault(_View);
  var _react = require(_dependencyMap[13]);
  var React = _interopDefault(_react);
  var _fbjsLibWarning = require(_dependencyMap[14]);
  var warning = _interopDefault(_fbjsLibWarning);
  var _excluded = ["contentContainerStyle", "horizontal", "onContentSizeChange", "refreshControl", "stickyHeaderIndices", "pagingEnabled", "forwardedRef", "keyboardDismissMode", "onScroll", "centerContent"];
  var emptyObject = {};
  var IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;
  class ScrollView extends React.default.Component {
    constructor() {
      super(...arguments);
      this._scrollNodeRef = null;
      this._innerViewRef = null;
      this.isTouching = false;
      this.lastMomentumScrollBeginTime = 0;
      this.lastMomentumScrollEndTime = 0;
      this.observedScrollSinceBecomingResponder = false;
      this.becameResponderWhileAnimating = false;
      this.scrollResponderHandleScrollShouldSetResponder = () => {
        return this.isTouching;
      };
      this.scrollResponderHandleStartShouldSetResponderCapture = e => {
        // First see if we want to eat taps while the keyboard is up
        // var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();
        // if (!this.props.keyboardShouldPersistTaps &&
        //   currentlyFocusedTextInput != null &&
        //   e.target !== currentlyFocusedTextInput) {
        //   return true;
        // }
        return this.scrollResponderIsAnimating();
      };
      this.scrollResponderHandleTerminationRequest = () => {
        return !this.observedScrollSinceBecomingResponder;
      };
      this.scrollResponderHandleTouchEnd = e => {
        var nativeEvent = e.nativeEvent;
        this.isTouching = nativeEvent.touches.length !== 0;
        this.props.onTouchEnd && this.props.onTouchEnd(e);
      };
      this.scrollResponderHandleResponderRelease = e => {
        this.props.onResponderRelease && this.props.onResponderRelease(e);

        // By default scroll views will unfocus a textField
        // if another touch occurs outside of it
        var currentlyFocusedTextInput = TextInputState.default.currentlyFocusedField();
        if (!this.props.keyboardShouldPersistTaps && currentlyFocusedTextInput != null && e.target !== currentlyFocusedTextInput && !this.observedScrollSinceBecomingResponder && !this.becameResponderWhileAnimating) {
          this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e);
          TextInputState.default.blurTextInput(currentlyFocusedTextInput);
        }
      };
      this.scrollResponderHandleScroll = e => {
        this.observedScrollSinceBecomingResponder = true;
        this.props.onScroll && this.props.onScroll(e);
      };
      this.scrollResponderHandleResponderGrant = e => {
        this.observedScrollSinceBecomingResponder = false;
        this.props.onResponderGrant && this.props.onResponderGrant(e);
        this.becameResponderWhileAnimating = this.scrollResponderIsAnimating();
      };
      this.scrollResponderHandleScrollBeginDrag = e => {
        this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);
      };
      this.scrollResponderHandleScrollEndDrag = e => {
        this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);
      };
      this.scrollResponderHandleMomentumScrollBegin = e => {
        this.lastMomentumScrollBeginTime = Date.now();
        this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);
      };
      this.scrollResponderHandleMomentumScrollEnd = e => {
        this.lastMomentumScrollEndTime = Date.now();
        this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);
      };
      this.scrollResponderHandleTouchStart = e => {
        this.isTouching = true;
        this.props.onTouchStart && this.props.onTouchStart(e);
      };
      this.scrollResponderHandleTouchMove = e => {
        this.props.onTouchMove && this.props.onTouchMove(e);
      };
      this.scrollResponderIsAnimating = () => {
        var now = Date.now();
        var timeSinceLastMomentumScrollEnd = now - this.lastMomentumScrollEndTime;
        var isAnimating = timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || this.lastMomentumScrollEndTime < this.lastMomentumScrollBeginTime;
        return isAnimating;
      };
      this.scrollResponderScrollTo = (x, y, animated) => {
        if (typeof x === 'number') {
          console.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');
        } else {
          var _ref = x || emptyObject;
          x = _ref.x;
          y = _ref.y;
          animated = _ref.animated;
        }
        var node = this.getScrollableNode();
        var left = x || 0;
        var top = y || 0;
        if (node != null) {
          if (typeof node.scroll === 'function') {
            node.scroll({
              top,
              left,
              behavior: !animated ? 'auto' : 'smooth'
            });
          } else {
            node.scrollLeft = left;
            node.scrollTop = top;
          }
        }
      };
      this.scrollResponderZoomTo = (rect, animated) => {
        {
          (0, invariant.default)('zoomToRect is not implemented');
        }
      };
      this.scrollResponderScrollNativeHandleToKeyboard = (nodeHandle, additionalOffset, preventNegativeScrollOffset) => {
        this.additionalScrollOffset = additionalOffset || 0;
        this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;
        UIManager.default.measureLayout(nodeHandle, this.getInnerViewNode(), this.scrollResponderTextInputFocusError, this.scrollResponderInputMeasureAndScrollToKeyboard);
      };
      this.scrollResponderInputMeasureAndScrollToKeyboard = (left, top, width, height) => {
        var keyboardScreenY = Dimensions.default.get('window').height;
        if (this.keyboardWillOpenTo) {
          keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY;
        }
        var scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset;

        // By default, this can scroll with negative offset, pulling the content
        // down so that the target component's bottom meets the keyboard's top.
        // If requested otherwise, cap the offset at 0 minimum to avoid content
        // shifting down.
        if (this.preventNegativeScrollOffset) {
          scrollOffsetY = Math.max(0, scrollOffsetY);
        }
        this.scrollResponderScrollTo({
          x: 0,
          y: scrollOffsetY,
          animated: true
        });
        this.additionalOffset = 0;
        this.preventNegativeScrollOffset = false;
      };
      this.scrollResponderKeyboardWillShow = e => {
        this.keyboardWillOpenTo = e;
        this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);
      };
      this.scrollResponderKeyboardWillHide = e => {
        this.keyboardWillOpenTo = null;
        this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);
      };
      this.scrollResponderKeyboardDidShow = e => {
        // TODO(7693961): The event for DidShow is not available on iOS yet.
        // Use the one from WillShow and do not assign.
        if (e) {
          this.keyboardWillOpenTo = e;
        }
        this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);
      };
      this.scrollResponderKeyboardDidHide = e => {
        this.keyboardWillOpenTo = null;
        this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e);
      };
      this.flashScrollIndicators = () => {
        this.scrollResponderFlashScrollIndicators();
      };
      this.getScrollResponder = () => {
        return this;
      };
      this.getScrollableNode = () => {
        return this._scrollNodeRef;
      };
      this.getInnerViewRef = () => {
        return this._innerViewRef;
      };
      this.getInnerViewNode = () => {
        return this._innerViewRef;
      };
      this.getNativeScrollRef = () => {
        return this._scrollNodeRef;
      };
      this.scrollTo = (y, x, animated) => {
        if (typeof y === 'number') {
          console.warn('`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, animated: true})` instead.');
        } else {
          var _ref2 = y || emptyObject;
          x = _ref2.x;
          y = _ref2.y;
          animated = _ref2.animated;
        }
        this.scrollResponderScrollTo({
          x: x || 0,
          y: y || 0,
          animated: animated !== false
        });
      };
      this.scrollToEnd = options => {
        // Default to true
        var animated = (options && options.animated) !== false;
        var horizontal = this.props.horizontal;
        var scrollResponderNode = this.getScrollableNode();
        var x = horizontal ? scrollResponderNode.scrollWidth : 0;
        var y = horizontal ? 0 : scrollResponderNode.scrollHeight;
        this.scrollResponderScrollTo({
          x,
          y,
          animated
        });
      };
      this._handleContentOnLayout = e => {
        var _e$nativeEvent$layout = e.nativeEvent.layout,
          width = _e$nativeEvent$layout.width,
          height = _e$nativeEvent$layout.height;
        this.props.onContentSizeChange(width, height);
      };
      this._handleScroll = e => {
        if (this.props.keyboardDismissMode === 'on-drag') {
          (0, dismissKeyboard.default)();
        }
        this.scrollResponderHandleScroll(e);
      };
      this._setInnerViewRef = node => {
        this._innerViewRef = node;
      };
      this._setScrollNodeRef = node => {
        this._scrollNodeRef = node;
        // ScrollView needs to add more methods to the hostNode in addition to those
        // added by `usePlatformMethods`. This is temporarily until an API like
        // `ScrollView.scrollTo(hostNode, { x, y })` is added to React Native.
        if (node != null) {
          node.getScrollResponder = this.getScrollResponder;
          node.getInnerViewNode = this.getInnerViewNode;
          node.getInnerViewRef = this.getInnerViewRef;
          node.getNativeScrollRef = this.getNativeScrollRef;
          node.getScrollableNode = this.getScrollableNode;
          node.scrollTo = this.scrollTo;
          node.scrollToEnd = this.scrollToEnd;
          node.flashScrollIndicators = this.flashScrollIndicators;
          node.scrollResponderZoomTo = this.scrollResponderZoomTo;
          node.scrollResponderScrollNativeHandleToKeyboard = this.scrollResponderScrollNativeHandleToKeyboard;
        }
        var ref = (0, mergeRefs.default)(this.props.forwardedRef);
        ref(node);
      };
    }
    /**
     * ------------------------------------------------------
     * START SCROLLRESPONDER
     * ------------------------------------------------------
     */
    // Reset to false every time becomes responder. This is used to:
    // - Determine if the scroll view has been scrolled and therefore should
    // refuse to give up its responder lock.
    // - Determine if releasing should dismiss the keyboard when we are in
    // tap-to-dismiss mode (!this.props.keyboardShouldPersistTaps).
    /**
     * Invoke this from an `onScroll` event.
     */
    /**
     * Merely touch starting is not sufficient for a scroll view to become the
     * responder. Being the "responder" means that the very next touch move/end
     * event will result in an action/movement.
     *
     * Invoke this from an `onStartShouldSetResponder` event.
     *
     * `onStartShouldSetResponder` is used when the next move/end will trigger
     * some UI movement/action, but when you want to yield priority to views
     * nested inside of the view.
     *
     * There may be some cases where scroll views actually should return `true`
     * from `onStartShouldSetResponder`: Any time we are detecting a standard tap
     * that gives priority to nested views.
     *
     * - If a single tap on the scroll view triggers an action such as
     *   recentering a map style view yet wants to give priority to interaction
     *   views inside (such as dropped pins or labels), then we would return true
     *   from this method when there is a single touch.
     *
     * - Similar to the previous case, if a two finger "tap" should trigger a
     *   zoom, we would check the `touches` count, and if `>= 2`, we would return
     *   true.
     *
     */
    scrollResponderHandleStartShouldSetResponder() {
      return false;
    }

    /**
     * There are times when the scroll view wants to become the responder
     * (meaning respond to the next immediate `touchStart/touchEnd`), in a way
     * that *doesn't* give priority to nested views (hence the capture phase):
     *
     * - Currently animating.
     * - Tapping anywhere that is not the focused input, while the keyboard is
     *   up (which should dismiss the keyboard).
     *
     * Invoke this from an `onStartShouldSetResponderCapture` event.
     */

    /**
     * Invoke this from an `onResponderReject` event.
     *
     * Some other element is not yielding its role as responder. Normally, we'd
     * just disable the `UIScrollView`, but a touch has already began on it, the
     * `UIScrollView` will not accept being disabled after that. The easiest
     * solution for now is to accept the limitation of disallowing this
     * altogether. To improve this, find a way to disable the `UIScrollView` after
     * a touch has already started.
     */
    scrollResponderHandleResponderReject() {
      (0, warning.default)(false, "ScrollView doesn't take rejection well - scrolls anyway");
    }

    /**
     * We will allow the scroll view to give up its lock iff it acquired the lock
     * during an animation. This is a very useful default that happens to satisfy
     * many common user experiences.
     *
     * - Stop a scroll on the left edge, then turn that into an outer view's
     *   backswipe.
     * - Stop a scroll mid-bounce at the top, continue pulling to have the outer
     *   view dismiss.
     * - However, without catching the scroll view mid-bounce (while it is
     *   motionless), if you drag far enough for the scroll view to become
     *   responder (and therefore drag the scroll view a bit), any backswipe
     *   navigation of a swipe gesture higher in the view hierarchy, should be
     *   rejected.
     */

    /**
     * Invoke this from an `onTouchEnd` event.
     *
     * @param {SyntheticEvent} e Event.
     */

    /**
     * Invoke this from an `onResponderRelease` event.
     */

    /**
     * Invoke this from an `onResponderGrant` event.
     */

    /**
     * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll
     * animation, and there's not an easy way to distinguish a drag vs. stopping
     * momentum.
     *
     * Invoke this from an `onScrollBeginDrag` event.
     */

    /**
     * Invoke this from an `onScrollEndDrag` event.
     */

    /**
     * Invoke this from an `onMomentumScrollBegin` event.
     */

    /**
     * Invoke this from an `onMomentumScrollEnd` event.
     */

    /**
     * Invoke this from an `onTouchStart` event.
     *
     * Since we know that the `SimpleEventPlugin` occurs later in the plugin
     * order, after `ResponderEventPlugin`, we can detect that we were *not*
     * permitted to be the responder (presumably because a contained view became
     * responder). The `onResponderReject` won't fire in that case - it only
     * fires when a *current* responder rejects our request.
     *
     * @param {SyntheticEvent} e Touch Start event.
     */

    /**
     * Invoke this from an `onTouchMove` event.
     *
     * Since we know that the `SimpleEventPlugin` occurs later in the plugin
     * order, after `ResponderEventPlugin`, we can detect that we were *not*
     * permitted to be the responder (presumably because a contained view became
     * responder). The `onResponderReject` won't fire in that case - it only
     * fires when a *current* responder rejects our request.
     *
     * @param {SyntheticEvent} e Touch Start event.
     */

    /**
     * A helper function for this class that lets us quickly determine if the
     * view is currently animating. This is particularly useful to know when
     * a touch has just started or ended.
     */

    /**
     * A helper function to scroll to a specific point in the scrollview.
     * This is currently used to help focus on child textviews, but can also
     * be used to quickly scroll to any element we want to focus. Syntax:
     *
     * scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})
     *
     * Note: The weird argument signature is due to the fact that, for historical reasons,
     * the function also accepts separate arguments as as alternative to the options object.
     * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.
     */

    /**
     * A helper function to zoom to a specific rect in the scrollview. The argument has the shape
     * {x: number; y: number; width: number; height: number; animated: boolean = true}
     *
     * @platform ios
     */

    /**
     * Displays the scroll indicators momentarily.
     */
    scrollResponderFlashScrollIndicators() {}

    /**
     * This method should be used as the callback to onFocus in a TextInputs'
     * parent view. Note that any module using this mixin needs to return
     * the parent view's ref in getScrollViewRef() in order to use this method.
     * @param {any} nodeHandle The TextInput node handle
     * @param {number} additionalOffset The scroll view's top "contentInset".
     *        Default is 0.
     * @param {bool} preventNegativeScrolling Whether to allow pulling the content
     *        down to make it meet the keyboard's top. Default is false.
     */

    /**
     * The calculations performed here assume the scroll view takes up the entire
     * screen - even if has some content inset. We then measure the offsets of the
     * keyboard, and compensate both for the scroll view's "contentInset".
     *
     * @param {number} left Position of input w.r.t. table view.
     * @param {number} top Position of input w.r.t. table view.
     * @param {number} width Width of the text input.
     * @param {number} height Height of the text input.
     */

    scrollResponderTextInputFocusError(e) {
      console.error('Error measuring text field: ', e);
    }

    /**
     * Warning, this may be called several times for a single keyboard opening.
     * It's best to store the information in this method and then take any action
     * at a later point (either in `keyboardDidShow` or other).
     *
     * Here's the order that events occur in:
     * - focus
     * - willShow {startCoordinates, endCoordinates} several times
     * - didShow several times
     * - blur
     * - willHide {startCoordinates, endCoordinates} several times
     * - didHide several times
     *
     * The `ScrollResponder` providesModule callbacks for each of these events.
     * Even though any user could have easily listened to keyboard events
     * themselves, using these `props` callbacks ensures that ordering of events
     * is consistent - and not dependent on the order that the keyboard events are
     * subscribed to. This matters when telling the scroll view to scroll to where
     * the keyboard is headed - the scroll responder better have been notified of
     * the keyboard destination before being instructed to scroll to where the
     * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything
     * will work.
     *
     * WARNING: These callbacks will fire even if a keyboard is displayed in a
     * different navigation pane. Filter out the events to determine if they are
     * relevant to you. (For example, only if you receive these callbacks after
     * you had explicitly focused a node etc).
     */

    /**
     * ------------------------------------------------------
     * END SCROLLRESPONDER
     * ------------------------------------------------------
     */

    /**
     * Returns a reference to the underlying scroll responder, which supports
     * operations like `scrollTo`. All ScrollView-like components should
     * implement this method so that they can be composed while providing access
     * to the underlying scroll responder's methods.
     */

    /**
     * Scrolls to a given x, y offset, either immediately or with a smooth animation.
     * Syntax:
     *
     * scrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})
     *
     * Note: The weird argument signature is due to the fact that, for historical reasons,
     * the function also accepts separate arguments as as alternative to the options object.
     * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.
     */

    /**
     * If this is a vertical ScrollView scrolls to the bottom.
     * If this is a horizontal ScrollView scrolls to the right.
     *
     * Use `scrollToEnd({ animated: true })` for smooth animated scrolling,
     * `scrollToEnd({ animated: false })` for immediate scrolling.
     * If no options are passed, `animated` defaults to true.
     */

    render() {
      var _this$props = this.props,
        contentContainerStyle = _this$props.contentContainerStyle,
        horizontal = _this$props.horizontal,
        onContentSizeChange = _this$props.onContentSizeChange,
        refreshControl = _this$props.refreshControl,
        stickyHeaderIndices = _this$props.stickyHeaderIndices,
        pagingEnabled = _this$props.pagingEnabled,
        forwardedRef = _this$props.forwardedRef,
        keyboardDismissMode = _this$props.keyboardDismissMode,
        onScroll = _this$props.onScroll,
        centerContent = _this$props.centerContent,
        other = (0, _objectWithoutPropertiesLoose.default)(_this$props, _excluded);
      var contentSizeChangeProps = {};
      if (onContentSizeChange) {
        contentSizeChangeProps = {
          onLayout: this._handleContentOnLayout
        };
      }
      var hasStickyHeaderIndices = !horizontal && Array.isArray(stickyHeaderIndices);
      var children = hasStickyHeaderIndices || pagingEnabled ? React.default.Children.map(this.props.children, (child, i) => {
        var isSticky = hasStickyHeaderIndices && stickyHeaderIndices.indexOf(i) > -1;
        if (child != null && (isSticky || pagingEnabled)) {
          return /*#__PURE__*/React.default.createElement(View.default, {
            style: [isSticky && styles.stickyHeader, pagingEnabled && styles.pagingEnabledChild]
          }, child);
        } else {
          return child;
        }
      }) : this.props.children;
      var contentContainer = /*#__PURE__*/React.default.createElement(View.default, (0, _extends.default)({}, contentSizeChangeProps, {
        children: children,
        collapsable: false,
        ref: this._setInnerViewRef,
        style: [horizontal && styles.contentContainerHorizontal, centerContent && styles.contentContainerCenterContent, contentContainerStyle]
      }));
      var baseStyle = horizontal ? styles.baseHorizontal : styles.baseVertical;
      var pagingEnabledStyle = horizontal ? styles.pagingEnabledHorizontal : styles.pagingEnabledVertical;
      var props = (0, _objectSpread.default)((0, _objectSpread.default)({}, other), {}, {
        style: [baseStyle, pagingEnabled && pagingEnabledStyle, this.props.style],
        onTouchStart: this.scrollResponderHandleTouchStart,
        onTouchMove: this.scrollResponderHandleTouchMove,
        onTouchEnd: this.scrollResponderHandleTouchEnd,
        onScrollBeginDrag: this.scrollResponderHandleScrollBeginDrag,
        onScrollEndDrag: this.scrollResponderHandleScrollEndDrag,
        onMomentumScrollBegin: this.scrollResponderHandleMomentumScrollBegin,
        onMomentumScrollEnd: this.scrollResponderHandleMomentumScrollEnd,
        onStartShouldSetResponder: this.scrollResponderHandleStartShouldSetResponder,
        onStartShouldSetResponderCapture: this.scrollResponderHandleStartShouldSetResponderCapture,
        onScrollShouldSetResponder: this.scrollResponderHandleScrollShouldSetResponder,
        onScroll: this._handleScroll,
        onResponderGrant: this.scrollResponderHandleResponderGrant,
        onResponderTerminationRequest: this.scrollResponderHandleTerminationRequest,
        onResponderTerminate: this.scrollResponderHandleTerminate,
        onResponderRelease: this.scrollResponderHandleResponderRelease,
        onResponderReject: this.scrollResponderHandleResponderReject
      });
      var ScrollViewClass = ScrollViewBase.default;
      (0, invariant.default)(ScrollViewClass !== undefined, 'ScrollViewClass must not be undefined');
      var scrollView = /*#__PURE__*/React.default.createElement(ScrollViewClass, (0, _extends.default)({}, props, {
        ref: this._setScrollNodeRef
      }), contentContainer);
      if (refreshControl) {
        return /*#__PURE__*/React.default.cloneElement(refreshControl, {
          style: props.style
        }, scrollView);
      }
      return scrollView;
    }
  }
  var commonStyle = {
    flexGrow: 1,
    flexShrink: 1,
    // Enable hardware compositing in modern browsers.
    // Creates a new layer with its own backing surface that can significantly
    // improve scroll performance.
    transform: 'translateZ(0)',
    // iOS native scrolling
    WebkitOverflowScrolling: 'touch'
  };
  var styles = StyleSheet.default.create({
    baseVertical: (0, _objectSpread.default)((0, _objectSpread.default)({}, commonStyle), {}, {
      flexDirection: 'column',
      overflowX: 'hidden',
      overflowY: 'auto'
    }),
    baseHorizontal: (0, _objectSpread.default)((0, _objectSpread.default)({}, commonStyle), {}, {
      flexDirection: 'row',
      overflowX: 'auto',
      overflowY: 'hidden'
    }),
    contentContainerHorizontal: {
      flexDirection: 'row'
    },
    contentContainerCenterContent: {
      justifyContent: 'center',
      flexGrow: 1
    },
    stickyHeader: {
      position: 'sticky',
      top: 0,
      zIndex: 10
    },
    pagingEnabledHorizontal: {
      scrollSnapType: 'x mandatory'
    },
    pagingEnabledVertical: {
      scrollSnapType: 'y mandatory'
    },
    pagingEnabledChild: {
      scrollSnapAlign: 'start'
    }
  });
  var ForwardedScrollView = /*#__PURE__*/React.default.forwardRef((props, forwardedRef) => {
    return /*#__PURE__*/React.default.createElement(ScrollView, (0, _extends.default)({}, props, {
      forwardedRef: forwardedRef
    }));
  });
  ForwardedScrollView.displayName = 'ScrollView';
  var _default = ForwardedScrollView;
},161,[20,28,44,162,163,25,144,96,165,43,164,126,138,35,166]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return Dimensions;
    }
  });
  var _fbjsLibInvariant = require(_dependencyMap[0]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _modulesCanUseDom = require(_dependencyMap[1]);
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  var dimensions = {
    window: {
      fontScale: 1,
      height: 0,
      scale: 1,
      width: 0
    },
    screen: {
      fontScale: 1,
      height: 0,
      scale: 1,
      width: 0
    }
  };
  var listeners = {};
  var shouldInit = canUseDOM.default;
  function update() {
    if (!canUseDOM.default) {
      return;
    }
    var win = window;
    var height;
    var width;

    /**
     * iOS does not update viewport dimensions on keyboard open/close.
     * window.visualViewport(https://developer.mozilla.org/en-US/docs/Web/API/VisualViewport)
     * is used instead of document.documentElement.clientHeight (which remains as a fallback)
     */
    if (win.visualViewport) {
      var visualViewport = win.visualViewport;
      /**
       * We are multiplying by scale because height and width from visual viewport
       * also react to pinch zoom, and become smaller when zoomed. But it is not desired
       * behaviour, since originally documentElement client height and width were used,
       * and they do not react to pinch zoom.
       */
      height = Math.round(visualViewport.height * visualViewport.scale);
      width = Math.round(visualViewport.width * visualViewport.scale);
    } else {
      var docEl = win.document.documentElement;
      height = docEl.clientHeight;
      width = docEl.clientWidth;
    }
    dimensions.window = {
      fontScale: 1,
      height,
      scale: win.devicePixelRatio || 1,
      width
    };
    dimensions.screen = {
      fontScale: 1,
      height: win.screen.height,
      scale: win.devicePixelRatio || 1,
      width: win.screen.width
    };
  }
  function handleResize() {
    update();
    if (Array.isArray(listeners['change'])) {
      listeners['change'].forEach(handler => handler(dimensions));
    }
  }
  class Dimensions {
    static get(dimension) {
      if (shouldInit) {
        shouldInit = false;
        update();
      }
      (0, invariant.default)(dimensions[dimension], "No dimension set for key " + dimension);
      return dimensions[dimension];
    }
    static set(initialDimensions) {
      if (initialDimensions) {
        if (canUseDOM.default) {
          (0, invariant.default)(false, 'Dimensions cannot be set in the browser');
        } else {
          if (initialDimensions.screen != null) {
            dimensions.screen = initialDimensions.screen;
          }
          if (initialDimensions.window != null) {
            dimensions.window = initialDimensions.window;
          }
        }
      }
    }
    static addEventListener(type, handler) {
      listeners[type] = listeners[type] || [];
      listeners[type].push(handler);
      return {
        remove: () => {
          this.removeEventListener(type, handler);
        }
      };
    }
    static removeEventListener(type, handler) {
      if (Array.isArray(listeners[type])) {
        listeners[type] = listeners[type].filter(_handler => _handler !== handler);
      }
    }
  }
  if (canUseDOM.default) {
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', handleResize, false);
    } else {
      window.addEventListener('resize', handleResize, false);
    }
  }
},162,[25,40]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _TextInputState = require(_dependencyMap[0]);
  var TextInputState = _interopDefault(_TextInputState);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var dismissKeyboard = () => {
    TextInputState.default.blurTextInput(TextInputState.default.currentlyFocusedField());
  };
  var _default = dismissKeyboard;
},163,[164]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _exportsUIManager = require(_dependencyMap[0]);
  var UIManager = _interopDefault(_exportsUIManager);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * This class is responsible for coordinating the "focused"
   * state for TextInputs. All calls relating to the keyboard
   * should be funneled through here
   */
  var TextInputState = {
    /**
     * Internal state
     */
    _currentlyFocusedNode: null,
    /**
     * Returns the ID of the currently focused text field, if one exists
     * If no text field is focused it returns null
     */
    currentlyFocusedField() {
      if (document.activeElement !== this._currentlyFocusedNode) {
        this._currentlyFocusedNode = null;
      }
      return this._currentlyFocusedNode;
    },
    /**
     * @param {Object} TextInputID id of the text field to focus
     * Focuses the specified text field
     * noop if the text field was already focused
     */
    focusTextInput(textFieldNode) {
      if (textFieldNode !== null) {
        this._currentlyFocusedNode = textFieldNode;
        if (document.activeElement !== textFieldNode) {
          UIManager.default.focus(textFieldNode);
        }
      }
    },
    /**
     * @param {Object} textFieldNode id of the text field to focus
     * Unfocuses the specified text field
     * noop if it wasn't focused
     */
    blurTextInput(textFieldNode) {
      if (textFieldNode !== null) {
        this._currentlyFocusedNode = null;
        if (document.activeElement === textFieldNode) {
          UIManager.default.blur(textFieldNode);
        }
      }
    }
  };
  var _default = TextInputState;
},164,[126]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2]);
  var React = _interopNamespace(_react);
  var _StyleSheet = require(_dependencyMap[3]);
  var StyleSheet = _interopDefault(_StyleSheet);
  var _View = require(_dependencyMap[4]);
  var View = _interopDefault(_View);
  var _modulesUseMergeRefs = require(_dependencyMap[5]);
  var useMergeRefs = _interopDefault(_modulesUseMergeRefs);
  var _excluded = ["onScroll", "onTouchMove", "onWheel", "scrollEnabled", "scrollEventThrottle", "showsHorizontalScrollIndicator", "showsVerticalScrollIndicator", "style"];
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function normalizeScrollEvent(e) {
    return {
      nativeEvent: {
        contentOffset: {
          get x() {
            return e.target.scrollLeft;
          },
          get y() {
            return e.target.scrollTop;
          }
        },
        contentSize: {
          get height() {
            return e.target.scrollHeight;
          },
          get width() {
            return e.target.scrollWidth;
          }
        },
        layoutMeasurement: {
          get height() {
            return e.target.offsetHeight;
          },
          get width() {
            return e.target.offsetWidth;
          }
        }
      },
      timeStamp: Date.now()
    };
  }
  function shouldEmitScrollEvent(lastTick, eventThrottle) {
    var timeSinceLastTick = Date.now() - lastTick;
    return eventThrottle > 0 && timeSinceLastTick >= eventThrottle;
  }

  /**
   * Encapsulates the Web-specific scroll throttling and disabling logic
   */
  var ScrollViewBase = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var onScroll = props.onScroll,
      onTouchMove = props.onTouchMove,
      onWheel = props.onWheel,
      _props$scrollEnabled = props.scrollEnabled,
      scrollEnabled = _props$scrollEnabled === undefined ? true : _props$scrollEnabled,
      _props$scrollEventThr = props.scrollEventThrottle,
      scrollEventThrottle = _props$scrollEventThr === undefined ? 0 : _props$scrollEventThr,
      showsHorizontalScrollIndicator = props.showsHorizontalScrollIndicator,
      showsVerticalScrollIndicator = props.showsVerticalScrollIndicator,
      style = props.style,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    var scrollState = React.useRef({
      isScrolling: false,
      scrollLastTick: 0
    });
    var scrollTimeout = React.useRef(null);
    var scrollRef = React.useRef(null);
    function createPreventableScrollHandler(handler) {
      return e => {
        if (scrollEnabled) {
          if (handler) {
            handler(e);
          }
        }
      };
    }
    function handleScroll(e) {
      e.stopPropagation();
      if (e.target === scrollRef.current) {
        e.persist();
        // A scroll happened, so the scroll resets the scrollend timeout.
        if (scrollTimeout.current != null) {
          clearTimeout(scrollTimeout.current);
        }
        scrollTimeout.current = setTimeout(() => {
          handleScrollEnd(e);
        }, 100);
        if (scrollState.current.isScrolling) {
          // Scroll last tick may have changed, check if we need to notify
          if (shouldEmitScrollEvent(scrollState.current.scrollLastTick, scrollEventThrottle)) {
            handleScrollTick(e);
          }
        } else {
          // Weren't scrolling, so we must have just started
          handleScrollStart(e);
        }
      }
    }
    function handleScrollStart(e) {
      scrollState.current.isScrolling = true;
      handleScrollTick(e);
    }
    function handleScrollTick(e) {
      scrollState.current.scrollLastTick = Date.now();
      if (onScroll) {
        onScroll(normalizeScrollEvent(e));
      }
    }
    function handleScrollEnd(e) {
      scrollState.current.isScrolling = false;
      if (onScroll) {
        onScroll(normalizeScrollEvent(e));
      }
    }
    var hideScrollbar = showsHorizontalScrollIndicator === false || showsVerticalScrollIndicator === false;
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, rest, {
      onScroll: handleScroll,
      onTouchMove: createPreventableScrollHandler(onTouchMove),
      onWheel: createPreventableScrollHandler(onWheel),
      ref: (0, useMergeRefs.default)(scrollRef, forwardedRef),
      style: [style, !scrollEnabled && styles.scrollDisabled, hideScrollbar && styles.hideScrollbar]
    }));
  });

  // Chrome doesn't support e.preventDefault in this case; touch-action must be
  // used to disable scrolling.
  // https://developers.google.com/web/updates/2017/01/scrolling-intervention
  var styles = StyleSheet.default.create({
    scrollDisabled: {
      overflowX: 'hidden',
      overflowY: 'hidden',
      touchAction: 'none'
    },
    hideScrollbar: {
      scrollbarWidth: 'none'
    }
  });
  var _default = ScrollViewBase;
},165,[28,44,35,43,138,143]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   */
  'use strict';

  var emptyFunction = require(_dependencyMap[0]);
  /**
   * Similar to invariant but only logs a warning if the condition is not met.
   * This can be used to log issues in development environments in critical
   * paths. Removing the logging code for production environments will keep the
   * same logic and follow the same code paths.
   */

  var warning = emptyFunction;
  module.exports = warning;
},166,[167]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */
  function makeEmptyFunction(arg) {
    return function () {
      return arg;
    };
  }
  /**
   * This function accepts and discards inputs; it has no side effects. This is
   * primarily useful idiomatically for overridable function endpoints which
   * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
   */

  var emptyFunction = function emptyFunction() {};
  emptyFunction.thatReturns = makeEmptyFunction;
  emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
  emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
  emptyFunction.thatReturnsNull = makeEmptyFunction(null);
  emptyFunction.thatReturnsThis = function () {
    return this;
  };
  emptyFunction.thatReturnsArgument = function (arg) {
    return arg;
  };
  module.exports = emptyFunction;
},167,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _exportsInteractionManager = require(_dependencyMap[0]);
  var InteractionManager = _interopDefault(_exportsInteractionManager);
  /**
   * A simple class for batching up invocations of a low-pri callback. A timeout is set to run the
   * callback once after a delay, no matter how many times it's scheduled. Once the delay is reached,
   * InteractionManager.runAfterInteractions is used to invoke the callback after any hi-pri
   * interactions are done running.
   *
   * Make sure to cleanup with dispose().  Example:
   *
   *   class Widget extends React.Component {
   *     _batchedSave: new Batchinator(() => this._saveState, 1000);
   *     _saveSate() {
   *       // save this.state to disk
   *     }
   *     componentDidUpdate() {
   *       this._batchedSave.schedule();
   *     }
   *     componentWillUnmount() {
   *       this._batchedSave.dispose();
   *     }
   *     ...
   *   }
   */
  class Batchinator {
    constructor(callback, delayMS) {
      this._delay = delayMS;
      this._callback = callback;
    }
    /*
     * Cleanup any pending tasks.
     *
     * By default, if there is a pending task the callback is run immediately. Set the option abort to
     * true to not call the callback if it was pending.
     */
    dispose(options) {
      if (options === undefined) {
        options = {
          abort: false
        };
      }
      if (this._taskHandle) {
        this._taskHandle.cancel();
        if (!options.abort) {
          this._callback();
        }
        this._taskHandle = null;
      }
    }
    schedule() {
      if (this._taskHandle) {
        return;
      }
      var timeoutHandle = setTimeout(() => {
        this._taskHandle = InteractionManager.default.runAfterInteractions(() => {
          // Note that we clear the handle before invoking the callback so that if the callback calls
          // schedule again, it will actually schedule another task.
          this._taskHandle = null;
          this._callback();
        });
      }, this._delay);
      this._taskHandle = {
        cancel: () => clearTimeout(timeoutHandle)
      };
    }
  }
  var _default = Batchinator;
},168,[169]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _fbjsLibInvariant = require(_dependencyMap[0]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _TaskQueue = require(_dependencyMap[1]);
  var TaskQueue = _interopDefault(_TaskQueue);
  var _vendorReactNativeVendorEmitterEventEmitter = require(_dependencyMap[2]);
  var EventEmitter = _interopDefault(_vendorReactNativeVendorEmitterEventEmitter);
  var _modulesRequestIdleCallback = require(_dependencyMap[3]);
  var requestIdleCallback = _interopDefault(_modulesRequestIdleCallback);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var _emitter = new EventEmitter.default();
  var InteractionManager = {
    Events: {
      interactionStart: 'interactionStart',
      interactionComplete: 'interactionComplete'
    },
    /**
     * Schedule a function to run after all interactions have completed.
     */
    runAfterInteractions(task) {
      var tasks = [];
      var promise = new Promise(resolve => {
        _scheduleUpdate();
        if (task) {
          tasks.push(task);
        }
        tasks.push({
          run: resolve,
          name: 'resolve ' + (task && task.name || '?')
        });
        _taskQueue.enqueueTasks(tasks);
      });
      return {
        then: promise.then.bind(promise),
        done: promise.then.bind(promise),
        cancel: () => {
          _taskQueue.cancelTasks(tasks);
        }
      };
    },
    /**
     * Notify manager that an interaction has started.
     */
    createInteractionHandle() {
      _scheduleUpdate();
      var handle = ++_inc;
      _addInteractionSet.add(handle);
      return handle;
    },
    /**
     * Notify manager that an interaction has completed.
     */
    clearInteractionHandle(handle) {
      (0, invariant.default)(!!handle, 'Must provide a handle to clear.');
      _scheduleUpdate();
      _addInteractionSet.delete(handle);
      _deleteInteractionSet.add(handle);
    },
    addListener: _emitter.addListener.bind(_emitter),
    /**
     *
     * @param deadline
     */
    setDeadline(deadline) {
      _deadline = deadline;
    }
  };
  var _interactionSet = new Set();
  var _addInteractionSet = new Set();
  var _deleteInteractionSet = new Set();
  var _taskQueue = new TaskQueue.default({
    onMoreTasks: _scheduleUpdate
  });
  var _nextUpdateHandle = 0;
  var _inc = 0;
  var _deadline = -1;

  /**
   * Schedule an asynchronous update to the interaction state.
   */
  function _scheduleUpdate() {
    if (!_nextUpdateHandle) {
      if (_deadline > 0) {
        _nextUpdateHandle = setTimeout(_processUpdate);
      } else {
        _nextUpdateHandle = (0, requestIdleCallback.default)(_processUpdate);
      }
    }
  }

  /**
   * Notify listeners, process queue, etc
   */
  function _processUpdate() {
    _nextUpdateHandle = 0;
    var interactionCount = _interactionSet.size;
    _addInteractionSet.forEach(handle => _interactionSet.add(handle));
    _deleteInteractionSet.forEach(handle => _interactionSet.delete(handle));
    var nextInteractionCount = _interactionSet.size;
    if (interactionCount !== 0 && nextInteractionCount === 0) {
      _emitter.emit(InteractionManager.Events.interactionComplete);
    } else if (interactionCount === 0 && nextInteractionCount !== 0) {
      _emitter.emit(InteractionManager.Events.interactionStart);
    }
    if (nextInteractionCount === 0) {
      // It seems that we can't know the running time of the current event loop,
      // we can only calculate the running time of the current task queue.
      var begin = Date.now();
      while (_taskQueue.hasTasksToProcess()) {
        _taskQueue.processNext();
        if (_deadline > 0 && Date.now() - begin >= _deadline) {
          _scheduleUpdate();
          break;
        }
      }
    }
    _addInteractionSet.clear();
    _deleteInteractionSet.clear();
  }
  var _default = InteractionManager;
},169,[25,170,171,172]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _fbjsLibInvariant = require(_dependencyMap[1]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  class TaskQueue {
    constructor(_ref) {
      var onMoreTasks = _ref.onMoreTasks;
      this._onMoreTasks = onMoreTasks;
      this._queueStack = [{
        tasks: [],
        popable: true
      }];
    }
    enqueue(task) {
      this._getCurrentQueue().push(task);
    }
    enqueueTasks(tasks) {
      tasks.forEach(task => this.enqueue(task));
    }
    cancelTasks(tasksToCancel) {
      this._queueStack = this._queueStack.map(queue => (0, _objectSpread.default)((0, _objectSpread.default)({}, queue), {}, {
        tasks: queue.tasks.filter(task => tasksToCancel.indexOf(task) === -1)
      })).filter((queue, idx) => queue.tasks.length > 0 || idx === 0);
    }
    hasTasksToProcess() {
      return this._getCurrentQueue().length > 0;
    }

    /**
     * Executes the next task in the queue.
     */
    processNext() {
      var queue = this._getCurrentQueue();
      if (queue.length) {
        var task = queue.shift();
        try {
          if (typeof task === 'object' && task.gen) {
            this._genPromise(task);
          } else if (typeof task === 'object' && task.run) {
            task.run();
          } else {
            (0, invariant.default)(typeof task === 'function', 'Expected Function, SimpleTask, or PromiseTask, but got:\n' + JSON.stringify(task, null, 2));
            task();
          }
        } catch (e) {
          e.message = 'TaskQueue: Error with task ' + (task.name || '') + ': ' + e.message;
          throw e;
        }
      }
    }
    _getCurrentQueue() {
      var stackIdx = this._queueStack.length - 1;
      var queue = this._queueStack[stackIdx];
      if (queue.popable && queue.tasks.length === 0 && stackIdx > 0) {
        this._queueStack.pop();
        return this._getCurrentQueue();
      } else {
        return queue.tasks;
      }
    }
    _genPromise(task) {
      var length = this._queueStack.push({
        tasks: [],
        popable: false
      });
      var stackIdx = length - 1;
      var stackItem = this._queueStack[stackIdx];
      task.gen().then(() => {
        stackItem.popable = true;
        this.hasTasksToProcess() && this._onMoreTasks();
      }).catch(ex => {
        setTimeout(() => {
          ex.message = "TaskQueue: Error resolving Promise in task " + task.name + ": " + ex.message;
          throw ex;
        }, 0);
      });
    }
  }
  var _default = TaskQueue;
},170,[20,25]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return EventEmitter;
    }
  });
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * EventEmitter manages listeners and publishes events to them.
   *
   * EventEmitter accepts a single type parameter that defines the valid events
   * and associated listener argument(s).
   *
   * @example
   *
   *   const emitter = new EventEmitter<{
   *     success: [number, string],
   *     error: [Error],
   *   }>();
   *
   *   emitter.on('success', (statusCode, responseText) => {...});
   *   emitter.emit('success', 200, '...');
   *
   *   emitter.on('error', error => {...});
   *   emitter.emit('error', new Error('Resource not found'));
   *
   */
  class EventEmitter {
    constructor() {
      this._registry = {};
    }
    /**
     * Registers a listener that is called when the supplied event is emitted.
     * Returns a subscription that has a `remove` method to undo registration.
     */
    addListener(eventType, listener, context) {
      var registrations = allocate(this._registry, eventType);
      var registration = {
        context,
        listener,
        remove() {
          registrations.delete(registration);
        }
      };
      registrations.add(registration);
      return registration;
    }

    /**
     * Emits the supplied event. Additional arguments supplied to `emit` will be
     * passed through to each of the registered listeners.
     *
     * If a listener modifies the listeners registered for the same event, those
     * changes will not be reflected in the current invocation of `emit`.
     */
    emit(eventType) {
      var registrations = this._registry[eventType];
      if (registrations != null) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        for (var _i = 0, _arr = [...registrations]; _i < _arr.length; _i++) {
          var registration = _arr[_i];
          registration.listener.apply(registration.context, args);
        }
      }
    }

    /**
     * Removes all registered listeners.
     */
    removeAllListeners(eventType) {
      if (eventType == null) {
        this._registry = {};
      } else {
        delete this._registry[eventType];
      }
    }

    /**
     * Returns the number of registered listeners for the supplied event.
     */
    listenerCount(eventType) {
      var registrations = this._registry[eventType];
      return registrations == null ? 0 : registrations.size;
    }
  }
  function allocate(registry, eventType) {
    var registrations = registry[eventType];
    if (registrations == null) {
      registrations = new Set();
      registry[eventType] = registrations;
    }
    return registrations;
  }
},171,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  Object.defineProperty(exports, "cancelIdleCallback", {
    enumerable: true,
    get: function () {
      return cancelIdleCallback;
    }
  });
  var _canUseDom = require(_dependencyMap[0]);
  var canUseDOM = _interopDefault(_canUseDom);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var _requestIdleCallback = function _requestIdleCallback(cb, options) {
    return setTimeout(() => {
      var start = Date.now();
      cb({
        didTimeout: false,
        timeRemaining() {
          return Math.max(0, 50 - (Date.now() - start));
        }
      });
    }, 1);
  };
  var _cancelIdleCallback = function _cancelIdleCallback(id) {
    clearTimeout(id);
  };
  var isSupported = canUseDOM.default && typeof window.requestIdleCallback !== 'undefined';
  var requestIdleCallback = isSupported ? window.requestIdleCallback : _requestIdleCallback;
  var cancelIdleCallback = isSupported ? window.cancelIdleCallback : _cancelIdleCallback;
  var _default = requestIdleCallback;
},172,[40]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  function clamp(min, value, max) {
    if (value < min) {
      return min;
    }
    if (value > max) {
      return max;
    }
    return value;
  }
  var _default = clamp;
},173,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  /**
   * Intentional info-level logging for clear separation from ad-hoc console debug logging.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  function infoLog() {
    return console.log(...arguments);
  }
  var _default = infoLog;
},174,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "CellRenderMask", {
    enumerable: true,
    get: function () {
      return CellRenderMask;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _fbjsLibInvariant = require(_dependencyMap[1]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  class CellRenderMask {
    constructor(numCells) {
      (0, invariant.default)(numCells >= 0, 'CellRenderMask must contain a non-negative number os cells');
      this._numCells = numCells;
      if (numCells === 0) {
        this._regions = [];
      } else {
        this._regions = [{
          first: 0,
          last: numCells - 1,
          isSpacer: true
        }];
      }
    }
    enumerateRegions() {
      return this._regions;
    }
    addCells(cells) {
      (0, invariant.default)(cells.first >= 0 && cells.first < this._numCells && cells.last >= -1 && cells.last < this._numCells && cells.last >= cells.first - 1, 'CellRenderMask.addCells called with invalid cell range');

      // VirtualizedList uses inclusive ranges, where zero-count states are
      // possible. E.g. [0, -1] for no cells, starting at 0.
      if (cells.last < cells.first) {
        return;
      }
      var _this$_findRegion = this._findRegion(cells.first),
        firstIntersect = _this$_findRegion[0],
        firstIntersectIdx = _this$_findRegion[1];
      var _this$_findRegion2 = this._findRegion(cells.last),
        lastIntersect = _this$_findRegion2[0],
        lastIntersectIdx = _this$_findRegion2[1];

      // Fast-path if the cells to add are already all present in the mask. We
      // will otherwise need to do some mutation.
      if (firstIntersectIdx === lastIntersectIdx && !firstIntersect.isSpacer) {
        return;
      }

      // We need to replace the existing covered regions with 1-3 new regions
      // depending whether we need to split spacers out of overlapping regions.
      var newLeadRegion = [];
      var newTailRegion = [];
      var newMainRegion = (0, _objectSpread.default)((0, _objectSpread.default)({}, cells), {}, {
        isSpacer: false
      });
      if (firstIntersect.first < newMainRegion.first) {
        if (firstIntersect.isSpacer) {
          newLeadRegion.push({
            first: firstIntersect.first,
            last: newMainRegion.first - 1,
            isSpacer: true
          });
        } else {
          newMainRegion.first = firstIntersect.first;
        }
      }
      if (lastIntersect.last > newMainRegion.last) {
        if (lastIntersect.isSpacer) {
          newTailRegion.push({
            first: newMainRegion.last + 1,
            last: lastIntersect.last,
            isSpacer: true
          });
        } else {
          newMainRegion.last = lastIntersect.last;
        }
      }
      var replacementRegions = [...newLeadRegion, newMainRegion, ...newTailRegion];
      var numRegionsToDelete = lastIntersectIdx - firstIntersectIdx + 1;
      this._regions.splice(firstIntersectIdx, numRegionsToDelete, ...replacementRegions);
    }
    numCells() {
      return this._numCells;
    }
    equals(other) {
      return this._numCells === other._numCells && this._regions.length === other._regions.length && this._regions.every((region, i) => region.first === other._regions[i].first && region.last === other._regions[i].last && region.isSpacer === other._regions[i].isSpacer);
    }
    _findRegion(cellIdx) {
      var firstIdx = 0;
      var lastIdx = this._regions.length - 1;
      while (firstIdx <= lastIdx) {
        var middleIdx = Math.floor((firstIdx + lastIdx) / 2);
        var middleRegion = this._regions[middleIdx];
        if (cellIdx >= middleRegion.first && cellIdx <= middleRegion.last) {
          return [middleRegion, middleIdx];
        } else if (cellIdx < middleRegion.first) {
          lastIdx = middleIdx - 1;
        } else if (cellIdx > middleRegion.last) {
          firstIdx = middleIdx + 1;
        }
      }
      (0, invariant.default)(false, "A region was not found containing cellIdx " + cellIdx);
    }
  }
},175,[20,25]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return ChildListCollection;
    }
  });
  var _babelRuntimeHelpersCreateForOfIteratorHelperLoose = require(_dependencyMap[0]);
  var _createForOfIteratorHelperLoose = _interopDefault(_babelRuntimeHelpersCreateForOfIteratorHelperLoose);
  var _fbjsLibInvariant = require(_dependencyMap[1]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  class ChildListCollection {
    constructor() {
      this._cellKeyToChildren = new Map();
      this._childrenToCellKey = new Map();
    }
    add(list, cellKey) {
      var _this$_cellKeyToChild;
      (0, invariant.default)(!this._childrenToCellKey.has(list), 'Trying to add already present child list');
      var cellLists = (_this$_cellKeyToChild = this._cellKeyToChildren.get(cellKey)) !== null && _this$_cellKeyToChild !== undefined ? _this$_cellKeyToChild : new Set();
      cellLists.add(list);
      this._cellKeyToChildren.set(cellKey, cellLists);
      this._childrenToCellKey.set(list, cellKey);
    }
    remove(list) {
      var cellKey = this._childrenToCellKey.get(list);
      (0, invariant.default)(cellKey != null, 'Trying to remove non-present child list');
      this._childrenToCellKey.delete(list);
      var cellLists = this._cellKeyToChildren.get(cellKey);
      (0, invariant.default)(cellLists, '_cellKeyToChildren should contain cellKey');
      cellLists.delete(list);
      if (cellLists.size === 0) {
        this._cellKeyToChildren.delete(cellKey);
      }
    }
    forEach(fn) {
      for (var _iterator = (0, _createForOfIteratorHelperLoose.default)(this._cellKeyToChildren.values()), _step; !(_step = _iterator()).done;) {
        var listSet = _step.value;
        for (var _iterator2 = (0, _createForOfIteratorHelperLoose.default)(listSet), _step2; !(_step2 = _iterator2()).done;) {
          var list = _step2.value;
          fn(list);
        }
      }
    }
    forEachInCell(cellKey, fn) {
      var _this$_cellKeyToChild2;
      var listSet = (_this$_cellKeyToChild2 = this._cellKeyToChildren.get(cellKey)) !== null && _this$_cellKeyToChild2 !== undefined ? _this$_cellKeyToChild2 : [];
      for (var _iterator3 = (0, _createForOfIteratorHelperLoose.default)(listSet), _step3; !(_step3 = _iterator3()).done;) {
        var list = _step3.value;
        fn(list);
      }
    }
    anyInCell(cellKey, fn) {
      var _this$_cellKeyToChild3;
      var listSet = (_this$_cellKeyToChild3 = this._cellKeyToChildren.get(cellKey)) !== null && _this$_cellKeyToChild3 !== undefined ? _this$_cellKeyToChild3 : [];
      for (var _iterator4 = (0, _createForOfIteratorHelperLoose.default)(listSet), _step4; !(_step4 = _iterator4()).done;) {
        var list = _step4.value;
        if (fn(list)) {
          return true;
        }
      }
      return false;
    }
    size() {
      return this._childrenToCellKey.size;
    }
  }
},176,[157,25]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  class Info {
    constructor() {
      this.any_blank_count = 0;
      this.any_blank_ms = 0;
      this.any_blank_speed_sum = 0;
      this.mostly_blank_count = 0;
      this.mostly_blank_ms = 0;
      this.pixels_blank = 0;
      this.pixels_sampled = 0;
      this.pixels_scrolled = 0;
      this.total_time_spent = 0;
      this.sample_count = 0;
    }
  }
  var DEBUG = false;
  var _listeners = [];
  var _minSampleCount = 10;
  var _sampleRate = null;

  /**
   * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.
   * By default the sampling rate is set to zero and this will do nothing. If you want to collect
   * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.
   *
   * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with
   * `SceneTracker.getActiveScene` to determine the context of the events.
   */
  class FillRateHelper {
    static addListener(callback) {
      if (_sampleRate === null) {
        console.warn('Call `FillRateHelper.setSampleRate` before `addListener`.');
      }
      _listeners.push(callback);
      return {
        remove: () => {
          _listeners = _listeners.filter(listener => callback !== listener);
        }
      };
    }
    static setSampleRate(sampleRate) {
      _sampleRate = sampleRate;
    }
    static setMinSampleCount(minSampleCount) {
      _minSampleCount = minSampleCount;
    }
    constructor(getFrameMetrics) {
      this._anyBlankStartTime = null;
      this._enabled = false;
      this._info = new Info();
      this._mostlyBlankStartTime = null;
      this._samplesStartTime = null;
      this._getFrameMetrics = getFrameMetrics;
      this._enabled = (_sampleRate || 0) > Math.random();
      this._resetData();
    }
    activate() {
      if (this._enabled && this._samplesStartTime == null) {
        DEBUG;
        this._samplesStartTime = global.performance.now();
      }
    }
    deactivateAndFlush() {
      if (!this._enabled) {
        return;
      }
      var start = this._samplesStartTime; // const for flow
      if (start == null) {
        DEBUG;
        return;
      }
      if (this._info.sample_count < _minSampleCount) {
        // Don't bother with under-sampled events.
        this._resetData();
        return;
      }
      var total_time_spent = global.performance.now() - start;
      var info = (0, _objectSpread.default)((0, _objectSpread.default)({}, this._info), {}, {
        total_time_spent
      });
      _listeners.forEach(listener => listener(info));
      this._resetData();
    }
    computeBlankness(props, cellsAroundViewport, scrollMetrics) {
      if (!this._enabled || props.getItemCount(props.data) === 0 || cellsAroundViewport.last < cellsAroundViewport.first || this._samplesStartTime == null) {
        return 0;
      }
      var dOffset = scrollMetrics.dOffset,
        offset = scrollMetrics.offset,
        velocity = scrollMetrics.velocity,
        visibleLength = scrollMetrics.visibleLength;

      // Denominator metrics that we track for all events - most of the time there is no blankness and
      // we want to capture that.
      this._info.sample_count++;
      this._info.pixels_sampled += Math.round(visibleLength);
      this._info.pixels_scrolled += Math.round(Math.abs(dOffset));
      var scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec

      // Whether blank now or not, record the elapsed time blank if we were blank last time.
      var now = global.performance.now();
      if (this._anyBlankStartTime != null) {
        this._info.any_blank_ms += now - this._anyBlankStartTime;
      }
      this._anyBlankStartTime = null;
      if (this._mostlyBlankStartTime != null) {
        this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;
      }
      this._mostlyBlankStartTime = null;
      var blankTop = 0;
      var first = cellsAroundViewport.first;
      var firstFrame = this._getFrameMetrics(first, props);
      while (first <= cellsAroundViewport.last && (!firstFrame || !firstFrame.inLayout)) {
        firstFrame = this._getFrameMetrics(first, props);
        first++;
      }
      // Only count blankTop if we aren't rendering the first item, otherwise we will count the header
      // as blank.
      if (firstFrame && first > 0) {
        blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));
      }
      var blankBottom = 0;
      var last = cellsAroundViewport.last;
      var lastFrame = this._getFrameMetrics(last, props);
      while (last >= cellsAroundViewport.first && (!lastFrame || !lastFrame.inLayout)) {
        lastFrame = this._getFrameMetrics(last, props);
        last--;
      }
      // Only count blankBottom if we aren't rendering the last item, otherwise we will count the
      // footer as blank.
      if (lastFrame && last < props.getItemCount(props.data) - 1) {
        var bottomEdge = lastFrame.offset + lastFrame.length;
        blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));
      }
      var pixels_blank = Math.round(blankTop + blankBottom);
      var blankness = pixels_blank / visibleLength;
      if (blankness > 0) {
        this._anyBlankStartTime = now;
        this._info.any_blank_speed_sum += scrollSpeed;
        this._info.any_blank_count++;
        this._info.pixels_blank += pixels_blank;
        if (blankness > 0.5) {
          this._mostlyBlankStartTime = now;
          this._info.mostly_blank_count++;
        }
      } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {
        this.deactivateAndFlush();
      }
      return blankness;
    }
    enabled() {
      return this._enabled;
    }
    _resetData() {
      this._anyBlankStartTime = null;
      this._info = new Info();
      this._mostlyBlankStartTime = null;
      this._samplesStartTime = null;
    }
  }
  var _default = FillRateHelper;
},177,[20]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return StateSafePureComponent;
    }
  });
  var _fbjsLibInvariant = require(_dependencyMap[0]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _react = require(_dependencyMap[1]);
  var React = _interopNamespace(_react);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * `setState` is called asynchronously, and should not rely on the value of
   * `this.props` or `this.state`:
   * https://reactjs.org/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous
   *
   * SafePureComponent adds runtime enforcement, to catch cases where these
   * variables are read in a state updater function, instead of the ones passed
   * in.
   */
  class StateSafePureComponent extends React.PureComponent {
    constructor(props) {
      super(props);
      this._inAsyncStateUpdate = false;
      this._installSetStateHooks();
    }
    setState(partialState, callback) {
      if (typeof partialState === 'function') {
        super.setState((state, props) => {
          this._inAsyncStateUpdate = true;
          var ret;
          try {
            ret = partialState(state, props);
          } catch (err) {
            throw err;
          } finally {
            this._inAsyncStateUpdate = false;
          }
          return ret;
        }, callback);
      } else {
        super.setState(partialState, callback);
      }
    }
    _installSetStateHooks() {
      var that = this;
      var props = this.props,
        state = this.state;
      Object.defineProperty(this, 'props', {
        get() {
          (0, invariant.default)(!that._inAsyncStateUpdate, '"this.props" should not be accessed during state updates');
          return props;
        },
        set(newProps) {
          props = newProps;
        }
      });
      Object.defineProperty(this, 'state', {
        get() {
          (0, invariant.default)(!that._inAsyncStateUpdate, '"this.state" should not be acceessed during state updates');
          return state;
        },
        set(newState) {
          state = newState;
        }
      });
    }
  }
},178,[25,35]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _babelRuntimeHelpersCreateForOfIteratorHelperLoose = require(_dependencyMap[1]);
  var _createForOfIteratorHelperLoose = _interopDefault(_babelRuntimeHelpersCreateForOfIteratorHelperLoose);
  var _fbjsLibInvariant = require(_dependencyMap[2]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  /**
   * A Utility class for calculating viewable items based on current metrics like scroll position and
   * layout.
   *
   * An item is said to be in a "viewable" state when any of the following
   * is true for longer than `minimumViewTime` milliseconds (after an interaction if `waitForInteraction`
   * is true):
   *
   * - Occupying >= `viewAreaCoveragePercentThreshold` of the view area XOR fraction of the item
   *   visible in the view area >= `itemVisiblePercentThreshold`.
   * - Entirely visible on screen
   */
  class ViewabilityHelper {
    constructor(config) {
      if (config === undefined) {
        config = {
          viewAreaCoveragePercentThreshold: 0
        };
      }
      this._hasInteracted = false;
      this._timers = new Set();
      this._viewableIndices = [];
      this._viewableItems = new Map();
      this._config = config;
    }

    /**
     * Cleanup, e.g. on unmount. Clears any pending timers.
     */
    dispose() {
      /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
       * comment suppresses an error found when Flow v0.63 was deployed. To see
       * the error delete this comment and run Flow. */
      this._timers.forEach(clearTimeout);
    }

    /**
     * Determines which items are viewable based on the current metrics and config.
     */
    computeViewableItems(props, scrollOffset, viewportHeight, getFrameMetrics,
    // Optional optimization to reduce the scan size
    renderRange) {
      var itemCount = props.getItemCount(props.data);
      var _this$_config = this._config,
        itemVisiblePercentThreshold = _this$_config.itemVisiblePercentThreshold,
        viewAreaCoveragePercentThreshold = _this$_config.viewAreaCoveragePercentThreshold;
      var viewAreaMode = viewAreaCoveragePercentThreshold != null;
      var viewablePercentThreshold = viewAreaMode ? viewAreaCoveragePercentThreshold : itemVisiblePercentThreshold;
      (0, invariant.default)(viewablePercentThreshold != null && itemVisiblePercentThreshold != null !== (viewAreaCoveragePercentThreshold != null), 'Must set exactly one of itemVisiblePercentThreshold or viewAreaCoveragePercentThreshold');
      var viewableIndices = [];
      if (itemCount === 0) {
        return viewableIndices;
      }
      var firstVisible = -1;
      var _ref = renderRange || {
          first: 0,
          last: itemCount - 1
        },
        first = _ref.first,
        last = _ref.last;
      if (last >= itemCount) {
        console.warn('Invalid render range computing viewability ' + JSON.stringify({
          renderRange,
          itemCount
        }));
        return [];
      }
      for (var idx = first; idx <= last; idx++) {
        var metrics = getFrameMetrics(idx, props);
        if (!metrics) {
          continue;
        }
        var top = metrics.offset - scrollOffset;
        var bottom = top + metrics.length;
        if (top < viewportHeight && bottom > 0) {
          firstVisible = idx;
          if (_isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, metrics.length)) {
            viewableIndices.push(idx);
          }
        } else if (firstVisible >= 0) {
          break;
        }
      }
      return viewableIndices;
    }

    /**
     * Figures out which items are viewable and how that has changed from before and calls
     * `onViewableItemsChanged` as appropriate.
     */
    onUpdate(props, scrollOffset, viewportHeight, getFrameMetrics, createViewToken, onViewableItemsChanged,
    // Optional optimization to reduce the scan size
    renderRange) {
      var itemCount = props.getItemCount(props.data);
      if (this._config.waitForInteraction && !this._hasInteracted || itemCount === 0 || !getFrameMetrics(0, props)) {
        return;
      }
      var viewableIndices = [];
      if (itemCount) {
        viewableIndices = this.computeViewableItems(props, scrollOffset, viewportHeight, getFrameMetrics, renderRange);
      }
      if (this._viewableIndices.length === viewableIndices.length && this._viewableIndices.every((v, ii) => v === viewableIndices[ii])) {
        // We might get a lot of scroll events where visibility doesn't change and we don't want to do
        // extra work in those cases.
        return;
      }
      this._viewableIndices = viewableIndices;
      if (this._config.minimumViewTime) {
        var handle = setTimeout(() => {
          /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
           * comment suppresses an error found when Flow v0.63 was deployed. To
           * see the error delete this comment and run Flow. */
          this._timers.delete(handle);
          this._onUpdateSync(props, viewableIndices, onViewableItemsChanged, createViewToken);
        }, this._config.minimumViewTime);
        /* $FlowFixMe[incompatible-call] (>=0.63.0 site=react_native_fb) This
         * comment suppresses an error found when Flow v0.63 was deployed. To see
         * the error delete this comment and run Flow. */
        this._timers.add(handle);
      } else {
        this._onUpdateSync(props, viewableIndices, onViewableItemsChanged, createViewToken);
      }
    }

    /**
     * clean-up cached _viewableIndices to evaluate changed items on next update
     */
    resetViewableIndices() {
      this._viewableIndices = [];
    }

    /**
     * Records that an interaction has happened even if there has been no scroll.
     */
    recordInteraction() {
      this._hasInteracted = true;
    }
    _onUpdateSync(props, viewableIndicesToCheck, onViewableItemsChanged, createViewToken) {
      // Filter out indices that have gone out of view since this call was scheduled.
      viewableIndicesToCheck = viewableIndicesToCheck.filter(ii => this._viewableIndices.includes(ii));
      var prevItems = this._viewableItems;
      var nextItems = new Map(viewableIndicesToCheck.map(ii => {
        var viewable = createViewToken(ii, true, props);
        return [viewable.key, viewable];
      }));
      var changed = [];
      for (var _iterator = (0, _createForOfIteratorHelperLoose.default)(nextItems), _step; !(_step = _iterator()).done;) {
        var _step$value = _step.value,
          key = _step$value[0],
          viewable = _step$value[1];
        if (!prevItems.has(key)) {
          changed.push(viewable);
        }
      }
      for (var _iterator2 = (0, _createForOfIteratorHelperLoose.default)(prevItems), _step2; !(_step2 = _iterator2()).done;) {
        var _step2$value = _step2.value,
          _key = _step2$value[0],
          _viewable = _step2$value[1];
        if (!nextItems.has(_key)) {
          changed.push((0, _objectSpread.default)((0, _objectSpread.default)({}, _viewable), {}, {
            isViewable: false
          }));
        }
      }
      if (changed.length > 0) {
        this._viewableItems = nextItems;
        onViewableItemsChanged({
          viewableItems: Array.from(nextItems.values()),
          changed,
          viewabilityConfig: this._config
        });
      }
    }
  }
  function _isViewable(viewAreaMode, viewablePercentThreshold, top, bottom, viewportHeight, itemLength) {
    if (_isEntirelyVisible(top, bottom, viewportHeight)) {
      return true;
    } else {
      var pixels = _getPixelsVisible(top, bottom, viewportHeight);
      var percent = 100 * (viewAreaMode ? pixels / viewportHeight : pixels / itemLength);
      return percent >= viewablePercentThreshold;
    }
  }
  function _getPixelsVisible(top, bottom, viewportHeight) {
    var visibleHeight = Math.min(bottom, viewportHeight) - Math.max(top, 0);
    return Math.max(0, visibleHeight);
  }
  function _isEntirelyVisible(top, bottom, viewportHeight) {
    return top >= 0 && bottom <= viewportHeight && bottom > top;
  }
  var _default = ViewabilityHelper;
},179,[20,157,25]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return CellRenderer;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[1]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _exportsView = require(_dependencyMap[2]);
  var View = _interopDefault(_exportsView);
  var _exportsStyleSheet = require(_dependencyMap[3]);
  var StyleSheet = _interopDefault(_exportsStyleSheet);
  var _VirtualizedListContextJs = require(_dependencyMap[4]);
  var _fbjsLibInvariant = require(_dependencyMap[5]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _react = require(_dependencyMap[6]);
  var React = _interopNamespace(_react);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  class CellRenderer extends React.Component {
    constructor() {
      super(...arguments);
      this.state = {
        separatorProps: {
          highlighted: false,
          leadingItem: this.props.item
        }
      };
      this._separators = {
        highlight: () => {
          var _this$props = this.props,
            cellKey = _this$props.cellKey,
            prevCellKey = _this$props.prevCellKey;
          this.props.onUpdateSeparators([cellKey, prevCellKey], {
            highlighted: true
          });
        },
        unhighlight: () => {
          var _this$props2 = this.props,
            cellKey = _this$props2.cellKey,
            prevCellKey = _this$props2.prevCellKey;
          this.props.onUpdateSeparators([cellKey, prevCellKey], {
            highlighted: false
          });
        },
        updateProps: (select, newProps) => {
          var _this$props3 = this.props,
            cellKey = _this$props3.cellKey,
            prevCellKey = _this$props3.prevCellKey;
          this.props.onUpdateSeparators([select === 'leading' ? prevCellKey : cellKey], newProps);
        }
      };
      this._onLayout = nativeEvent => {
        this.props.onCellLayout && this.props.onCellLayout(nativeEvent, this.props.cellKey, this.props.index);
      };
    }
    static getDerivedStateFromProps(props, prevState) {
      return {
        separatorProps: (0, _objectSpread.default)((0, _objectSpread.default)({}, prevState.separatorProps), {}, {
          leadingItem: props.item
        })
      };
    }

    // TODO: consider factoring separator stuff out of VirtualizedList into FlatList since it's not
    // reused by SectionList and we can keep VirtualizedList simpler.
    // $FlowFixMe[missing-local-annot]

    updateSeparatorProps(newProps) {
      this.setState(state => ({
        separatorProps: (0, _objectSpread.default)((0, _objectSpread.default)({}, state.separatorProps), newProps)
      }));
    }
    componentWillUnmount() {
      this.props.onUnmount(this.props.cellKey);
    }
    _renderElement(renderItem, ListItemComponent, item, index) {
      if (renderItem && ListItemComponent) {
        console.warn("VirtualizedList: Both ListItemComponent and renderItem props are present. ListItemComponent will take precedence over renderItem.");
      }
      if (ListItemComponent) {
        /* $FlowFixMe[not-a-component] (>=0.108.0 site=react_native_fb) This
         * comment suppresses an error found when Flow v0.108 was deployed. To
         * see the error, delete this comment and run Flow. */
        /* $FlowFixMe[incompatible-type-arg] (>=0.108.0 site=react_native_fb)
         * This comment suppresses an error found when Flow v0.108 was deployed.
         * To see the error, delete this comment and run Flow. */
        return /*#__PURE__*/React.createElement(ListItemComponent, {
          item,
          index,
          separators: this._separators
        });
      }
      if (renderItem) {
        return renderItem({
          item,
          index,
          separators: this._separators
        });
      }
      (0, invariant.default)(false, 'VirtualizedList: Either ListItemComponent or renderItem props are required but none were found.');
    }
    render() {
      var _this$props4 = this.props,
        CellRendererComponent = _this$props4.CellRendererComponent,
        ItemSeparatorComponent = _this$props4.ItemSeparatorComponent,
        ListItemComponent = _this$props4.ListItemComponent,
        cellKey = _this$props4.cellKey,
        horizontal = _this$props4.horizontal,
        item = _this$props4.item,
        index = _this$props4.index,
        inversionStyle = _this$props4.inversionStyle,
        onCellFocusCapture = _this$props4.onCellFocusCapture,
        onCellLayout = _this$props4.onCellLayout,
        renderItem = _this$props4.renderItem;
      var element = this._renderElement(renderItem, ListItemComponent, item, index);

      // NOTE: that when this is a sticky header, `onLayout` will get automatically extracted and
      // called explicitly by `ScrollViewStickyHeader`.
      var itemSeparator = /*#__PURE__*/ /*#__PURE__*/React.isValidElement(ItemSeparatorComponent) ?
      // $FlowFixMe[incompatible-type]
      ItemSeparatorComponent :
      // $FlowFixMe[incompatible-type]
      ItemSeparatorComponent && /*#__PURE__*/React.createElement(ItemSeparatorComponent, this.state.separatorProps);
      var cellStyle = inversionStyle ? horizontal ? [styles.rowReverse, inversionStyle] : [styles.columnReverse, inversionStyle] : horizontal ? [styles.row, inversionStyle] : inversionStyle;
      var result = !CellRendererComponent ? /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({
        style: cellStyle,
        onFocusCapture: onCellFocusCapture
      }, onCellLayout && {
        onLayout: this._onLayout
      }), element, itemSeparator) : /*#__PURE__*/React.createElement(CellRendererComponent, (0, _extends.default)({
        cellKey: cellKey,
        index: index,
        item: item,
        style: cellStyle,
        onFocusCapture: onCellFocusCapture
      }, onCellLayout && {
        onLayout: this._onLayout
      }), element, itemSeparator);
      return /*#__PURE__*/React.createElement(_VirtualizedListContextJs.VirtualizedListCellContextProvider, {
        cellKey: this.props.cellKey
      }, result);
    }
  }
  var styles = StyleSheet.default.create({
    row: {
      flexDirection: 'row'
    },
    rowReverse: {
      flexDirection: 'row-reverse'
    },
    columnReverse: {
      flexDirection: 'column-reverse'
    }
  });
},180,[28,20,138,43,181,25,35]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "VirtualizedListContext", {
    enumerable: true,
    get: function () {
      return VirtualizedListContext;
    }
  });
  exports.VirtualizedListContextResetter = VirtualizedListContextResetter;
  exports.VirtualizedListContextProvider = VirtualizedListContextProvider;
  exports.VirtualizedListCellContextProvider = VirtualizedListCellContextProvider;
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _react = require(_dependencyMap[1]);
  var React = _interopNamespace(_react);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  var __DEV__ = false;
  var VirtualizedListContext = /*#__PURE__*/React.createContext(null);
  /**
   * Resets the context. Intended for use by portal-like components (e.g. Modal).
   */
  function VirtualizedListContextResetter(_ref) {
    var children = _ref.children;
    return /*#__PURE__*/React.createElement(VirtualizedListContext.Provider, {
      value: null
    }, children);
  }

  /**
   * Sets the context with memoization. Intended to be used by `VirtualizedList`.
   */
  function VirtualizedListContextProvider(_ref2) {
    var children = _ref2.children,
      value = _ref2.value;
    // Avoid setting a newly created context object if the values are identical.
    var context = (0, _react.useMemo)(() => ({
      cellKey: null,
      getScrollMetrics: value.getScrollMetrics,
      horizontal: value.horizontal,
      getOutermostParentListRef: value.getOutermostParentListRef,
      registerAsNestedChild: value.registerAsNestedChild,
      unregisterAsNestedChild: value.unregisterAsNestedChild
    }), [value.getScrollMetrics, value.horizontal, value.getOutermostParentListRef, value.registerAsNestedChild, value.unregisterAsNestedChild]);
    return /*#__PURE__*/React.createElement(VirtualizedListContext.Provider, {
      value: context
    }, children);
  }

  /**
   * Sets the `cellKey`. Intended to be used by `VirtualizedList` for each cell.
   */
  function VirtualizedListCellContextProvider(_ref3) {
    var cellKey = _ref3.cellKey,
      children = _ref3.children;
    // Avoid setting a newly created context object if the values are identical.
    var currContext = (0, _react.useContext)(VirtualizedListContext);
    var context = (0, _react.useMemo)(() => currContext == null ? null : (0, _objectSpread.default)((0, _objectSpread.default)({}, currContext), {}, {
      cellKey
    }), [currContext, cellKey]);
    return /*#__PURE__*/React.createElement(VirtualizedListContext.Provider, {
      value: context
    }, children);
  }
},181,[20,35]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  /**
   * Used to find the indices of the frames that overlap the given offsets. Useful for finding the
   * items that bound different windows of content, such as the visible area or the buffered overscan
   * area.
   */
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.elementsThatOverlapOffsets = elementsThatOverlapOffsets;
  exports.newRangeCount = newRangeCount;
  exports.computeWindowedRenderLimits = computeWindowedRenderLimits;
  exports.keyExtractor = keyExtractor;
  function elementsThatOverlapOffsets(offsets, props, getFrameMetrics, zoomScale) {
    if (zoomScale === undefined) {
      zoomScale = 1;
    }
    var itemCount = props.getItemCount(props.data);
    var result = [];
    for (var offsetIndex = 0; offsetIndex < offsets.length; offsetIndex++) {
      var currentOffset = offsets[offsetIndex];
      var left = 0;
      var right = itemCount - 1;
      while (left <= right) {
        // eslint-disable-next-line no-bitwise
        var mid = left + (right - left >>> 1);
        var frame = getFrameMetrics(mid, props);
        var scaledOffsetStart = frame.offset * zoomScale;
        var scaledOffsetEnd = (frame.offset + frame.length) * zoomScale;

        // We want the first frame that contains the offset, with inclusive bounds. Thus, for the
        // first frame the scaledOffsetStart is inclusive, while for other frames it is exclusive.
        if (mid === 0 && currentOffset < scaledOffsetStart || mid !== 0 && currentOffset <= scaledOffsetStart) {
          right = mid - 1;
        } else if (currentOffset > scaledOffsetEnd) {
          left = mid + 1;
        } else {
          result[offsetIndex] = mid;
          break;
        }
      }
    }
    return result;
  }

  /**
   * Computes the number of elements in the `next` range that are new compared to the `prev` range.
   * Handy for calculating how many new items will be rendered when the render window changes so we
   * can restrict the number of new items render at once so that content can appear on the screen
   * faster.
   */
  function newRangeCount(prev, next) {
    return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));
  }

  /**
   * Custom logic for determining which items should be rendered given the current frame and scroll
   * metrics, as well as the previous render state. The algorithm may evolve over time, but generally
   * prioritizes the visible area first, then expands that with overscan regions ahead and behind,
   * biased in the direction of scroll.
   */
  function computeWindowedRenderLimits(props, maxToRenderPerBatch, windowSize, prev, getFrameMetricsApprox, scrollMetrics) {
    var itemCount = props.getItemCount(props.data);
    if (itemCount === 0) {
      return {
        first: 0,
        last: -1
      };
    }
    var offset = scrollMetrics.offset,
      velocity = scrollMetrics.velocity,
      visibleLength = scrollMetrics.visibleLength,
      _scrollMetrics$zoomSc = scrollMetrics.zoomScale,
      zoomScale = _scrollMetrics$zoomSc === undefined ? 1 : _scrollMetrics$zoomSc;

    // Start with visible area, then compute maximum overscan region by expanding from there, biased
    // in the direction of scroll. Total overscan area is capped, which should cap memory consumption
    // too.
    var visibleBegin = Math.max(0, offset);
    var visibleEnd = visibleBegin + visibleLength;
    var overscanLength = (windowSize - 1) * visibleLength;

    // Considering velocity seems to introduce more churn than it's worth.
    var leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));

    var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';
    var overscanBegin = Math.max(0, visibleBegin - 0.5 * overscanLength);
    var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);
    var lastItemOffset = getFrameMetricsApprox(itemCount - 1, props).offset * zoomScale;
    if (lastItemOffset < overscanBegin) {
      // Entire list is before our overscan window
      return {
        first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),
        last: itemCount - 1
      };
    }

    // Find the indices that correspond to the items at the render boundaries we're targeting.
    var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], props, getFrameMetricsApprox, zoomScale),
      overscanFirst = _elementsThatOverlapO[0],
      first = _elementsThatOverlapO[1],
      last = _elementsThatOverlapO[2],
      overscanLast = _elementsThatOverlapO[3];
    overscanFirst = overscanFirst == null ? 0 : overscanFirst;
    first = first == null ? Math.max(0, overscanFirst) : first;
    overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;
    last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;
    var visible = {
      first,
      last
    };

    // We want to limit the number of new cells we're rendering per batch so that we can fill the
    // content on the screen quickly. If we rendered the entire overscan window at once, the user
    // could be staring at white space for a long time waiting for a bunch of offscreen content to
    // render.
    var newCellCount = newRangeCount(prev, visible);
    while (true) {
      if (first <= overscanFirst && last >= overscanLast) {
        // If we fill the entire overscan range, we're done.
        break;
      }
      var maxNewCells = newCellCount >= maxToRenderPerBatch;
      var firstWillAddMore = first <= prev.first || first > prev.last;
      var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);
      var lastWillAddMore = last >= prev.last || last < prev.first;
      var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);
      if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {
        // We only want to stop if we've hit maxNewCells AND we cannot increment first or last
        // without rendering new items. This let's us preserve as many already rendered items as
        // possible, reducing render churn and keeping the rendered overscan range as large as
        // possible.
        break;
      }
      if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {
        if (firstWillAddMore) {
          newCellCount++;
        }
        first--;
      }
      if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {
        if (lastWillAddMore) {
          newCellCount++;
        }
        last++;
      }
    }
    if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {
      throw new Error('Bad window calculation ' + JSON.stringify({
        first,
        last,
        itemCount,
        overscanFirst,
        overscanLast,
        visible
      }));
    }
    return {
      first,
      last
    };
  }
  function keyExtractor(item, index) {
    if (typeof item === 'object' && (item == null ? undefined : item.key) != null) {
      return item.key;
    }
    if (typeof item === 'object' && (item == null ? undefined : item.id) != null) {
      return item.id;
    }
    return String(index);
  }
},182,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  function nullthrows(x, message) {
    if (x != null) {
      return x;
    }
    var error = new Error(message !== undefined ? message : 'Got unexpected ' + x);
    error.framesToPop = 1; // Skip nullthrows's own stack frame.
    throw error;
  }
  module.exports = nullthrows;
  module.exports.default = nullthrows;
  Object.defineProperty(module.exports, '__esModule', {
    value: true
  });
},183,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return memoizeOne;
    }
  });
  var safeIsNaN = Number.isNaN || function ponyfill(value) {
    return typeof value === 'number' && value !== value;
  };
  function isEqual(first, second) {
    if (first === second) {
      return true;
    }
    if (safeIsNaN(first) && safeIsNaN(second)) {
      return true;
    }
    return false;
  }
  function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
      return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
      if (!isEqual(newInputs[i], lastInputs[i])) {
        return false;
      }
    }
    return true;
  }
  function memoizeOne(resultFn, isEqual) {
    if (isEqual === undefined) {
      isEqual = areInputsEqual;
    }
    var cache = null;
    function memoized() {
      var newArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        newArgs[_i] = arguments[_i];
      }
      if (cache && cache.lastThis === this && isEqual(newArgs, cache.lastArgs)) {
        return cache.lastResult;
      }
      var lastResult = resultFn.apply(this, newArgs);
      cache = {
        lastResult: lastResult,
        lastArgs: newArgs,
        lastThis: this
      };
      return lastResult;
    }
    memoized.clear = function clear() {
      cache = null;
    };
    return memoized;
  }
},184,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return createAnimatedComponent;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _useAnimatedProps2 = require(_dependencyMap[2]);
  var useAnimatedProps = _interopDefault(_useAnimatedProps2);
  var _UtilitiesUseMergeRefs = require(_dependencyMap[3]);
  var useMergeRefs = _interopDefault(_UtilitiesUseMergeRefs);
  require(_dependencyMap[4]);
  require(_dependencyMap[5]);
  var _react = require(_dependencyMap[6]);
  var React = _interopNamespace(_react);
  var _excluded = ["style"];
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * Experimental implementation of `createAnimatedComponent` that is intended to
   * be compatible with concurrent rendering.
   */
  function createAnimatedComponent(Component) {
    return /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
      var _useAnimatedProps = (0, useAnimatedProps.default)(props),
        reducedProps = _useAnimatedProps[0],
        callbackRef = _useAnimatedProps[1];
      var ref = (0, useMergeRefs.default)(callbackRef, forwardedRef);

      // Some components require explicit passthrough values for animation
      // to work properly. For example, if an animated component is
      // transformed and Pressable, onPress will not work after transform
      // without these passthrough values.
      // $FlowFixMe[prop-missing]
      var passthroughAnimatedPropExplicitValues = reducedProps.passthroughAnimatedPropExplicitValues,
        style = reducedProps.style;
      var _ref = passthroughAnimatedPropExplicitValues !== null && passthroughAnimatedPropExplicitValues !== undefined ? passthroughAnimatedPropExplicitValues : {},
        passthroughStyle = _ref.style,
        passthroughProps = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
      var mergedStyle = [style, passthroughStyle];
      return /*#__PURE__*/React.createElement(Component, (0, _extends.default)({}, reducedProps, passthroughProps, {
        style: mergedStyle,
        ref: ref
      }));
    });
  }
},185,[28,44,186,204,43,138,35]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useAnimatedProps;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _nodesAnimatedProps = require(_dependencyMap[1]);
  var AnimatedProps = _interopDefault(_nodesAnimatedProps);
  var _AnimatedEvent = require(_dependencyMap[2]);
  var _UtilitiesUseRefEffect = require(_dependencyMap[3]);
  var useRefEffect = _interopDefault(_UtilitiesUseRefEffect);
  var _NativeAnimatedHelper = require(_dependencyMap[4]);
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  var _react = require(_dependencyMap[5]);
  var _modulesUseLayoutEffect = require(_dependencyMap[6]);
  var useLayoutEffect = _interopDefault(_modulesUseLayoutEffect);
  function useAnimatedProps(props) {
    var _useReducer = (0, _react.useReducer)(count => count + 1, 0),
      scheduleUpdate = _useReducer[1];
    var onUpdateRef = (0, _react.useRef)(null);

    // TODO: Only invalidate `node` if animated props or `style` change. In the
    // previous implementation, we permitted `style` to override props with the
    // same name property name as styles, so we can probably continue doing that.
    // The ordering of other props *should* not matter.
    var node = (0, _react.useMemo)(() => new AnimatedProps.default(props, () => onUpdateRef.current == null ? undefined : onUpdateRef.current()), [props]);
    useAnimatedPropsLifecycle(node);

    // TODO: This "effect" does three things:
    //
    //   1) Call `setNativeView`.
    //   2) Update `onUpdateRef`.
    //   3) Update listeners for `AnimatedEvent` props.
    //
    // Ideally, each of these would be separat "effects" so that they are not
    // unnecessarily re-run when irrelevant dependencies change. For example, we
    // should be able to hoist all `AnimatedEvent` props and only do #3 if either
    // the `AnimatedEvent` props change or `instance` changes.
    //
    // But there is no way to transparently compose three separate callback refs,
    // so we just combine them all into one for now.
    var refEffect = (0, _react.useCallback)(instance => {
      // NOTE: This may be called more often than necessary (e.g. when `props`
      // changes), but `setNativeView` already optimizes for that.
      node.setNativeView(instance);

      // NOTE: This callback is only used by the JavaScript animation driver.
      onUpdateRef.current = () => {
        // Schedule an update for this component to update `reducedProps`,
        // but do not compute it immediately. If a parent also updated, we
        // need to merge those new props in before updating.
        scheduleUpdate();
      };
      var target = getEventTarget(instance);
      var events = [];
      for (var propName in props) {
        var propValue = props[propName];
        if (propValue instanceof _AnimatedEvent.AnimatedEvent && propValue.__isNative) {
          propValue.__attach(target, propName);
          events.push([propName, propValue]);
        }
      }
      return () => {
        onUpdateRef.current = null;
        for (var _i = 0, _events = events; _i < _events.length; _i++) {
          var _events$_i = _events[_i],
            _propName = _events$_i[0],
            _propValue = _events$_i[1];
          _propValue.__detach(target, _propName);
        }
      };
    }, [props, node]);
    var callbackRef = (0, useRefEffect.default)(refEffect);
    return [reduceAnimatedProps(node), callbackRef];
  }
  function reduceAnimatedProps(node) {
    // Force `collapsable` to be false so that the native view is not flattened.
    // Flattened views cannot be accurately referenced by the native driver.
    return (0, _objectSpread.default)((0, _objectSpread.default)({}, node.__getValue()), {}, {
      collapsable: false
    });
  }

  /**
   * Manages the lifecycle of the supplied `AnimatedProps` by invoking `__attach`
   * and `__detach`. However, this is more complicated because `AnimatedProps`
   * uses reference counting to determine when to recursively detach its children
   * nodes. So in order to optimize this, we avoid detaching until the next attach
   * unless we are unmounting.
   */
  function useAnimatedPropsLifecycle(node) {
    var prevNodeRef = (0, _react.useRef)(null);
    var isUnmountingRef = (0, _react.useRef)(false);
    (0, _react.useEffect)(() => {
      // It is ok for multiple components to call `flushQueue` because it noops
      // if the queue is empty. When multiple animated components are mounted at
      // the same time. Only first component flushes the queue and the others will noop.
      NativeAnimatedHelper.default.API.flushQueue();
    });
    (0, useLayoutEffect.default)(() => {
      isUnmountingRef.current = false;
      return () => {
        isUnmountingRef.current = true;
      };
    }, []);
    (0, useLayoutEffect.default)(() => {
      node.__attach();
      if (prevNodeRef.current != null) {
        var prevNode = prevNodeRef.current;
        // TODO: Stop restoring default values (unless `reset` is called).
        prevNode.__restoreDefaultValues();
        prevNode.__detach();
        prevNodeRef.current = null;
      }
      return () => {
        if (isUnmountingRef.current) {
          // NOTE: Do not restore default values on unmount, see D18197735.
          node.__detach();
        } else {
          prevNodeRef.current = node;
        }
      };
    }, [node]);
  }
  function getEventTarget(instance) {
    return typeof instance === 'object' && typeof (instance == null ? undefined : instance.getScrollableNode) === 'function' ?
    // $FlowFixMe[incompatible-use] - Legacy instance assumptions.
    instance.getScrollableNode() : instance;
  }

  // $FlowFixMe[unclear-type] - Legacy instance assumptions.

  // $FlowFixMe[unclear-type] - Legacy instance assumptions.
},186,[20,187,188,203,193,35,142]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _AnimatedEvent = require(_dependencyMap[1]);
  var _AnimatedNode = require(_dependencyMap[2]);
  var AnimatedNode = _interopDefault(_AnimatedNode);
  var _AnimatedStyle = require(_dependencyMap[3]);
  var AnimatedStyle = _interopDefault(_AnimatedStyle);
  var _NativeAnimatedHelper = require(_dependencyMap[4]);
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  var _fbjsLibInvariant = require(_dependencyMap[5]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  class AnimatedProps extends AnimatedNode.default {
    constructor(props, callback) {
      super();
      if (props.style) {
        props = (0, _objectSpread.default)((0, _objectSpread.default)({}, props), {}, {
          style: new AnimatedStyle.default(props.style)
        });
      }
      this._props = props;
      this._callback = callback;
      this.__attach();
    }
    __getValue() {
      var props = {};
      for (var key in this._props) {
        var value = this._props[key];
        if (value instanceof AnimatedNode.default) {
          if (!value.__isNative || value instanceof AnimatedStyle.default) {
            // We cannot use value of natively driven nodes this way as the value we have access from
            // JS may not be up to date.
            props[key] = value.__getValue();
          }
        } else if (value instanceof _AnimatedEvent.AnimatedEvent) {
          props[key] = value.__getHandler();
        } else {
          props[key] = value;
        }
      }
      return props;
    }
    __getAnimatedValue() {
      var props = {};
      for (var key in this._props) {
        var value = this._props[key];
        if (value instanceof AnimatedNode.default) {
          props[key] = value.__getAnimatedValue();
        }
      }
      return props;
    }
    __attach() {
      for (var key in this._props) {
        var value = this._props[key];
        if (value instanceof AnimatedNode.default) {
          value.__addChild(this);
        }
      }
    }
    __detach() {
      if (this.__isNative && this._animatedView) {
        this.__disconnectAnimatedView();
      }
      this._animatedView = null;
      for (var key in this._props) {
        var value = this._props[key];
        if (value instanceof AnimatedNode.default) {
          value.__removeChild(this);
        }
      }
      super.__detach();
    }
    update() {
      this._callback();
    }
    __makeNative() {
      if (!this.__isNative) {
        this.__isNative = true;
        for (var key in this._props) {
          var value = this._props[key];
          if (value instanceof AnimatedNode.default) {
            value.__makeNative();
          }
        }
        if (this._animatedView) {
          this.__connectAnimatedView();
        }
      }
    }
    setNativeView(animatedView) {
      if (this._animatedView === animatedView) {
        return;
      }
      this._animatedView = animatedView;
      if (this.__isNative) {
        this.__connectAnimatedView();
      }
    }
    __connectAnimatedView() {
      (0, invariant.default)(this.__isNative, 'Expected node to be marked as "native"');
      var nativeViewTag = this._animatedView;
      (0, invariant.default)(nativeViewTag != null, 'Unable to locate attached view in the native tree');
      NativeAnimatedHelper.default.API.connectAnimatedNodeToView(this.__getNativeTag(), nativeViewTag);
    }
    __disconnectAnimatedView() {
      (0, invariant.default)(this.__isNative, 'Expected node to be marked as "native"');
      var nativeViewTag = this._animatedView;
      (0, invariant.default)(nativeViewTag != null, 'Unable to locate attached view in the native tree');
      NativeAnimatedHelper.default.API.disconnectAnimatedNodeFromView(this.__getNativeTag(), nativeViewTag);
    }
    __restoreDefaultValues() {
      // When using the native driver, view properties need to be restored to
      // their default values manually since react no longer tracks them. This
      // is needed to handle cases where a prop driven by native animated is removed
      // after having been changed natively by an animation.
      if (this.__isNative) {
        NativeAnimatedHelper.default.API.restoreDefaultValues(this.__getNativeTag());
      }
    }
    __getNativeConfig() {
      var propsConfig = {};
      for (var propKey in this._props) {
        var value = this._props[propKey];
        if (value instanceof AnimatedNode.default) {
          value.__makeNative();
          propsConfig[propKey] = value.__getNativeTag();
        }
      }
      return {
        type: 'props',
        props: propsConfig
      };
    }
  }
  var _default = AnimatedProps;
},187,[20,188,192,201,193,25]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.attachNativeEvent = attachNativeEvent;
  Object.defineProperty(exports, "AnimatedEvent", {
    enumerable: true,
    get: function () {
      return AnimatedEvent;
    }
  });
  var _nodesAnimatedValue = require(_dependencyMap[0]);
  var AnimatedValue = _interopDefault(_nodesAnimatedValue);
  var _NativeAnimatedHelper = require(_dependencyMap[1]);
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  var _fbjsLibInvariant = require(_dependencyMap[2]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  var __DEV__ = false;
  function attachNativeEvent(viewRef, eventName, argMapping) {
    // Find animated values in `argMapping` and create an array representing their
    // key path inside the `nativeEvent` object. Ex.: ['contentOffset', 'x'].
    var eventMappings = [];
    var traverse = (value, path) => {
      if (value instanceof AnimatedValue.default) {
        value.__makeNative();
        eventMappings.push({
          nativeEventPath: path,
          animatedValueTag: value.__getNativeTag()
        });
      } else if (typeof value === 'object') {
        for (var _key in value) {
          traverse(value[_key], path.concat(_key));
        }
      }
    };
    (0, invariant.default)(argMapping[0] && argMapping[0].nativeEvent, 'Native driven events only support animated values contained inside `nativeEvent`.');

    // Assume that the event containing `nativeEvent` is always the first argument.
    traverse(argMapping[0].nativeEvent, []);
    if (viewRef != null) {
      eventMappings.forEach(mapping => {
        NativeAnimatedHelper.default.API.addAnimatedEventToView(viewRef, eventName, mapping);
      });
    }
    return {
      detach() {
        if (viewRef != null) {
          eventMappings.forEach(mapping => {
            NativeAnimatedHelper.default.API.removeAnimatedEventFromView(viewRef, eventName,
            // $FlowFixMe[incompatible-call]
            mapping.animatedValueTag);
          });
        }
      }
    };
  }
  class AnimatedEvent {
    constructor(argMapping, config) {
      this._listeners = [];
      this._argMapping = argMapping;
      if (config == null) {
        console.warn('Animated.event now requires a second argument for options');
        config = {
          useNativeDriver: false
        };
      }
      if (config.listener) {
        this.__addListener(config.listener);
      }
      this._callListeners = this._callListeners.bind(this);
      this._attachedEvent = null;
      this.__isNative = (0, _NativeAnimatedHelper.shouldUseNativeDriver)(config);
    }
    __addListener(callback) {
      this._listeners.push(callback);
    }
    __removeListener(callback) {
      this._listeners = this._listeners.filter(listener => listener !== callback);
    }
    __attach(viewRef, eventName) {
      (0, invariant.default)(this.__isNative, 'Only native driven events need to be attached.');
      this._attachedEvent = attachNativeEvent(viewRef, eventName, this._argMapping);
    }
    __detach(viewTag, eventName) {
      (0, invariant.default)(this.__isNative, 'Only native driven events need to be detached.');
      this._attachedEvent && this._attachedEvent.detach();
    }
    __getHandler() {
      var _this = this;
      if (this.__isNative) {
        {
          return this._callListeners;
        }
      }
      var validatedMapping = false;
      return function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
          args[_key3] = arguments[_key3];
        }
        var traverse = (recMapping, recEvt, key) => {
          if (recMapping instanceof AnimatedValue.default) {
            if (typeof recEvt === 'number') {
              recMapping.setValue(recEvt);
            }
          } else if (typeof recMapping === 'object') {
            for (var mappingKey in recMapping) {
              /* $FlowFixMe(>=0.120.0) This comment suppresses an error found
               * when Flow v0.120 was deployed. To see the error, delete this
               * comment and run Flow. */
              traverse(recMapping[mappingKey], recEvt[mappingKey], mappingKey);
            }
          }
        };
        _this._argMapping.forEach((mapping, idx) => {
          traverse(mapping, args[idx], 'arg' + idx);
        });
        _this._callListeners(...args);
      };
    }
    _callListeners() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
        args[_key4] = arguments[_key4];
      }
      this._listeners.forEach(listener => listener(...args));
    }
  }
},188,[189,193,25]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _AnimatedInterpolation = require(_dependencyMap[0]);
  var AnimatedInterpolation = _interopDefault(_AnimatedInterpolation);
  var _AnimatedWithChildren = require(_dependencyMap[1]);
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  var _exportsInteractionManager = require(_dependencyMap[2]);
  var InteractionManager = _interopDefault(_exportsInteractionManager);
  var _NativeAnimatedHelper = require(_dependencyMap[3]);
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  var NativeAnimatedAPI = NativeAnimatedHelper.default.API;

  /**
   * Animated works by building a directed acyclic graph of dependencies
   * transparently when you render your Animated components.
   *
   *               new Animated.Value(0)
   *     .interpolate()        .interpolate()    new Animated.Value(1)
   *         opacity               translateY      scale
   *          style                         transform
   *         View#234                         style
   *                                         View#123
   *
   * A) Top Down phase
   * When an Animated.Value is updated, we recursively go down through this
   * graph in order to find leaf nodes: the views that we flag as needing
   * an update.
   *
   * B) Bottom Up phase
   * When a view is flagged as needing an update, we recursively go back up
   * in order to build the new value that it needs. The reason why we need
   * this two-phases process is to deal with composite props such as
   * transform which can receive values from multiple parents.
   */
  function _flush(rootNode) {
    var animatedStyles = new Set();
    function findAnimatedStyles(node) {
      /* $FlowFixMe[prop-missing] (>=0.68.0 site=react_native_fb) This comment
       * suppresses an error found when Flow v0.68 was deployed. To see the error
       * delete this comment and run Flow. */
      if (typeof node.update === 'function') {
        animatedStyles.add(node);
      } else {
        node.__getChildren().forEach(findAnimatedStyles);
      }
    }
    findAnimatedStyles(rootNode);
    // $FlowFixMe[prop-missing]
    animatedStyles.forEach(animatedStyle => animatedStyle.update());
  }

  /**
   * Some operations are executed only on batch end, which is _mostly_ scheduled when
   * Animated component props change. For some of the changes which require immediate execution
   * (e.g. setValue), we create a separate batch in case none is scheduled.
   */
  function _executeAsAnimatedBatch(id, operation) {
    NativeAnimatedAPI.setWaitingForIdentifier(id);
    operation();
    NativeAnimatedAPI.unsetWaitingForIdentifier(id);
  }

  /**
   * Standard value for driving animations.  One `Animated.Value` can drive
   * multiple properties in a synchronized fashion, but can only be driven by one
   * mechanism at a time.  Using a new mechanism (e.g. starting a new animation,
   * or calling `setValue`) will stop any previous ones.
   *
   * See https://reactnative.dev/docs/animatedvalue
   */
  class AnimatedValue extends AnimatedWithChildren.default {
    constructor(value, config) {
      super();
      if (typeof value !== 'number') {
        throw new Error('AnimatedValue: Attempting to set value to undefined');
      }
      this._startingValue = this._value = value;
      this._offset = 0;
      this._animation = null;
      if (config && config.useNativeDriver) {
        this.__makeNative();
      }
    }
    __detach() {
      if (this.__isNative) {
        NativeAnimatedAPI.getValue(this.__getNativeTag(), value => {
          this._value = value - this._offset;
        });
      }
      this.stopAnimation();
      super.__detach();
    }
    __getValue() {
      return this._value + this._offset;
    }

    /**
     * Directly set the value.  This will stop any animations running on the value
     * and update all the bound properties.
     *
     * See https://reactnative.dev/docs/animatedvalue#setvalue
     */
    setValue(value) {
      if (this._animation) {
        this._animation.stop();
        this._animation = null;
      }
      this._updateValue(value, !this.__isNative /* don't perform a flush for natively driven values */);
      if (this.__isNative) {
        _executeAsAnimatedBatch(this.__getNativeTag().toString(), () => NativeAnimatedAPI.setAnimatedNodeValue(this.__getNativeTag(), value));
      }
    }

    /**
     * Sets an offset that is applied on top of whatever value is set, whether via
     * `setValue`, an animation, or `Animated.event`.  Useful for compensating
     * things like the start of a pan gesture.
     *
     * See https://reactnative.dev/docs/animatedvalue#setoffset
     */
    setOffset(offset) {
      this._offset = offset;
      if (this.__isNative) {
        NativeAnimatedAPI.setAnimatedNodeOffset(this.__getNativeTag(), offset);
      }
    }

    /**
     * Merges the offset value into the base value and resets the offset to zero.
     * The final output of the value is unchanged.
     *
     * See https://reactnative.dev/docs/animatedvalue#flattenoffset
     */
    flattenOffset() {
      this._value += this._offset;
      this._offset = 0;
      if (this.__isNative) {
        NativeAnimatedAPI.flattenAnimatedNodeOffset(this.__getNativeTag());
      }
    }

    /**
     * Sets the offset value to the base value, and resets the base value to zero.
     * The final output of the value is unchanged.
     *
     * See https://reactnative.dev/docs/animatedvalue#extractoffset
     */
    extractOffset() {
      this._offset += this._value;
      this._value = 0;
      if (this.__isNative) {
        NativeAnimatedAPI.extractAnimatedNodeOffset(this.__getNativeTag());
      }
    }

    /**
     * Stops any running animation or tracking. `callback` is invoked with the
     * final value after stopping the animation, which is useful for updating
     * state to match the animation position with layout.
     *
     * See https://reactnative.dev/docs/animatedvalue#stopanimation
     */
    stopAnimation(callback) {
      this.stopTracking();
      this._animation && this._animation.stop();
      this._animation = null;
      if (callback) {
        if (this.__isNative) {
          NativeAnimatedAPI.getValue(this.__getNativeTag(), callback);
        } else {
          callback(this.__getValue());
        }
      }
    }

    /**
     * Stops any animation and resets the value to its original.
     *
     * See https://reactnative.dev/docs/animatedvalue#resetanimation
     */
    resetAnimation(callback) {
      this.stopAnimation(callback);
      this._value = this._startingValue;
      if (this.__isNative) {
        NativeAnimatedAPI.setAnimatedNodeValue(this.__getNativeTag(), this._startingValue);
      }
    }
    __onAnimatedValueUpdateReceived(value) {
      this._updateValue(value, false /*flush*/);
    }

    /**
     * Interpolates the value before updating the property, e.g. mapping 0-1 to
     * 0-10.
     */
    interpolate(config) {
      return new AnimatedInterpolation.default(this, config);
    }

    /**
     * Typically only used internally, but could be used by a custom Animation
     * class.
     *
     * See https://reactnative.dev/docs/animatedvalue#animate
     */
    animate(animation, callback) {
      var handle = null;
      if (animation.__isInteraction) {
        handle = InteractionManager.default.createInteractionHandle();
      }
      var previousAnimation = this._animation;
      this._animation && this._animation.stop();
      this._animation = animation;
      animation.start(this._value, value => {
        // Natively driven animations will never call into that callback
        this._updateValue(value, true /* flush */);
      }, result => {
        this._animation = null;
        if (handle !== null) {
          InteractionManager.default.clearInteractionHandle(handle);
        }
        callback && callback(result);
      }, previousAnimation, this);
    }

    /**
     * Typically only used internally.
     */
    stopTracking() {
      this._tracking && this._tracking.__detach();
      this._tracking = null;
    }

    /**
     * Typically only used internally.
     */
    track(tracking) {
      this.stopTracking();
      this._tracking = tracking;
      // Make sure that the tracking animation starts executing
      this._tracking && this._tracking.update();
    }
    _updateValue(value, flush) {
      if (value === undefined) {
        throw new Error('AnimatedValue: Attempting to set value to undefined');
      }
      this._value = value;
      if (flush) {
        _flush(this);
      }
      super.__callListeners(this.__getValue());
    }
    __getNativeConfig() {
      return {
        type: 'value',
        value: this._value,
        offset: this._offset
      };
    }
  }
  var _default = AnimatedValue;
},189,[190,191,169,193]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /* eslint no-bitwise: 0 */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _AnimatedWithChildren = require(_dependencyMap[1]);
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  var _NativeAnimatedHelper = require(_dependencyMap[2]);
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  var _fbjsLibInvariant = require(_dependencyMap[3]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _reactNativeNormalizeColors = require(_dependencyMap[4]);
  var normalizeColor = _interopDefault(_reactNativeNormalizeColors);
  var __DEV__ = false;
  var linear = t => t;

  /**
   * Very handy helper to map input ranges to output ranges with an easing
   * function and custom behavior outside of the ranges.
   */
  function createInterpolation(config) {
    if (config.outputRange && typeof config.outputRange[0] === 'string') {
      return createInterpolationFromStringOutputRange(config);
    }
    var outputRange = config.outputRange;
    var inputRange = config.inputRange;
    var easing = config.easing || linear;
    var extrapolateLeft = 'extend';
    if (config.extrapolateLeft !== undefined) {
      extrapolateLeft = config.extrapolateLeft;
    } else if (config.extrapolate !== undefined) {
      extrapolateLeft = config.extrapolate;
    }
    var extrapolateRight = 'extend';
    if (config.extrapolateRight !== undefined) {
      extrapolateRight = config.extrapolateRight;
    } else if (config.extrapolate !== undefined) {
      extrapolateRight = config.extrapolate;
    }
    return input => {
      (0, invariant.default)(typeof input === 'number', 'Cannot interpolation an input which is not a number');
      var range = findRange(input, inputRange);
      return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight);
    };
  }
  function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight) {
    var result = input;

    // Extrapolate
    if (result < inputMin) {
      if (extrapolateLeft === 'identity') {
        return result;
      } else if (extrapolateLeft === 'clamp') {
        result = inputMin;
      } else if (extrapolateLeft === 'extend') {
        // noop
      }
    }
    if (result > inputMax) {
      if (extrapolateRight === 'identity') {
        return result;
      } else if (extrapolateRight === 'clamp') {
        result = inputMax;
      } else if (extrapolateRight === 'extend') {
        // noop
      }
    }
    if (outputMin === outputMax) {
      return outputMin;
    }
    if (inputMin === inputMax) {
      if (input <= inputMin) {
        return outputMin;
      }
      return outputMax;
    }

    // Input Range
    if (inputMin === -(1 / 0)) {
      result = -result;
    } else if (inputMax === Infinity) {
      result = result - inputMin;
    } else {
      result = (result - inputMin) / (inputMax - inputMin);
    }

    // Easing
    result = easing(result);

    // Output Range
    if (outputMin === -(1 / 0)) {
      result = -result;
    } else if (outputMax === Infinity) {
      result = result + outputMin;
    } else {
      result = result * (outputMax - outputMin) + outputMin;
    }
    return result;
  }
  function colorToRgba(input) {
    var normalizedColor = (0, normalizeColor.default)(input);
    if (normalizedColor === null || typeof normalizedColor !== 'number') {
      return input;
    }
    normalizedColor = normalizedColor || 0;
    var r = (normalizedColor & 0xff000000) >>> 24;
    var g = (normalizedColor & 0x00ff0000) >>> 16;
    var b = (normalizedColor & 0x0000ff00) >>> 8;
    var a = (normalizedColor & 0x000000ff) / 255;
    return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
  }
  var stringShapeRegex = /[+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?/g;

  /**
   * Supports string shapes by extracting numbers so new values can be computed,
   * and recombines those values into new strings of the same shape.  Supports
   * things like:
   *
   *   rgba(123, 42, 99, 0.36) // colors
   *   -45deg                  // values with units
   */
  function createInterpolationFromStringOutputRange(config) {
    var outputRange = config.outputRange;
    (0, invariant.default)(outputRange.length >= 2, 'Bad output range');
    outputRange = outputRange.map(colorToRgba);
    checkPattern(outputRange);

    // ['rgba(0, 100, 200, 0)', 'rgba(50, 150, 250, 0.5)']
    // ->
    // [
    //   [0, 50],
    //   [100, 150],
    //   [200, 250],
    //   [0, 0.5],
    // ]
    /* $FlowFixMe[incompatible-use] (>=0.18.0): `outputRange[0].match()` can
     * return `null`. Need to guard against this possibility. */
    var outputRanges = outputRange[0].match(stringShapeRegex).map(() => []);
    outputRange.forEach(value => {
      /* $FlowFixMe[incompatible-use] (>=0.18.0): `value.match()` can return
       * `null`. Need to guard against this possibility. */
      value.match(stringShapeRegex).forEach((number, i) => {
        outputRanges[i].push(+number);
      });
    });
    var interpolations = outputRange[0].match(stringShapeRegex)
    /* $FlowFixMe[incompatible-use] (>=0.18.0): `outputRange[0].match()` can
     * return `null`. Need to guard against this possibility. */
    /* $FlowFixMe[incompatible-call] (>=0.18.0): `outputRange[0].match()` can
     * return `null`. Need to guard against this possibility. */.map((value, i) => {
      return createInterpolation((0, _objectSpread.default)((0, _objectSpread.default)({}, config), {}, {
        outputRange: outputRanges[i]
      }));
    });

    // rgba requires that the r,g,b are integers.... so we want to round them, but we *dont* want to
    // round the opacity (4th column).
    var shouldRound = isRgbOrRgba(outputRange[0]);
    return input => {
      var i = 0;
      // 'rgba(0, 100, 200, 0)'
      // ->
      // 'rgba(${interpolations[0](input)}, ${interpolations[1](input)}, ...'
      return outputRange[0].replace(stringShapeRegex, () => {
        var val = +interpolations[i++](input);
        if (shouldRound) {
          val = i < 4 ? Math.round(val) : Math.round(val * 1000) / 1000;
        }
        return String(val);
      });
    };
  }
  function isRgbOrRgba(range) {
    return typeof range === 'string' && range.startsWith('rgb');
  }
  function checkPattern(arr) {
    var pattern = arr[0].replace(stringShapeRegex, '');
    for (var i = 1; i < arr.length; ++i) {
      (0, invariant.default)(pattern === arr[i].replace(stringShapeRegex, ''), 'invalid pattern ' + arr[0] + ' and ' + arr[i]);
    }
  }
  function findRange(input, inputRange) {
    var i;
    for (i = 1; i < inputRange.length - 1; ++i) {
      if (inputRange[i] >= input) {
        break;
      }
    }
    return i - 1;
  }
  class AnimatedInterpolation extends AnimatedWithChildren.default {
    // Export for testing.

    constructor(parent, config) {
      super();
      this._parent = parent;
      this._config = config;
      this._interpolation = createInterpolation(config);
    }
    __makeNative(platformConfig) {
      this._parent.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    __getValue() {
      var parentValue = this._parent.__getValue();
      (0, invariant.default)(typeof parentValue === 'number', 'Cannot interpolate an input which is not a number.');
      return this._interpolation(parentValue);
    }
    interpolate(config) {
      return new AnimatedInterpolation(this, config);
    }
    __attach() {
      this._parent.__addChild(this);
    }
    __detach() {
      this._parent.__removeChild(this);
      super.__detach();
    }
    __transformDataType(range) {
      return range.map(NativeAnimatedHelper.default.transformDataType);
    }
    __getNativeConfig() {
      return {
        inputRange: this._config.inputRange,
        // Only the `outputRange` can contain strings so we don't need to transform `inputRange` here
        outputRange: this.__transformDataType(this._config.outputRange),
        extrapolateLeft: this._config.extrapolateLeft || this._config.extrapolate || 'extend',
        extrapolateRight: this._config.extrapolateRight || this._config.extrapolate || 'extend',
        type: 'interpolation'
      };
    }
  }
  AnimatedInterpolation.__createInterpolation = createInterpolation;
  var _default = AnimatedInterpolation;
},190,[20,191,193,25,52]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersCreateForOfIteratorHelperLoose = require(_dependencyMap[0]);
  var _createForOfIteratorHelperLoose = _interopDefault(_babelRuntimeHelpersCreateForOfIteratorHelperLoose);
  var _AnimatedNode = require(_dependencyMap[1]);
  var AnimatedNode = _interopDefault(_AnimatedNode);
  var _NativeAnimatedHelper = require(_dependencyMap[2]);
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  class AnimatedWithChildren extends AnimatedNode.default {
    constructor() {
      super();
      this._children = [];
    }
    __makeNative(platformConfig) {
      if (!this.__isNative) {
        this.__isNative = true;
        for (var _iterator = (0, _createForOfIteratorHelperLoose.default)(this._children), _step; !(_step = _iterator()).done;) {
          var child = _step.value;
          child.__makeNative(platformConfig);
          NativeAnimatedHelper.default.API.connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
        }
      }
      super.__makeNative(platformConfig);
    }
    __addChild(child) {
      if (this._children.length === 0) {
        this.__attach();
      }
      this._children.push(child);
      if (this.__isNative) {
        // Only accept "native" animated nodes as children
        child.__makeNative(this.__getPlatformConfig());
        NativeAnimatedHelper.default.API.connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
      }
    }
    __removeChild(child) {
      var index = this._children.indexOf(child);
      if (index === -1) {
        console.warn("Trying to remove a child that doesn't exist");
        return;
      }
      if (this.__isNative && child.__isNative) {
        NativeAnimatedHelper.default.API.disconnectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
      }
      this._children.splice(index, 1);
      if (this._children.length === 0) {
        this.__detach();
      }
    }
    __getChildren() {
      return this._children;
    }
    __callListeners(value) {
      super.__callListeners(value);
      if (!this.__isNative) {
        for (var _iterator2 = (0, _createForOfIteratorHelperLoose.default)(this._children), _step2; !(_step2 = _iterator2()).done;) {
          var child = _step2.value;
          // $FlowFixMe[method-unbinding] added when improving typing for this parameters
          if (child.__getValue) {
            child.__callListeners(child.__getValue());
          }
        }
      }
    }
  }
  var _default = AnimatedWithChildren;
},191,[157,192,193]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _NativeAnimatedHelper = require(_dependencyMap[0]);
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  var _fbjsLibInvariant = require(_dependencyMap[1]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  var NativeAnimatedAPI = NativeAnimatedHelper.default.API;
  var _uniqueId = 1;

  // Note(vjeux): this would be better as an interface but flow doesn't
  // support them yet
  class AnimatedNode {
    __attach() {}
    __detach() {
      if (this.__isNative && this.__nativeTag != null) {
        NativeAnimatedHelper.default.API.dropAnimatedNode(this.__nativeTag);
        this.__nativeTag = undefined;
      }
    }
    __getValue() {}
    __getAnimatedValue() {
      return this.__getValue();
    }
    __addChild(child) {}
    __removeChild(child) {}
    __getChildren() {
      return [];
    }

    /* Methods and props used by native Animated impl */

    constructor() {
      this._listeners = {};
    }
    __makeNative(platformConfig) {
      if (!this.__isNative) {
        throw new Error('This node cannot be made a "native" animated node');
      }
      this._platformConfig = platformConfig;
      if (this.hasListeners()) {
        this._startListeningToNativeValueUpdates();
      }
    }

    /**
     * Adds an asynchronous listener to the value so you can observe updates from
     * animations.  This is useful because there is no way to
     * synchronously read the value because it might be driven natively.
     *
     * See https://reactnative.dev/docs/animatedvalue#addlistener
     */
    addListener(callback) {
      var id = String(_uniqueId++);
      this._listeners[id] = callback;
      if (this.__isNative) {
        this._startListeningToNativeValueUpdates();
      }
      return id;
    }

    /**
     * Unregister a listener. The `id` param shall match the identifier
     * previously returned by `addListener()`.
     *
     * See https://reactnative.dev/docs/animatedvalue#removelistener
     */
    removeListener(id) {
      delete this._listeners[id];
      if (this.__isNative && !this.hasListeners()) {
        this._stopListeningForNativeValueUpdates();
      }
    }

    /**
     * Remove all registered listeners.
     *
     * See https://reactnative.dev/docs/animatedvalue#removealllisteners
     */
    removeAllListeners() {
      this._listeners = {};
      if (this.__isNative) {
        this._stopListeningForNativeValueUpdates();
      }
    }
    hasListeners() {
      return !!Object.keys(this._listeners).length;
    }
    _startListeningToNativeValueUpdates() {
      if (this.__nativeAnimatedValueListener && !this.__shouldUpdateListenersForNewNativeTag) {
        return;
      }
      if (this.__shouldUpdateListenersForNewNativeTag) {
        this.__shouldUpdateListenersForNewNativeTag = false;
        this._stopListeningForNativeValueUpdates();
      }
      NativeAnimatedAPI.startListeningToAnimatedNodeValue(this.__getNativeTag());
      this.__nativeAnimatedValueListener = NativeAnimatedHelper.default.nativeEventEmitter.addListener('onAnimatedValueUpdate', data => {
        if (data.tag !== this.__getNativeTag()) {
          return;
        }
        this.__onAnimatedValueUpdateReceived(data.value);
      });
    }
    __onAnimatedValueUpdateReceived(value) {
      this.__callListeners(value);
    }
    __callListeners(value) {
      for (var _key in this._listeners) {
        this._listeners[_key]({
          value
        });
      }
    }
    _stopListeningForNativeValueUpdates() {
      if (!this.__nativeAnimatedValueListener) {
        return;
      }
      this.__nativeAnimatedValueListener.remove();
      this.__nativeAnimatedValueListener = null;
      NativeAnimatedAPI.stopListeningToAnimatedNodeValue(this.__getNativeTag());
    }
    __getNativeTag() {
      var _this$__nativeTag;
      NativeAnimatedHelper.default.assertNativeAnimatedModule();
      (0, invariant.default)(this.__isNative, 'Attempt to get native tag from node not marked as "native"');
      var nativeTag = (_this$__nativeTag = this.__nativeTag) !== null && _this$__nativeTag !== undefined ? _this$__nativeTag : NativeAnimatedHelper.default.generateNewNodeTag();
      if (this.__nativeTag == null) {
        this.__nativeTag = nativeTag;
        var config = this.__getNativeConfig();
        if (this._platformConfig) {
          config.platformConfig = this._platformConfig;
        }
        NativeAnimatedHelper.default.API.createAnimatedNode(nativeTag, config);
        this.__shouldUpdateListenersForNewNativeTag = true;
      }
      return nativeTag;
    }
    __getNativeConfig() {
      throw new Error('This JS animated node type cannot be used as native animated node');
    }
    toJSON() {
      return this.__getValue();
    }
    __getPlatformConfig() {
      return this._platformConfig;
    }
    __setPlatformConfig(platformConfig) {
      this._platformConfig = platformConfig;
    }
  }
  var _default = AnimatedNode;
},192,[193,25]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  Object.defineProperty(exports, "API", {
    enumerable: true,
    get: function () {
      return API;
    }
  });
  Object.defineProperty(exports, "isSupportedColorStyleProp", {
    enumerable: true,
    get: function () {
      return isSupportedColorStyleProp;
    }
  });
  Object.defineProperty(exports, "isSupportedStyleProp", {
    enumerable: true,
    get: function () {
      return isSupportedStyleProp;
    }
  });
  Object.defineProperty(exports, "isSupportedTransformProp", {
    enumerable: true,
    get: function () {
      return isSupportedTransformProp;
    }
  });
  Object.defineProperty(exports, "isSupportedInterpolationParam", {
    enumerable: true,
    get: function () {
      return isSupportedInterpolationParam;
    }
  });
  Object.defineProperty(exports, "addWhitelistedStyleProp", {
    enumerable: true,
    get: function () {
      return addWhitelistedStyleProp;
    }
  });
  Object.defineProperty(exports, "addWhitelistedTransformProp", {
    enumerable: true,
    get: function () {
      return addWhitelistedTransformProp;
    }
  });
  Object.defineProperty(exports, "addWhitelistedInterpolationParam", {
    enumerable: true,
    get: function () {
      return addWhitelistedInterpolationParam;
    }
  });
  Object.defineProperty(exports, "validateStyles", {
    enumerable: true,
    get: function () {
      return validateStyles;
    }
  });
  Object.defineProperty(exports, "validateTransform", {
    enumerable: true,
    get: function () {
      return validateTransform;
    }
  });
  Object.defineProperty(exports, "validateInterpolation", {
    enumerable: true,
    get: function () {
      return validateInterpolation;
    }
  });
  Object.defineProperty(exports, "generateNewNodeTag", {
    enumerable: true,
    get: function () {
      return generateNewNodeTag;
    }
  });
  Object.defineProperty(exports, "generateNewAnimationId", {
    enumerable: true,
    get: function () {
      return generateNewAnimationId;
    }
  });
  Object.defineProperty(exports, "assertNativeAnimatedModule", {
    enumerable: true,
    get: function () {
      return assertNativeAnimatedModule;
    }
  });
  Object.defineProperty(exports, "shouldUseNativeDriver", {
    enumerable: true,
    get: function () {
      return shouldUseNativeDriver;
    }
  });
  Object.defineProperty(exports, "transformDataType", {
    enumerable: true,
    get: function () {
      return transformDataType;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _NativeAnimatedModule = require(_dependencyMap[1]);
  var NativeAnimatedNonTurboModule = _interopDefault(_NativeAnimatedModule);
  var _NativeAnimatedTurboModule = require(_dependencyMap[2]);
  var NativeAnimatedTurboModule = _interopDefault(_NativeAnimatedTurboModule);
  var _EventEmitterNativeEventEmitter = require(_dependencyMap[3]);
  var NativeEventEmitter = _interopDefault(_EventEmitterNativeEventEmitter);
  require(_dependencyMap[4]);
  var _ReactNativeReactNativeFeatureFlags = require(_dependencyMap[5]);
  var ReactNativeFeatureFlags = _interopDefault(_ReactNativeReactNativeFeatureFlags);
  var _fbjsLibInvariant = require(_dependencyMap[6]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _EventEmitterRCTDeviceEventEmitter = require(_dependencyMap[7]);
  var RCTDeviceEventEmitter = _interopDefault(_EventEmitterRCTDeviceEventEmitter);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  // TODO T69437152 @petetheheat - Delete this fork when Fabric ships to 100%.
  var NativeAnimatedModule = NativeAnimatedNonTurboModule.default;
  var __nativeAnimatedNodeTagCount = 1; /* used for animated nodes */
  var __nativeAnimationIdCount = 1; /* used for started animations */

  var nativeEventEmitter;
  var waitingForQueuedOperations = new Set();
  var queueOperations = false;
  var queue = [];
  // $FlowFixMe
  var singleOpQueue = [];
  var useSingleOpBatching = false;
  false;
  var flushQueueTimeout = null;
  var eventListenerGetValueCallbacks = {};
  var eventListenerAnimationFinishedCallbacks = {};
  var globalEventEmitterGetValueListener = null;
  var globalEventEmitterAnimationFinishedListener = null;
  var nativeOps = NativeAnimatedModule;

  /**
   * Wrappers around NativeAnimatedModule to provide flow and autocomplete support for
   * the native module methods, and automatic queue management on Android
   */
  var API = {
    getValue: function getValue(tag, saveValueCallback) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      {
        API.queueOperation(nativeOps.getValue, tag, saveValueCallback);
      }
    },
    setWaitingForIdentifier: function setWaitingForIdentifier(id) {
      waitingForQueuedOperations.add(id);
      queueOperations = true;
      if (ReactNativeFeatureFlags.default.animatedShouldDebounceQueueFlush() && flushQueueTimeout) {
        clearTimeout(flushQueueTimeout);
      }
    },
    unsetWaitingForIdentifier: function unsetWaitingForIdentifier(id) {
      waitingForQueuedOperations.delete(id);
      if (waitingForQueuedOperations.size === 0) {
        queueOperations = false;
        API.disableQueue();
      }
    },
    disableQueue: function disableQueue() {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      if (ReactNativeFeatureFlags.default.animatedShouldDebounceQueueFlush()) {
        var prevTimeout = flushQueueTimeout;
        clearImmediate(prevTimeout);
        flushQueueTimeout = setImmediate(API.flushQueue);
      } else {
        API.flushQueue();
      }
    },
    flushQueue: function flushQueue() {
      /*
      invariant(NativeAnimatedModule, 'Native animated module is not available');
      flushQueueTimeout = null;
       // Early returns before calling any APIs
      if (useSingleOpBatching && singleOpQueue.length === 0) {
        return;
      }
      if (!useSingleOpBatching && queue.length === 0) {
        return;
      }
       if (useSingleOpBatching) {
        // Set up event listener for callbacks if it's not set up
        if (
          !globalEventEmitterGetValueListener ||
          !globalEventEmitterAnimationFinishedListener
        ) {
          setupGlobalEventEmitterListeners();
        }
        // Single op batching doesn't use callback functions, instead we
        // use RCTDeviceEventEmitter. This reduces overhead of sending lots of
        // JSI functions across to native code; but also, TM infrastructure currently
        // does not support packing a function into native arrays.
        NativeAnimatedModule.queueAndExecuteBatchedOperations?.(singleOpQueue);
        singleOpQueue.length = 0;
      } else {
        Platform.OS === 'android' && NativeAnimatedModule.startOperationBatch?.();
        for (let q = 0, l = queue.length; q < l; q++) {
          queue[q]();
        }
        queue.length = 0;
        Platform.OS === 'android' &&
          NativeAnimatedModule.finishOperationBatch?.();
      }
      */
    },
    queueOperation: function queueOperation(fn) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      // If queueing is explicitly on, *or* the queue has not yet
      // been flushed, use the queue. This is to prevent operations
      // from being executed out of order.
      if (queueOperations || queue.length !== 0) {
        queue.push(() => fn(...args));
      } else {
        fn(...args);
      }
    },
    createAnimatedNode: function createAnimatedNode(tag, config) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.createAnimatedNode, tag, config);
    },
    updateAnimatedNodeConfig: function updateAnimatedNodeConfig(tag, config) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      //if (nativeOps.updateAnimatedNodeConfig) {
      //  API.queueOperation(nativeOps.updateAnimatedNodeConfig, tag, config);
      //}
    },
    startListeningToAnimatedNodeValue: function startListeningToAnimatedNodeValue(tag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.startListeningToAnimatedNodeValue, tag);
    },
    stopListeningToAnimatedNodeValue: function stopListeningToAnimatedNodeValue(tag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.stopListeningToAnimatedNodeValue, tag);
    },
    connectAnimatedNodes: function connectAnimatedNodes(parentTag, childTag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.connectAnimatedNodes, parentTag, childTag);
    },
    disconnectAnimatedNodes: function disconnectAnimatedNodes(parentTag, childTag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.disconnectAnimatedNodes, parentTag, childTag);
    },
    startAnimatingNode: function startAnimatingNode(animationId, nodeTag, config, endCallback) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      {
        API.queueOperation(nativeOps.startAnimatingNode, animationId, nodeTag, config, endCallback);
      }
    },
    stopAnimation: function stopAnimation(animationId) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.stopAnimation, animationId);
    },
    setAnimatedNodeValue: function setAnimatedNodeValue(nodeTag, value) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.setAnimatedNodeValue, nodeTag, value);
    },
    setAnimatedNodeOffset: function setAnimatedNodeOffset(nodeTag, offset) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.setAnimatedNodeOffset, nodeTag, offset);
    },
    flattenAnimatedNodeOffset: function flattenAnimatedNodeOffset(nodeTag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.flattenAnimatedNodeOffset, nodeTag);
    },
    extractAnimatedNodeOffset: function extractAnimatedNodeOffset(nodeTag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.extractAnimatedNodeOffset, nodeTag);
    },
    connectAnimatedNodeToView: function connectAnimatedNodeToView(nodeTag, viewTag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.connectAnimatedNodeToView, nodeTag, viewTag);
    },
    disconnectAnimatedNodeFromView: function disconnectAnimatedNodeFromView(nodeTag, viewTag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.disconnectAnimatedNodeFromView, nodeTag, viewTag);
    },
    restoreDefaultValues: function restoreDefaultValues(nodeTag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      // Backwards compat with older native runtimes, can be removed later.
      if (nativeOps.restoreDefaultValues != null) {
        API.queueOperation(nativeOps.restoreDefaultValues, nodeTag);
      }
    },
    dropAnimatedNode: function dropAnimatedNode(tag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.dropAnimatedNode, tag);
    },
    addAnimatedEventToView: function addAnimatedEventToView(viewTag, eventName, eventMapping) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.addAnimatedEventToView, viewTag, eventName, eventMapping);
    },
    removeAnimatedEventFromView(viewTag, eventName, animatedNodeTag) {
      (0, invariant.default)(nativeOps, 'Native animated module is not available');
      API.queueOperation(nativeOps.removeAnimatedEventFromView, viewTag, eventName, animatedNodeTag);
    }
  };
  /**
   * Styles allowed by the native animated implementation.
   *
   * In general native animated implementation should support any numeric or color property that
   * doesn't need to be updated through the shadow view hierarchy (all non-layout properties).
   */
  var SUPPORTED_COLOR_STYLES = {
    backgroundColor: true,
    borderBottomColor: true,
    borderColor: true,
    borderEndColor: true,
    borderLeftColor: true,
    borderRightColor: true,
    borderStartColor: true,
    borderTopColor: true,
    color: true,
    tintColor: true
  };
  var SUPPORTED_STYLES = (0, _objectSpread.default)((0, _objectSpread.default)({}, SUPPORTED_COLOR_STYLES), {}, {
    borderBottomEndRadius: true,
    borderBottomLeftRadius: true,
    borderBottomRightRadius: true,
    borderBottomStartRadius: true,
    borderRadius: true,
    borderTopEndRadius: true,
    borderTopLeftRadius: true,
    borderTopRightRadius: true,
    borderTopStartRadius: true,
    elevation: true,
    opacity: true,
    transform: true,
    zIndex: true,
    /* ios styles */
    shadowOpacity: true,
    shadowRadius: true,
    /* legacy android transform properties */
    scaleX: true,
    scaleY: true,
    translateX: true,
    translateY: true
  });
  var SUPPORTED_TRANSFORMS = {
    translateX: true,
    translateY: true,
    scale: true,
    scaleX: true,
    scaleY: true,
    rotate: true,
    rotateX: true,
    rotateY: true,
    rotateZ: true,
    perspective: true
  };
  var SUPPORTED_INTERPOLATION_PARAMS = {
    inputRange: true,
    outputRange: true,
    extrapolate: true,
    extrapolateRight: true,
    extrapolateLeft: true
  };
  function addWhitelistedStyleProp(prop) {
    SUPPORTED_STYLES[prop] = true;
  }
  function addWhitelistedTransformProp(prop) {
    SUPPORTED_TRANSFORMS[prop] = true;
  }
  function addWhitelistedInterpolationParam(param) {
    SUPPORTED_INTERPOLATION_PARAMS[param] = true;
  }
  function isSupportedColorStyleProp(prop) {
    return SUPPORTED_COLOR_STYLES.hasOwnProperty(prop);
  }
  function isSupportedStyleProp(prop) {
    return SUPPORTED_STYLES.hasOwnProperty(prop);
  }
  function isSupportedTransformProp(prop) {
    return SUPPORTED_TRANSFORMS.hasOwnProperty(prop);
  }
  function isSupportedInterpolationParam(param) {
    return SUPPORTED_INTERPOLATION_PARAMS.hasOwnProperty(param);
  }
  function validateTransform(configs) {
    configs.forEach(config => {
      if (!isSupportedTransformProp(config.property)) {
        throw new Error("Property '" + config.property + "' is not supported by native animated module");
      }
    });
  }
  function validateStyles(styles) {
    for (var _key2 in styles) {
      if (!isSupportedStyleProp(_key2)) {
        throw new Error("Style property '" + _key2 + "' is not supported by native animated module");
      }
    }
  }
  function validateInterpolation(config) {
    for (var _key3 in config) {
      if (!isSupportedInterpolationParam(_key3)) {
        throw new Error("Interpolation property '" + _key3 + "' is not supported by native animated module");
      }
    }
  }
  function generateNewNodeTag() {
    return __nativeAnimatedNodeTagCount++;
  }
  function generateNewAnimationId() {
    return __nativeAnimationIdCount++;
  }
  function assertNativeAnimatedModule() {
    (0, invariant.default)(NativeAnimatedModule, 'Native animated module is not available');
  }
  var _warnedMissingNativeAnimated = false;
  function shouldUseNativeDriver(config) {
    if (config.useNativeDriver == null) {
      console.warn("Animated: `useNativeDriver` was not specified. This is a required option and must be explicitly set to `true` or `false`");
    }
    if (config.useNativeDriver === true && !NativeAnimatedModule) {
      if (!_warnedMissingNativeAnimated) {
        console.warn("Animated: `useNativeDriver` is not supported because the native animated module is missing. Falling back to JS-based animation. To resolve this, add `RCTAnimation` module to this app, or remove `useNativeDriver`. Make sure to run `bundle exec pod install` first. Read more about autolinking: https://github.com/react-native-community/cli/blob/master/docs/autolinking.md");
        _warnedMissingNativeAnimated = true;
      }
      return false;
    }
    return config.useNativeDriver || false;
  }
  function transformDataType(value) {
    // Change the string type to number type so we can reuse the same logic in
    // iOS and Android platform
    if (typeof value !== 'string') {
      return value;
    }
    if (/deg$/.test(value)) {
      var degrees = parseFloat(value) || 0;
      var radians = degrees * Math.PI / 180.0;
      return radians;
    } else {
      return value;
    }
  }
  var _default = {
    API,
    isSupportedColorStyleProp,
    isSupportedStyleProp,
    isSupportedTransformProp,
    isSupportedInterpolationParam,
    addWhitelistedStyleProp,
    addWhitelistedTransformProp,
    addWhitelistedInterpolationParam,
    validateStyles,
    validateTransform,
    validateInterpolation,
    generateNewNodeTag,
    generateNewAnimationId,
    assertNativeAnimatedModule,
    shouldUseNativeDriver,
    transformDataType,
    // $FlowExpectedError[unsafe-getters-setters] - unsafe getter lint suppresion
    // $FlowExpectedError[missing-type-arg] - unsafe getter lint suppresion
    get nativeEventEmitter() {
      if (!nativeEventEmitter) {
        nativeEventEmitter = new NativeEventEmitter.default(
        // T88715063: NativeEventEmitter only used this parameter on iOS. Now it uses it on all platforms, so this code was modified automatically to preserve its behavior
        // If you want to use the native module on other platforms, please remove this condition and test its behavior
        null);
      }
      return nativeEventEmitter;
    }
  };
},193,[20,194,196,197,199,200,25,198]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _TurboModuleTurboModuleRegistry = require(_dependencyMap[0]);
  var TurboModuleRegistry = _interopNamespace(_TurboModuleTurboModuleRegistry);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  // The config has different keys depending on the type of the Node
  // TODO(T54896888): Make these types strict

  var _default = TurboModuleRegistry.get('NativeAnimatedModule');
},194,[195]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.get = get;
  exports.getEnforcing = getEnforcing;
  var _fbjsLibInvariant = require(_dependencyMap[0]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  function get(name) {
    return null;
  }
  function getEnforcing(name) {
    var module = get(name);
    (0, invariant.default)(module != null, "TurboModuleRegistry.getEnforcing(...): '" + name + "' could not be found. " + 'Verify that a module by this name is registered in the native binary.');
    return module;
  }
},195,[25]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _TurboModuleTurboModuleRegistry = require(_dependencyMap[0]);
  var TurboModuleRegistry = _interopNamespace(_TurboModuleTurboModuleRegistry);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  // The config has different keys depending on the type of the Node
  // TODO(T54896888): Make these types strict

  var _default = TurboModuleRegistry.get('NativeAnimatedTurboModule');
},196,[195]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return NativeEventEmitter;
    }
  });
  require(_dependencyMap[0]);
  var _RCTDeviceEventEmitter = require(_dependencyMap[1]);
  var RCTDeviceEventEmitter = _interopDefault(_RCTDeviceEventEmitter);
  var _fbjsLibInvariant = require(_dependencyMap[2]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  /**
   * `NativeEventEmitter` is intended for use by Native Modules to emit events to
   * JavaScript listeners. If a `NativeModule` is supplied to the constructor, it
   * will be notified (via `addListener` and `removeListeners`) when the listener
   * count changes to manage "native memory".
   *
   * Currently, all native events are fired via a global `RCTDeviceEventEmitter`.
   * This means event names must be globally unique, and it means that call sites
   * can theoretically listen to `RCTDeviceEventEmitter` (although discouraged).
   */
  class NativeEventEmitter {
    constructor(nativeModule) {}
    addListener(eventType, listener, context) {
      var _this$_nativeModule;
      (_this$_nativeModule = this._nativeModule) == null ? undefined : _this$_nativeModule.addListener(eventType);
      var subscription = RCTDeviceEventEmitter.default.addListener(eventType, listener, context);
      return {
        remove: () => {
          if (subscription != null) {
            var _this$_nativeModule2;
            (_this$_nativeModule2 = this._nativeModule) == null ? undefined : _this$_nativeModule2.removeListeners(1);
            // $FlowFixMe[incompatible-use]
            subscription.remove();
            subscription = null;
          }
        }
      };
    }

    /**
     * @deprecated Use `remove` on the EventSubscription from `addListener`.
     */
    removeListener(eventType, listener) {
      var _this$_nativeModule3;
      (_this$_nativeModule3 = this._nativeModule) == null ? undefined : _this$_nativeModule3.removeListeners(1);
      // NOTE: This will report a deprecation notice via `console.error`.
      // $FlowFixMe[prop-missing] - `removeListener` exists but is deprecated.
      RCTDeviceEventEmitter.default.removeListener(eventType, listener);
    }
    emit(eventType) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      // Generally, `RCTDeviceEventEmitter` is directly invoked. But this is
      // included for completeness.
      RCTDeviceEventEmitter.default.emit(eventType, ...args);
    }
    removeAllListeners(eventType) {
      var _this$_nativeModule4;
      (0, invariant.default)(eventType != null, '`NativeEventEmitter.removeAllListener()` requires a non-null argument.');
      (_this$_nativeModule4 = this._nativeModule) == null ? undefined : _this$_nativeModule4.removeListeners(this.listenerCount(eventType));
      RCTDeviceEventEmitter.default.removeAllListeners(eventType);
    }
    listenerCount(eventType) {
      return RCTDeviceEventEmitter.default.listenerCount(eventType);
    }
  }
},197,[96,198,25]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorEmitterEventEmitter = require(_dependencyMap[0]);
  var EventEmitter = _interopDefault(_vendorEmitterEventEmitter);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  // FIXME: use typed events

  /**
   * Global EventEmitter used by the native platform to emit events to JavaScript.
   * Events are identified by globally unique event names.
   *
   * NativeModules that emit events should instead subclass `NativeEventEmitter`.
   */
  var _default = new EventEmitter.default();
},198,[171]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _exportsPlatform = require(_dependencyMap[0]);
  var Platform = _interopDefault(_exportsPlatform);
  var _default = Platform.default;
},199,[96]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var ReactNativeFeatureFlags = {
    isLayoutAnimationEnabled: () => true,
    shouldEmitW3CPointerEvents: () => false,
    shouldPressibilityUseW3CPointerEventsForHover: () => false,
    animatedShouldDebounceQueueFlush: () => false,
    animatedShouldUseSingleOp: () => false
  };
  var _default = ReactNativeFeatureFlags;
},200,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _AnimatedNode = require(_dependencyMap[0]);
  var AnimatedNode = _interopDefault(_AnimatedNode);
  var _AnimatedTransform = require(_dependencyMap[1]);
  var AnimatedTransform = _interopDefault(_AnimatedTransform);
  var _AnimatedWithChildren = require(_dependencyMap[2]);
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  var _NativeAnimatedHelper = require(_dependencyMap[3]);
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  var _exportsStyleSheet = require(_dependencyMap[4]);
  var StyleSheet = _interopDefault(_exportsStyleSheet);
  var flattenStyle = StyleSheet.default.flatten;
  function createAnimatedStyle(inputStyle) {
    var style = flattenStyle(inputStyle);
    var animatedStyles = {};
    for (var key in style) {
      var value = style[key];
      if (key === 'transform' && Array.isArray(value)) {
        animatedStyles[key] = new AnimatedTransform.default(value);
      } else if (value instanceof AnimatedNode.default) {
        animatedStyles[key] = value;
      } else if (value && !Array.isArray(value) && typeof value === 'object') {
        animatedStyles[key] = createAnimatedStyle(value);
      }
    }
    return animatedStyles;
  }
  class AnimatedStyle extends AnimatedWithChildren.default {
    constructor(style) {
      super();
      this._inputStyle = style;
      this._style = createAnimatedStyle(style);
    }

    // Recursively get values for nested styles (like iOS's shadowOffset)
    _walkStyleAndGetValues(style) {
      var updatedStyle = {};
      for (var key in style) {
        var value = style[key];
        if (value instanceof AnimatedNode.default) {
          if (!value.__isNative) {
            // We cannot use value of natively driven nodes this way as the value we have access from
            // JS may not be up to date.
            updatedStyle[key] = value.__getValue();
          }
        } else if (value && !Array.isArray(value) && typeof value === 'object') {
          // Support animating nested values (for example: shadowOffset.height)
          updatedStyle[key] = this._walkStyleAndGetValues(value);
        } else {
          updatedStyle[key] = value;
        }
      }
      return updatedStyle;
    }
    __getValue() {
      return [this._inputStyle, this._walkStyleAndGetValues(this._style)];
    }

    // Recursively get animated values for nested styles (like iOS's shadowOffset)
    _walkStyleAndGetAnimatedValues(style) {
      var updatedStyle = {};
      for (var key in style) {
        var value = style[key];
        if (value instanceof AnimatedNode.default) {
          updatedStyle[key] = value.__getAnimatedValue();
        } else if (value && !Array.isArray(value) && typeof value === 'object') {
          // Support animating nested values (for example: shadowOffset.height)
          updatedStyle[key] = this._walkStyleAndGetAnimatedValues(value);
        }
      }
      return updatedStyle;
    }
    __getAnimatedValue() {
      return this._walkStyleAndGetAnimatedValues(this._style);
    }
    __attach() {
      for (var key in this._style) {
        var value = this._style[key];
        if (value instanceof AnimatedNode.default) {
          value.__addChild(this);
        }
      }
    }
    __detach() {
      for (var key in this._style) {
        var value = this._style[key];
        if (value instanceof AnimatedNode.default) {
          value.__removeChild(this);
        }
      }
      super.__detach();
    }
    __makeNative() {
      for (var key in this._style) {
        var value = this._style[key];
        if (value instanceof AnimatedNode.default) {
          value.__makeNative();
        }
      }
      super.__makeNative();
    }
    __getNativeConfig() {
      var styleConfig = {};
      for (var styleKey in this._style) {
        if (this._style[styleKey] instanceof AnimatedNode.default) {
          var style = this._style[styleKey];
          style.__makeNative();
          styleConfig[styleKey] = style.__getNativeTag();
        }
      }
      NativeAnimatedHelper.default.validateStyles(styleConfig);
      return {
        type: 'style',
        style: styleConfig
      };
    }
  }
  var _default = AnimatedStyle;
},201,[192,202,191,193,43]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _AnimatedNode = require(_dependencyMap[0]);
  var AnimatedNode = _interopDefault(_AnimatedNode);
  var _AnimatedWithChildren = require(_dependencyMap[1]);
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  var _NativeAnimatedHelper = require(_dependencyMap[2]);
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  class AnimatedTransform extends AnimatedWithChildren.default {
    constructor(transforms) {
      super();
      this._transforms = transforms;
    }
    __makeNative() {
      this._transforms.forEach(transform => {
        for (var key in transform) {
          var value = transform[key];
          if (value instanceof AnimatedNode.default) {
            value.__makeNative();
          }
        }
      });
      super.__makeNative();
    }
    __getValue() {
      return this._transforms.map(transform => {
        var result = {};
        for (var key in transform) {
          var value = transform[key];
          if (value instanceof AnimatedNode.default) {
            result[key] = value.__getValue();
          } else {
            result[key] = value;
          }
        }
        return result;
      });
    }
    __getAnimatedValue() {
      return this._transforms.map(transform => {
        var result = {};
        for (var key in transform) {
          var value = transform[key];
          if (value instanceof AnimatedNode.default) {
            result[key] = value.__getAnimatedValue();
          } else {
            // All transform components needed to recompose matrix
            result[key] = value;
          }
        }
        return result;
      });
    }
    __attach() {
      this._transforms.forEach(transform => {
        for (var key in transform) {
          var value = transform[key];
          if (value instanceof AnimatedNode.default) {
            value.__addChild(this);
          }
        }
      });
    }
    __detach() {
      this._transforms.forEach(transform => {
        for (var key in transform) {
          var value = transform[key];
          if (value instanceof AnimatedNode.default) {
            value.__removeChild(this);
          }
        }
      });
      super.__detach();
    }
    __getNativeConfig() {
      var transConfigs = [];
      this._transforms.forEach(transform => {
        for (var key in transform) {
          var value = transform[key];
          if (value instanceof AnimatedNode.default) {
            transConfigs.push({
              type: 'animated',
              property: key,
              nodeTag: value.__getNativeTag()
            });
          } else {
            transConfigs.push({
              type: 'static',
              property: key,
              value: NativeAnimatedHelper.default.transformDataType(value)
            });
          }
        }
      });
      NativeAnimatedHelper.default.validateTransform(transConfigs);
      return {
        type: 'transform',
        transforms: transConfigs
      };
    }
  }
  var _default = AnimatedTransform;
},202,[192,191,193]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useRefEffect;
    }
  });
  var _react = require(_dependencyMap[0]);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * Constructs a callback ref that provides similar semantics as `useEffect`. The
   * supplied `effect` callback will be called with non-null component instances.
   * The `effect` callback can also optionally return a cleanup function.
   *
   * When a component is updated or unmounted, the cleanup function is called. The
   * `effect` callback will then be called again, if applicable.
   *
   * When a new `effect` callback is supplied, the previously returned cleanup
   * function will be called before the new `effect` callback is called with the
   * same instance.
   *
   * WARNING: The `effect` callback should be stable (e.g. using `useCallback`).
   */
  function useRefEffect(effect) {
    var cleanupRef = (0, _react.useRef)(undefined);
    return (0, _react.useCallback)(instance => {
      if (cleanupRef.current) {
        cleanupRef.current();
        cleanupRef.current = undefined;
      }
      if (instance != null) {
        cleanupRef.current = effect(instance);
      }
    }, [effect]);
  }
},203,[35]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useMergeRefs;
    }
  });
  var _react = require(_dependencyMap[0]);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * Constructs a new ref that forwards new values to each of the given refs. The
   * given refs will always be invoked in the order that they are supplied.
   *
   * WARNING: A known problem of merging refs using this approach is that if any
   * of the given refs change, the returned callback ref will also be changed. If
   * the returned callback ref is supplied as a `ref` to a React element, this may
   * lead to problems with the given refs being invoked more times than desired.
   */
  function useMergeRefs() {
    for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
      refs[_key] = arguments[_key];
    }
    return (0, _react.useCallback)(current => {
      for (var _i = 0, _refs = refs; _i < _refs.length; _i++) {
        var ref = _refs[_i];
        if (ref != null) {
          if (typeof ref === 'function') {
            ref(current);
          } else {
            ref.current = current;
          }
        }
      }
    }, [...refs] // eslint-disable-line react-hooks/exhaustive-deps
    );
  }
},204,[35]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  require(_dependencyMap[0]);
  var _exportsImage = require(_dependencyMap[1]);
  var Image = _interopDefault(_exportsImage);
  var _createAnimatedComponent = require(_dependencyMap[2]);
  var createAnimatedComponent = _interopDefault(_createAnimatedComponent);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  var _default = (0, createAnimatedComponent.default)(Image.default);
},205,[35,206,185]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _babelRuntimeHelpersExtends = require(_dependencyMap[1]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[2]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[3]);
  var React = _interopNamespace(_react);
  var _createElement = require(_dependencyMap[4]);
  var createElement = _interopDefault(_createElement);
  var _modulesAssetRegistry = require(_dependencyMap[5]);
  var _StyleSheetPreprocess = require(_dependencyMap[6]);
  var _modulesImageLoader = require(_dependencyMap[7]);
  var ImageLoader = _interopDefault(_modulesImageLoader);
  var _PixelRatio = require(_dependencyMap[8]);
  var PixelRatio = _interopDefault(_PixelRatio);
  var _StyleSheet = require(_dependencyMap[9]);
  var StyleSheet = _interopDefault(_StyleSheet);
  var _TextTextAncestorContext = require(_dependencyMap[10]);
  var TextAncestorContext = _interopDefault(_TextTextAncestorContext);
  var _View = require(_dependencyMap[11]);
  var View = _interopDefault(_View);
  var _modulesWarnOnce = require(_dependencyMap[12]);
  var _excluded = ["aria-label", "accessibilityLabel", "blurRadius", "defaultSource", "draggable", "onError", "onLayout", "onLoad", "onLoadEnd", "onLoadStart", "pointerEvents", "source", "style"];
  var ERRORED = 'ERRORED';
  var LOADED = 'LOADED';
  var LOADING = 'LOADING';
  var IDLE = 'IDLE';
  var _filterId = 0;
  var svgDataUriPattern = /^(data:image\/svg\+xml;utf8,)(.*)/;
  function createTintColorSVG(tintColor, id) {
    return tintColor && id != null ? /*#__PURE__*/React.createElement("svg", {
      style: {
        position: 'absolute',
        height: 0,
        visibility: 'hidden',
        width: 0
      }
    }, /*#__PURE__*/React.createElement("defs", null, /*#__PURE__*/React.createElement("filter", {
      id: "tint-" + id,
      suppressHydrationWarning: true
    }, /*#__PURE__*/React.createElement("feFlood", {
      floodColor: "" + tintColor,
      key: tintColor
    }), /*#__PURE__*/React.createElement("feComposite", {
      in2: "SourceAlpha",
      operator: "in"
    })))) : null;
  }
  function extractNonStandardStyleProps(style, blurRadius, filterId, tintColorProp) {
    var flatStyle = StyleSheet.default.flatten(style);
    var filter = flatStyle.filter,
      resizeMode = flatStyle.resizeMode,
      shadowOffset = flatStyle.shadowOffset,
      tintColor = flatStyle.tintColor;
    if (flatStyle.resizeMode) {
      (0, _modulesWarnOnce.warnOnce)('Image.style.resizeMode', 'Image: style.resizeMode is deprecated. Please use props.resizeMode.');
    }
    if (flatStyle.tintColor) {
      (0, _modulesWarnOnce.warnOnce)('Image.style.tintColor', 'Image: style.tintColor is deprecated. Please use props.tintColor.');
    }

    // Add CSS filters
    // React Native exposes these features as props and proprietary styles
    var filters = [];
    var _filter = null;
    if (filter) {
      filters.push(filter);
    }
    if (blurRadius) {
      filters.push("blur(" + blurRadius + "px)");
    }
    if (shadowOffset) {
      var shadowString = (0, _StyleSheetPreprocess.createBoxShadowValue)(flatStyle);
      if (shadowString) {
        filters.push("drop-shadow(" + shadowString + ")");
      }
    }
    if ((tintColorProp || tintColor) && filterId != null) {
      filters.push("url(#tint-" + filterId + ")");
    }
    if (filters.length > 0) {
      _filter = filters.join(' ');
    }
    return [resizeMode, _filter, tintColor];
  }
  function resolveAssetDimensions(source) {
    if (typeof source === 'number') {
      var _getAssetByID = (0, _modulesAssetRegistry.getAssetByID)(source),
        _height = _getAssetByID.height,
        _width = _getAssetByID.width;
      return {
        height: _height,
        width: _width
      };
    } else if (source != null && !Array.isArray(source) && typeof source === 'object') {
      var _height2 = source.height,
        _width2 = source.width;
      return {
        height: _height2,
        width: _width2
      };
    }
  }
  function resolveAssetUri(source) {
    var uri = null;
    if (typeof source === 'number') {
      // get the URI from the packager
      var asset = (0, _modulesAssetRegistry.getAssetByID)(source);
      if (asset == null) {
        throw new Error("Image: asset with ID \"" + source + "\" could not be found. Please check the image source or packager.");
      }
      var scale = asset.scales[0];
      if (asset.scales.length > 1) {
        var preferredScale = PixelRatio.default.get();
        // Get the scale which is closest to the preferred scale
        scale = asset.scales.reduce((prev, curr) => Math.abs(curr - preferredScale) < Math.abs(prev - preferredScale) ? curr : prev);
      }
      var scaleSuffix = scale !== 1 ? "@" + scale + "x" : '';
      uri = asset ? asset.httpServerLocation + "/" + asset.name + scaleSuffix + "." + asset.type : '';
    } else if (typeof source === 'string') {
      uri = source;
    } else if (source && typeof source.uri === 'string') {
      uri = source.uri;
    }
    if (uri) {
      var match = uri.match(svgDataUriPattern);
      // inline SVG markup may contain characters (e.g., #, ") that need to be escaped
      if (match) {
        var prefix = match[1],
          svg = match[2];
        var encodedSvg = encodeURIComponent(svg);
        return "" + prefix + encodedSvg;
      }
    }
    return uri;
  }
  var Image = /*#__PURE__*/React.forwardRef((props, ref) => {
    var _ariaLabel = props['aria-label'],
      accessibilityLabel = props.accessibilityLabel,
      blurRadius = props.blurRadius,
      defaultSource = props.defaultSource,
      draggable = props.draggable,
      onError = props.onError,
      onLayout = props.onLayout,
      onLoad = props.onLoad,
      onLoadEnd = props.onLoadEnd,
      onLoadStart = props.onLoadStart,
      pointerEvents = props.pointerEvents,
      source = props.source,
      style = props.style,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    var ariaLabel = _ariaLabel || accessibilityLabel;
    var _React$useState = React.useState(() => {
        var uri = resolveAssetUri(source);
        if (uri != null) {
          var isLoaded = ImageLoader.default.has(uri);
          if (isLoaded) {
            return LOADED;
          }
        }
        return IDLE;
      }),
      state = _React$useState[0],
      updateState = _React$useState[1];
    var _React$useState2 = React.useState({}),
      layout = _React$useState2[0],
      updateLayout = _React$useState2[1];
    var hasTextAncestor = React.useContext(TextAncestorContext.default);
    var hiddenImageRef = React.useRef(null);
    var filterRef = React.useRef(_filterId++);
    var requestRef = React.useRef(null);
    var shouldDisplaySource = state === LOADED || state === LOADING && defaultSource == null;
    var _extractNonStandardSt = extractNonStandardStyleProps(style, blurRadius, filterRef.current, props.tintColor),
      _resizeMode = _extractNonStandardSt[0],
      filter = _extractNonStandardSt[1],
      _tintColor = _extractNonStandardSt[2];
    var resizeMode = props.resizeMode || _resizeMode || 'cover';
    var tintColor = props.tintColor || _tintColor;
    var selectedSource = shouldDisplaySource ? source : defaultSource;
    var displayImageUri = resolveAssetUri(selectedSource);
    var imageSizeStyle = resolveAssetDimensions(selectedSource);
    var backgroundImage = displayImageUri ? "url(\"" + displayImageUri + "\")" : null;
    var backgroundSize = getBackgroundSize();

    // Accessibility image allows users to trigger the browser's image context menu
    var hiddenImage = displayImageUri ? (0, createElement.default)('img', {
      alt: ariaLabel || '',
      style: styles.accessibilityImage$raw,
      draggable: draggable || false,
      ref: hiddenImageRef,
      src: displayImageUri
    }) : null;
    function getBackgroundSize() {
      if (hiddenImageRef.current != null && (resizeMode === 'center' || resizeMode === 'repeat')) {
        var _hiddenImageRef$curre = hiddenImageRef.current,
          naturalHeight = _hiddenImageRef$curre.naturalHeight,
          naturalWidth = _hiddenImageRef$curre.naturalWidth;
        var _height3 = layout.height,
          _width3 = layout.width;
        if (naturalHeight && naturalWidth && _height3 && _width3) {
          var scaleFactor = Math.min(1, _width3 / naturalWidth, _height3 / naturalHeight);
          var x = Math.ceil(scaleFactor * naturalWidth);
          var y = Math.ceil(scaleFactor * naturalHeight);
          return x + "px " + y + "px";
        }
      }
    }
    function handleLayout(e) {
      if (resizeMode === 'center' || resizeMode === 'repeat' || onLayout) {
        var _layout = e.nativeEvent.layout;
        onLayout && onLayout(e);
        updateLayout(_layout);
      }
    }

    // Image loading
    var uri = resolveAssetUri(source);
    React.useEffect(() => {
      abortPendingRequest();
      if (uri != null) {
        updateState(LOADING);
        if (onLoadStart) {
          onLoadStart();
        }
        requestRef.current = ImageLoader.default.load(uri, function load(e) {
          updateState(LOADED);
          if (onLoad) {
            onLoad(e);
          }
          if (onLoadEnd) {
            onLoadEnd();
          }
        }, function error() {
          updateState(ERRORED);
          if (onError) {
            onError({
              nativeEvent: {
                error: "Failed to load resource " + uri
              }
            });
          }
          if (onLoadEnd) {
            onLoadEnd();
          }
        });
      }
      function abortPendingRequest() {
        if (requestRef.current != null) {
          ImageLoader.default.abort(requestRef.current);
          requestRef.current = null;
        }
      }
      return abortPendingRequest;
    }, [uri, requestRef, updateState, onError, onLoad, onLoadEnd, onLoadStart]);
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, rest, {
      "aria-label": ariaLabel,
      onLayout: handleLayout,
      pointerEvents: pointerEvents,
      ref: ref,
      style: [styles.root, hasTextAncestor && styles.inline, imageSizeStyle, style, styles.undo,
      // TEMP: avoid deprecated shadow props regression
      // until Image refactored to use createElement.
      {
        boxShadow: null
      }]
    }), /*#__PURE__*/React.createElement(View.default, {
      style: [styles.image, resizeModeStyles[resizeMode], {
        backgroundImage,
        filter
      }, backgroundSize != null && {
        backgroundSize
      }],
      suppressHydrationWarning: true
    }), hiddenImage, createTintColorSVG(tintColor, filterRef.current));
  });
  Image.displayName = 'Image';

  // $FlowIgnore: This is the correct type, but casting makes it unhappy since the variables aren't defined yet
  var ImageWithStatics = Image;
  ImageWithStatics.getSize = function (uri, success, failure) {
    ImageLoader.default.getSize(uri, success, failure);
  };
  ImageWithStatics.prefetch = function (uri) {
    return ImageLoader.default.prefetch(uri);
  };
  ImageWithStatics.queryCache = function (uris) {
    return ImageLoader.default.queryCache(uris);
  };
  var styles = StyleSheet.default.create({
    root: {
      flexBasis: 'auto',
      overflow: 'hidden',
      zIndex: 0
    },
    inline: {
      display: 'inline-flex'
    },
    undo: {
      // These styles are converted to CSS filters applied to the
      // element displaying the background image.
      blurRadius: null,
      shadowColor: null,
      shadowOpacity: null,
      shadowOffset: null,
      shadowRadius: null,
      tintColor: null,
      // These styles are not supported
      overlayColor: null,
      resizeMode: null
    },
    image: (0, _objectSpread.default)((0, _objectSpread.default)({}, StyleSheet.default.absoluteFillObject), {}, {
      backgroundColor: 'transparent',
      backgroundPosition: 'center',
      backgroundRepeat: 'no-repeat',
      backgroundSize: 'cover',
      height: '100%',
      width: '100%',
      zIndex: -1
    }),
    accessibilityImage$raw: (0, _objectSpread.default)((0, _objectSpread.default)({}, StyleSheet.default.absoluteFillObject), {}, {
      height: '100%',
      opacity: 0,
      width: '100%',
      zIndex: -1
    })
  });
  var resizeModeStyles = StyleSheet.default.create({
    center: {
      backgroundSize: 'auto'
    },
    contain: {
      backgroundSize: 'contain'
    },
    cover: {
      backgroundSize: 'cover'
    },
    none: {
      backgroundPosition: '0',
      backgroundSize: 'auto'
    },
    repeat: {
      backgroundPosition: '0',
      backgroundRepeat: 'repeat',
      backgroundSize: 'auto'
    },
    stretch: {
      backgroundSize: '100% 100%'
    }
  });
  var _default = ImageWithStatics;
},206,[20,28,44,35,116,207,87,208,209,43,154,138,88]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  const assets = [];
  module.exports = {
    registerAsset: s => assets.push(s),
    getAssetByID: s => assets[s - 1]
  };
},207,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  Object.defineProperty(exports, "ImageUriCache", {
    enumerable: true,
    get: function () {
      return ImageUriCache;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var dataUriPattern = /^data:/;
  class ImageUriCache {
    static has(uri) {
      var entries = ImageUriCache._entries;
      var isDataUri = dataUriPattern.test(uri);
      return isDataUri || Boolean(entries[uri]);
    }
    static add(uri) {
      var entries = ImageUriCache._entries;
      var lastUsedTimestamp = Date.now();
      if (entries[uri]) {
        entries[uri].lastUsedTimestamp = lastUsedTimestamp;
        entries[uri].refCount += 1;
      } else {
        entries[uri] = {
          lastUsedTimestamp,
          refCount: 1
        };
      }
    }
    static remove(uri) {
      var entries = ImageUriCache._entries;
      if (entries[uri]) {
        entries[uri].refCount -= 1;
      }
      // Free up entries when the cache is "full"
      ImageUriCache._cleanUpIfNeeded();
    }
    static _cleanUpIfNeeded() {
      var entries = ImageUriCache._entries;
      var imageUris = Object.keys(entries);
      if (imageUris.length + 1 > ImageUriCache._maximumEntries) {
        var leastRecentlyUsedKey;
        var leastRecentlyUsedEntry;
        imageUris.forEach(uri => {
          var entry = entries[uri];
          if ((!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0) {
            leastRecentlyUsedKey = uri;
            leastRecentlyUsedEntry = entry;
          }
        });
        if (leastRecentlyUsedKey) {
          delete entries[leastRecentlyUsedKey];
        }
      }
    }
  }
  ImageUriCache._maximumEntries = 256;
  ImageUriCache._entries = {};
  var id = 0;
  var requests = {};
  var ImageLoader = {
    abort(requestId) {
      var image = requests["" + requestId];
      if (image) {
        image.onerror = null;
        image.onload = null;
        image = null;
        delete requests["" + requestId];
      }
    },
    getSize(uri, success, failure) {
      var complete = false;
      var interval = setInterval(callback, 16);
      var requestId = ImageLoader.load(uri, callback, errorCallback);
      function callback() {
        var image = requests["" + requestId];
        if (image) {
          var naturalHeight = image.naturalHeight,
            naturalWidth = image.naturalWidth;
          if (naturalHeight && naturalWidth) {
            success(naturalWidth, naturalHeight);
            complete = true;
          }
        }
        if (complete) {
          ImageLoader.abort(requestId);
          clearInterval(interval);
        }
      }
      function errorCallback() {
        if (typeof failure === 'function') {
          failure();
        }
        ImageLoader.abort(requestId);
        clearInterval(interval);
      }
    },
    has(uri) {
      return ImageUriCache.has(uri);
    },
    load(uri, onLoad, onError) {
      id += 1;
      var image = new window.Image();
      image.onerror = onError;
      image.onload = e => {
        // avoid blocking the main thread
        var onDecode = () => onLoad({
          nativeEvent: e
        });
        if (typeof image.decode === 'function') {
          // Safari currently throws exceptions when decoding svgs.
          // We want to catch that error and allow the load handler
          // to be forwarded to the onLoad handler in this case
          image.decode().then(onDecode, onDecode);
        } else {
          setTimeout(onDecode, 0);
        }
      };
      image.src = uri;
      requests["" + id] = image;
      return id;
    },
    prefetch(uri) {
      return new Promise((resolve, reject) => {
        ImageLoader.load(uri, () => {
          // Add the uri to the cache so it can be immediately displayed when used
          // but also immediately remove it to correctly reflect that it has no active references
          ImageUriCache.add(uri);
          ImageUriCache.remove(uri);
          resolve();
        }, reject);
      });
    },
    queryCache(uris) {
      var result = {};
      uris.forEach(u => {
        if (ImageUriCache.has(u)) {
          result[u] = 'disk/memory';
        }
      });
      return Promise.resolve(result);
    }
  };
  var _default = ImageLoader;
},208,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return PixelRatio;
    }
  });
  var _Dimensions = require(_dependencyMap[0]);
  var Dimensions = _interopDefault(_Dimensions);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * PixelRatio gives access to the device pixel density.
   */
  class PixelRatio {
    /**
     * Returns the device pixel density.
     */
    static get() {
      return Dimensions.default.get('window').scale;
    }

    /**
     * No equivalent for Web
     */
    static getFontScale() {
      return Dimensions.default.get('window').fontScale || PixelRatio.get();
    }

    /**
     * Converts a layout size (dp) to pixel size (px).
     * Guaranteed to return an integer number.
     */
    static getPixelSizeForLayoutSize(layoutSize) {
      return Math.round(layoutSize * PixelRatio.get());
    }

    /**
     * Rounds a layout size (dp) to the nearest layout size that corresponds to
     * an integer number of pixels. For example, on a device with a PixelRatio
     * of 3, `PixelRatio.roundToNearestPixel(8.4) = 8.33`, which corresponds to
     * exactly (8.33 * 3) = 25 pixels.
     */
    static roundToNearestPixel(layoutSize) {
      var ratio = PixelRatio.get();
      return Math.round(layoutSize * ratio) / ratio;
    }
  }
},209,[162]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _react = require(_dependencyMap[1]);
  var React = _interopNamespace(_react);
  var _exportsScrollView = require(_dependencyMap[2]);
  var ScrollView = _interopDefault(_exportsScrollView);
  var _createAnimatedComponent = require(_dependencyMap[3]);
  var createAnimatedComponent = _interopDefault(_createAnimatedComponent);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * @see https://github.com/facebook/react-native/commit/b8c8562
   */
  var ScrollViewWithEventThrottle = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(ScrollView.default, (0, _extends.default)({
    scrollEventThrottle: 0.0001
  }, props, {
    ref: ref
  })));
  var _default = (0, createAnimatedComponent.default)(ScrollViewWithEventThrottle);
},210,[28,35,161,185]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _react = require(_dependencyMap[1]);
  var React = _interopNamespace(_react);
  var _exportsSectionList = require(_dependencyMap[2]);
  var SectionList = _interopDefault(_exportsSectionList);
  var _createAnimatedComponent = require(_dependencyMap[3]);
  var createAnimatedComponent = _interopDefault(_createAnimatedComponent);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * @see https://github.com/facebook/react-native/commit/b8c8562
   */
  var SectionListWithEventThrottle = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(SectionList.default, (0, _extends.default)({
    scrollEventThrottle: 0.0001
  }, props, {
    ref: ref
  })));
  var _default = (0, createAnimatedComponent.default)(SectionListWithEventThrottle);
},211,[28,35,212,185]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativeSectionList = require(_dependencyMap[0]);
  var SectionList = _interopDefault(_vendorReactNativeSectionList);
  var _default = SectionList.default;
},212,[213]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return SectionList;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  require(_dependencyMap[2]);
  var _react = require(_dependencyMap[3]);
  var React = _interopNamespace(_react);
  var _VirtualizedSectionList = require(_dependencyMap[4]);
  var VirtualizedSectionList = _interopDefault(_VirtualizedSectionList);
  var _excluded = ["stickySectionHeadersEnabled"];
  /**
   * A performant interface for rendering sectioned lists, supporting the most handy features:
   *
   *  - Fully cross-platform.
   *  - Configurable viewability callbacks.
   *  - List header support.
   *  - List footer support.
   *  - Item separator support.
   *  - Section header support.
   *  - Section separator support.
   *  - Heterogeneous data and item rendering support.
   *  - Pull to Refresh.
   *  - Scroll loading.
   *
   * If you don't need section support and want a simpler interface, use
   * [`<FlatList>`](https://reactnative.dev/docs/flatlist).
   *
   * Simple Examples:
   *
   *     <SectionList
   *       renderItem={({item}) => <ListItem title={item} />}
   *       renderSectionHeader={({section}) => <Header title={section.title} />}
   *       sections={[ // homogeneous rendering between sections
   *         {data: [...], title: ...},
   *         {data: [...], title: ...},
   *         {data: [...], title: ...},
   *       ]}
   *     />
   *
   *     <SectionList
   *       sections={[ // heterogeneous rendering between sections
   *         {data: [...], renderItem: ...},
   *         {data: [...], renderItem: ...},
   *         {data: [...], renderItem: ...},
   *       ]}
   *     />
   *
   * This is a convenience wrapper around [`<VirtualizedList>`](docs/virtualizedlist),
   * and thus inherits its props (as well as those of `ScrollView`) that aren't explicitly listed
   * here, along with the following caveats:
   *
   * - Internal state is not preserved when content scrolls out of the render window. Make sure all
   *   your data is captured in the item data or external stores like Flux, Redux, or Relay.
   * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-
   *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop
   *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on
   *   changes. This includes the `data` prop and parent component state.
   * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously
   *   offscreen. This means it's possible to scroll faster than the fill rate and momentarily see
   *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,
   *   and we are working on improving it behind the scenes.
   * - By default, the list looks for a `key` prop on each item and uses that for the React key.
   *   Alternatively, you can provide a custom `keyExtractor` prop.
   *
   */
  class SectionList extends React.PureComponent {
    constructor() {
      super(...arguments);
      this._captureRef = ref => {
        this._wrapperListRef = ref;
      };
    }
    /**
     * Scrolls to the item at the specified `sectionIndex` and `itemIndex` (within the section)
     * positioned in the viewable area such that `viewPosition` 0 places it at the top (and may be
     * covered by a sticky header), 1 at the bottom, and 0.5 centered in the middle. `viewOffset` is a
     * fixed number of pixels to offset the final target position, e.g. to compensate for sticky
     * headers.
     *
     * Note: cannot scroll to locations outside the render window without specifying the
     * `getItemLayout` prop.
     */
    scrollToLocation(params) {
      if (this._wrapperListRef != null) {
        this._wrapperListRef.scrollToLocation(params);
      }
    }

    /**
     * Tells the list an interaction has occurred, which should trigger viewability calculations, e.g.
     * if `waitForInteractions` is true and the user has not scrolled. This is typically called by
     * taps on items or by navigation actions.
     */
    recordInteraction() {
      var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
      listRef && listRef.recordInteraction();
    }

    /**
     * Displays the scroll indicators momentarily.
     *
     * @platform ios
     */
    flashScrollIndicators() {
      var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
      listRef && listRef.flashScrollIndicators();
    }

    /**
     * Provides a handle to the underlying scroll responder.
     */
    getScrollResponder() {
      var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
      if (listRef) {
        return listRef.getScrollResponder();
      }
    }
    getScrollableNode() {
      var listRef = this._wrapperListRef && this._wrapperListRef.getListRef();
      if (listRef) {
        return listRef.getScrollableNode();
      }
    }
    render() {
      var _this$props = this.props,
        _stickySectionHeadersEnabled = _this$props.stickySectionHeadersEnabled,
        restProps = (0, _objectWithoutPropertiesLoose.default)(_this$props, _excluded);
      var stickySectionHeadersEnabled = _stickySectionHeadersEnabled !== null && _stickySectionHeadersEnabled !== undefined ? _stickySectionHeadersEnabled : false;
      return /*#__PURE__*/React.createElement(VirtualizedSectionList.default, (0, _extends.default)({}, restProps, {
        stickySectionHeadersEnabled: stickySectionHeadersEnabled,
        ref: this._captureRef,
        getItemCount: items => items.length,
        getItem: (items, index) => items[index]
      }));
    }
  }
},213,[28,44,96,35,214]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersCreateForOfIteratorHelperLoose = require(_dependencyMap[1]);
  var _createForOfIteratorHelperLoose = _interopDefault(_babelRuntimeHelpersCreateForOfIteratorHelperLoose);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[2]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[3]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _exportsView = require(_dependencyMap[4]);
  var View = _interopDefault(_exportsView);
  var _VirtualizedList = require(_dependencyMap[5]);
  var VirtualizedList = _interopDefault(_VirtualizedList);
  var _VirtualizeUtils = require(_dependencyMap[6]);
  var _fbjsLibInvariant = require(_dependencyMap[7]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _react = require(_dependencyMap[8]);
  var React = _interopNamespace(_react);
  var _excluded = ["ItemSeparatorComponent", "SectionSeparatorComponent", "renderItem", "renderSectionFooter", "renderSectionHeader", "sections", "stickySectionHeadersEnabled"];
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * Right now this just flattens everything into one list and uses VirtualizedList under the
   * hood. The only operation that might not scale well is concatting the data arrays of all the
   * sections when new props are received, which should be plenty fast for up to ~10,000 items.
   */
  class VirtualizedSectionList extends React.PureComponent {
    constructor() {
      super(...arguments);
      this._keyExtractor = (item, index) => {
        var info = this._subExtractor(index);
        return info && info.key || String(index);
      };
      this._convertViewable = viewable => {
        var _info$index;
        (0, invariant.default)(viewable.index != null, 'Received a broken ViewToken');
        var info = this._subExtractor(viewable.index);
        if (!info) {
          return null;
        }
        var keyExtractorWithNullableIndex = info.section.keyExtractor;
        var keyExtractorWithNonNullableIndex = this.props.keyExtractor || _VirtualizeUtils.keyExtractor;
        var key = keyExtractorWithNullableIndex != null ? keyExtractorWithNullableIndex(viewable.item, info.index) : keyExtractorWithNonNullableIndex(viewable.item, (_info$index = info.index) !== null && _info$index !== undefined ? _info$index : 0);
        return (0, _objectSpread.default)((0, _objectSpread.default)({}, viewable), {}, {
          index: info.index,
          key,
          section: info.section
        });
      };
      this._onViewableItemsChanged = _ref => {
        var viewableItems = _ref.viewableItems,
          changed = _ref.changed;
        var onViewableItemsChanged = this.props.onViewableItemsChanged;
        if (onViewableItemsChanged != null) {
          onViewableItemsChanged({
            viewableItems: viewableItems.map(this._convertViewable, this).filter(Boolean),
            changed: changed.map(this._convertViewable, this).filter(Boolean)
          });
        }
      };
      this._renderItem = listItemCount =>
      // eslint-disable-next-line react/no-unstable-nested-components
      _ref2 => {
        var item = _ref2.item,
          index = _ref2.index;
        var info = this._subExtractor(index);
        if (!info) {
          return null;
        }
        var infoIndex = info.index;
        if (infoIndex == null) {
          var section = info.section;
          if (info.header === true) {
            var renderSectionHeader = this.props.renderSectionHeader;
            return renderSectionHeader ? renderSectionHeader({
              section
            }) : null;
          } else {
            var renderSectionFooter = this.props.renderSectionFooter;
            return renderSectionFooter ? renderSectionFooter({
              section
            }) : null;
          }
        } else {
          var renderItem = info.section.renderItem || this.props.renderItem;
          var SeparatorComponent = this._getSeparatorComponent(index, info, listItemCount);
          (0, invariant.default)(renderItem, 'no renderItem!');
          return /*#__PURE__*/React.createElement(ItemWithSeparator, {
            SeparatorComponent: SeparatorComponent,
            LeadingSeparatorComponent: infoIndex === 0 ? this.props.SectionSeparatorComponent : undefined,
            cellKey: info.key,
            index: infoIndex,
            item: item,
            leadingItem: info.leadingItem,
            leadingSection: info.leadingSection,
            prevCellKey: (this._subExtractor(index - 1) || {}).key
            // Callback to provide updateHighlight for this item
            ,

            setSelfHighlightCallback: this._setUpdateHighlightFor,
            setSelfUpdatePropsCallback: this._setUpdatePropsFor
            // Provide child ability to set highlight/updateProps for previous item using prevCellKey
            ,

            updateHighlightFor: this._updateHighlightFor,
            updatePropsFor: this._updatePropsFor,
            renderItem: renderItem,
            section: info.section,
            trailingItem: info.trailingItem,
            trailingSection: info.trailingSection,
            inverted: !!this.props.inverted
          });
        }
      };
      this._updatePropsFor = (cellKey, value) => {
        var updateProps = this._updatePropsMap[cellKey];
        if (updateProps != null) {
          updateProps(value);
        }
      };
      this._updateHighlightFor = (cellKey, value) => {
        var updateHighlight = this._updateHighlightMap[cellKey];
        if (updateHighlight != null) {
          updateHighlight(value);
        }
      };
      this._setUpdateHighlightFor = (cellKey, updateHighlightFn) => {
        if (updateHighlightFn != null) {
          this._updateHighlightMap[cellKey] = updateHighlightFn;
        } else {
          // $FlowFixMe[prop-missing]
          delete this._updateHighlightFor[cellKey];
        }
      };
      this._setUpdatePropsFor = (cellKey, updatePropsFn) => {
        if (updatePropsFn != null) {
          this._updatePropsMap[cellKey] = updatePropsFn;
        } else {
          delete this._updatePropsMap[cellKey];
        }
      };
      this._updateHighlightMap = {};
      this._updatePropsMap = {};
      this._captureRef = ref => {
        this._listRef = ref;
      };
    }
    scrollToLocation(params) {
      var index = params.itemIndex;
      for (var i = 0; i < params.sectionIndex; i++) {
        index += this.props.getItemCount(this.props.sections[i].data) + 2;
      }
      var viewOffset = params.viewOffset || 0;
      if (this._listRef == null) {
        return;
      }
      if (params.itemIndex > 0 && this.props.stickySectionHeadersEnabled) {
        var frame = this._listRef.__getFrameMetricsApprox(index - params.itemIndex, this._listRef.props);
        viewOffset += frame.length;
      }
      var toIndexParams = (0, _objectSpread.default)((0, _objectSpread.default)({}, params), {}, {
        viewOffset,
        index
      });
      // $FlowFixMe[incompatible-use]
      this._listRef.scrollToIndex(toIndexParams);
    }
    getListRef() {
      return this._listRef;
    }
    render() {
      var _this$props = this.props,
        ItemSeparatorComponent = _this$props.ItemSeparatorComponent,
        SectionSeparatorComponent = _this$props.SectionSeparatorComponent,
        _renderItem = _this$props.renderItem,
        renderSectionFooter = _this$props.renderSectionFooter,
        renderSectionHeader = _this$props.renderSectionHeader,
        _sections = _this$props.sections,
        stickySectionHeadersEnabled = _this$props.stickySectionHeadersEnabled,
        passThroughProps = (0, _objectWithoutPropertiesLoose.default)(_this$props, _excluded);
      var listHeaderOffset = this.props.ListHeaderComponent ? 1 : 0;
      var stickyHeaderIndices = this.props.stickySectionHeadersEnabled ? [] : undefined;
      var itemCount = 0;
      for (var _iterator = (0, _createForOfIteratorHelperLoose.default)(this.props.sections), _step; !(_step = _iterator()).done;) {
        var section = _step.value;
        // Track the section header indices
        if (stickyHeaderIndices != null) {
          stickyHeaderIndices.push(itemCount + listHeaderOffset);
        }

        // Add two for the section header and footer.
        itemCount += 2;
        itemCount += this.props.getItemCount(section.data);
      }
      var renderItem = this._renderItem(itemCount);
      return /*#__PURE__*/React.createElement(VirtualizedList.default, (0, _extends.default)({}, passThroughProps, {
        keyExtractor: this._keyExtractor,
        stickyHeaderIndices: stickyHeaderIndices,
        renderItem: renderItem,
        data: this.props.sections,
        getItem: (sections, index) => this._getItem(this.props, sections, index),
        getItemCount: () => itemCount,
        onViewableItemsChanged: this.props.onViewableItemsChanged ? this._onViewableItemsChanged : undefined,
        ref: this._captureRef
      }));
    }
    _getItem(props, sections, index) {
      if (!sections) {
        return null;
      }
      var itemIdx = index - 1;
      for (var i = 0; i < sections.length; i++) {
        var section = sections[i];
        var sectionData = section.data;
        var itemCount = props.getItemCount(sectionData);
        if (itemIdx === -1 || itemIdx === itemCount) {
          // We intend for there to be overflow by one on both ends of the list.
          // This will be for headers and footers. When returning a header or footer
          // item the section itself is the item.
          return section;
        } else if (itemIdx < itemCount) {
          // If we are in the bounds of the list's data then return the item.
          return props.getItem(sectionData, itemIdx);
        } else {
          itemIdx -= itemCount + 2; // Add two for the header and footer
        }
      }
      return null;
    }

    // $FlowFixMe[missing-local-annot]

    _subExtractor(index) {
      var itemIndex = index;
      var _this$props2 = this.props,
        getItem = _this$props2.getItem,
        getItemCount = _this$props2.getItemCount,
        keyExtractor = _this$props2.keyExtractor,
        sections = _this$props2.sections;
      for (var i = 0; i < sections.length; i++) {
        var section = sections[i];
        var sectionData = section.data;
        var key = section.key || String(i);
        itemIndex -= 1; // The section adds an item for the header
        if (itemIndex >= getItemCount(sectionData) + 1) {
          itemIndex -= getItemCount(sectionData) + 1; // The section adds an item for the footer.
        } else if (itemIndex === -1) {
          return {
            section,
            key: key + ':header',
            index: null,
            header: true,
            trailingSection: sections[i + 1]
          };
        } else if (itemIndex === getItemCount(sectionData)) {
          return {
            section,
            key: key + ':footer',
            index: null,
            header: false,
            trailingSection: sections[i + 1]
          };
        } else {
          var extractor = section.keyExtractor || keyExtractor || _VirtualizeUtils.keyExtractor;
          return {
            section,
            key: key + ':' + extractor(getItem(sectionData, itemIndex), itemIndex),
            index: itemIndex,
            leadingItem: getItem(sectionData, itemIndex - 1),
            leadingSection: sections[i - 1],
            trailingItem: getItem(sectionData, itemIndex + 1),
            trailingSection: sections[i + 1]
          };
        }
      }
    }
    _getSeparatorComponent(index, info, listItemCount) {
      info = info || this._subExtractor(index);
      if (!info) {
        return null;
      }
      var ItemSeparatorComponent = info.section.ItemSeparatorComponent || this.props.ItemSeparatorComponent;
      var SectionSeparatorComponent = this.props.SectionSeparatorComponent;
      var isLastItemInList = index === listItemCount - 1;
      var isLastItemInSection = info.index === this.props.getItemCount(info.section.data) - 1;
      if (SectionSeparatorComponent && isLastItemInSection) {
        return SectionSeparatorComponent;
      }
      if (ItemSeparatorComponent && !isLastItemInSection && !isLastItemInList) {
        return ItemSeparatorComponent;
      }
      return null;
    }
  }
  function ItemWithSeparator(props) {
    var LeadingSeparatorComponent = props.LeadingSeparatorComponent,
      SeparatorComponent = props.SeparatorComponent,
      cellKey = props.cellKey,
      prevCellKey = props.prevCellKey,
      setSelfHighlightCallback = props.setSelfHighlightCallback,
      updateHighlightFor = props.updateHighlightFor,
      setSelfUpdatePropsCallback = props.setSelfUpdatePropsCallback,
      updatePropsFor = props.updatePropsFor,
      item = props.item,
      index = props.index,
      section = props.section,
      inverted = props.inverted;
    var _React$useState = React.useState(false),
      leadingSeparatorHiglighted = _React$useState[0],
      setLeadingSeparatorHighlighted = _React$useState[1];
    var _React$useState2 = React.useState(false),
      separatorHighlighted = _React$useState2[0],
      setSeparatorHighlighted = _React$useState2[1];
    var _React$useState3 = React.useState({
        leadingItem: props.leadingItem,
        leadingSection: props.leadingSection,
        section: props.section,
        trailingItem: props.item,
        trailingSection: props.trailingSection
      }),
      leadingSeparatorProps = _React$useState3[0],
      setLeadingSeparatorProps = _React$useState3[1];
    var _React$useState4 = React.useState({
        leadingItem: props.item,
        leadingSection: props.leadingSection,
        section: props.section,
        trailingItem: props.trailingItem,
        trailingSection: props.trailingSection
      }),
      separatorProps = _React$useState4[0],
      setSeparatorProps = _React$useState4[1];
    React.useEffect(() => {
      setSelfHighlightCallback(cellKey, setSeparatorHighlighted);
      // $FlowFixMe[incompatible-call]
      setSelfUpdatePropsCallback(cellKey, setSeparatorProps);
      return () => {
        setSelfUpdatePropsCallback(cellKey, null);
        setSelfHighlightCallback(cellKey, null);
      };
    }, [cellKey, setSelfHighlightCallback, setSeparatorProps, setSelfUpdatePropsCallback]);
    var separators = {
      highlight: () => {
        setLeadingSeparatorHighlighted(true);
        setSeparatorHighlighted(true);
        if (prevCellKey != null) {
          updateHighlightFor(prevCellKey, true);
        }
      },
      unhighlight: () => {
        setLeadingSeparatorHighlighted(false);
        setSeparatorHighlighted(false);
        if (prevCellKey != null) {
          updateHighlightFor(prevCellKey, false);
        }
      },
      updateProps: (select, newProps) => {
        if (select === 'leading') {
          if (LeadingSeparatorComponent != null) {
            setLeadingSeparatorProps((0, _objectSpread.default)((0, _objectSpread.default)({}, leadingSeparatorProps), newProps));
          } else if (prevCellKey != null) {
            // update the previous item's separator
            updatePropsFor(prevCellKey, (0, _objectSpread.default)((0, _objectSpread.default)({}, leadingSeparatorProps), newProps));
          }
        } else if (select === 'trailing' && SeparatorComponent != null) {
          setSeparatorProps((0, _objectSpread.default)((0, _objectSpread.default)({}, separatorProps), newProps));
        }
      }
    };
    var element = props.renderItem({
      item,
      index,
      section,
      separators
    });
    var leadingSeparator = LeadingSeparatorComponent != null && /*#__PURE__*/React.createElement(LeadingSeparatorComponent, (0, _extends.default)({
      highlighted: leadingSeparatorHiglighted
    }, leadingSeparatorProps));
    var separator = SeparatorComponent != null && /*#__PURE__*/React.createElement(SeparatorComponent, (0, _extends.default)({
      highlighted: separatorHighlighted
    }, separatorProps));
    return leadingSeparator || separator ? /*#__PURE__*/React.createElement(View.default, null, inverted === false ? leadingSeparator : separator, element, inverted === false ? separator : leadingSeparator) : element;
  }

  /* $FlowFixMe[class-object-subtyping] added when improving typing for this
   * parameters */
  // $FlowFixMe[method-unbinding]
  var _default = VirtualizedSectionList;
},214,[28,157,44,20,138,156,182,25,35]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  require(_dependencyMap[0]);
  var _exportsText = require(_dependencyMap[1]);
  var Text = _interopDefault(_exportsText);
  var _createAnimatedComponent = require(_dependencyMap[2]);
  var createAnimatedComponent = _interopDefault(_createAnimatedComponent);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  var _default = (0, createAnimatedComponent.default)(Text.default);
},215,[35,216,185]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2]);
  var React = _interopNamespace(_react);
  var _createElement = require(_dependencyMap[3]);
  var createElement = _interopDefault(_createElement);
  var _modulesForwardedProps = require(_dependencyMap[4]);
  var forwardedProps = _interopNamespace(_modulesForwardedProps);
  var _modulesPick = require(_dependencyMap[5]);
  var pick = _interopDefault(_modulesPick);
  var _modulesUseElementLayout = require(_dependencyMap[6]);
  var useElementLayout = _interopDefault(_modulesUseElementLayout);
  var _modulesUseMergeRefs = require(_dependencyMap[7]);
  var useMergeRefs = _interopDefault(_modulesUseMergeRefs);
  var _modulesUsePlatformMethods = require(_dependencyMap[8]);
  var usePlatformMethods = _interopDefault(_modulesUsePlatformMethods);
  var _modulesUseResponderEvents = require(_dependencyMap[9]);
  var useResponderEvents = _interopDefault(_modulesUseResponderEvents);
  var _StyleSheet = require(_dependencyMap[10]);
  var StyleSheet = _interopDefault(_StyleSheet);
  var _TextAncestorContext = require(_dependencyMap[11]);
  var TextAncestorContext = _interopDefault(_TextAncestorContext);
  var _modulesUseLocale = require(_dependencyMap[12]);
  var _excluded = ["hrefAttrs", "numberOfLines", "onClick", "onLayout", "onPress", "onMoveShouldSetResponder", "onMoveShouldSetResponderCapture", "onResponderEnd", "onResponderGrant", "onResponderMove", "onResponderReject", "onResponderRelease", "onResponderStart", "onResponderTerminate", "onResponderTerminationRequest", "onScrollShouldSetResponder", "onScrollShouldSetResponderCapture", "onSelectionChangeShouldSetResponder", "onSelectionChangeShouldSetResponderCapture", "onStartShouldSetResponder", "onStartShouldSetResponderCapture", "selectable"];
  //import { warnOnce } from '../../modules/warnOnce';

  var forwardPropsList = Object.assign({}, forwardedProps.defaultProps, forwardedProps.accessibilityProps, forwardedProps.clickProps, forwardedProps.focusProps, forwardedProps.keyboardProps, forwardedProps.mouseProps, forwardedProps.touchProps, forwardedProps.styleProps, {
    href: true,
    lang: true,
    pointerEvents: true
  });
  var pickProps = props => (0, pick.default)(props, forwardPropsList);
  var Text = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var hrefAttrs = props.hrefAttrs,
      numberOfLines = props.numberOfLines,
      onClick = props.onClick,
      onLayout = props.onLayout,
      onPress = props.onPress,
      onMoveShouldSetResponder = props.onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture = props.onMoveShouldSetResponderCapture,
      onResponderEnd = props.onResponderEnd,
      onResponderGrant = props.onResponderGrant,
      onResponderMove = props.onResponderMove,
      onResponderReject = props.onResponderReject,
      onResponderRelease = props.onResponderRelease,
      onResponderStart = props.onResponderStart,
      onResponderTerminate = props.onResponderTerminate,
      onResponderTerminationRequest = props.onResponderTerminationRequest,
      onScrollShouldSetResponder = props.onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture = props.onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder = props.onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture = props.onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder = props.onStartShouldSetResponder,
      onStartShouldSetResponderCapture = props.onStartShouldSetResponderCapture,
      selectable = props.selectable,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);

    /*
    if (selectable != null) {
      warnOnce(
        'selectable',
        'selectable prop is deprecated. Use styles.userSelect.'
      );
    }
    */

    var hasTextAncestor = React.useContext(TextAncestorContext.default);
    var hostRef = React.useRef(null);
    var _useLocaleContext = (0, _modulesUseLocale.useLocaleContext)(),
      contextDirection = _useLocaleContext.direction;
    (0, useElementLayout.default)(hostRef, onLayout);
    (0, useResponderEvents.default)(hostRef, {
      onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture,
      onResponderEnd,
      onResponderGrant,
      onResponderMove,
      onResponderReject,
      onResponderRelease,
      onResponderStart,
      onResponderTerminate,
      onResponderTerminationRequest,
      onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder,
      onStartShouldSetResponderCapture
    });
    var handleClick = React.useCallback(e => {
      if (onClick != null) {
        onClick(e);
      } else if (onPress != null) {
        e.stopPropagation();
        onPress(e);
      }
    }, [onClick, onPress]);
    var component = hasTextAncestor ? 'span' : 'div';
    var langDirection = props.lang != null ? (0, _modulesUseLocale.getLocaleDirection)(props.lang) : null;
    var componentDirection = props.dir || langDirection;
    var writingDirection = componentDirection || contextDirection;
    var supportedProps = pickProps(rest);
    supportedProps.dir = componentDirection;
    // 'auto' by default allows browsers to infer writing direction (root elements only)
    if (!hasTextAncestor) {
      supportedProps.dir = componentDirection != null ? componentDirection : 'auto';
    }
    if (onClick || onPress) {
      supportedProps.onClick = handleClick;
    }
    supportedProps.style = [numberOfLines != null && numberOfLines > 1 && {
      WebkitLineClamp: numberOfLines
    }, hasTextAncestor === true ? styles.textHasAncestor$raw : styles.text$raw, numberOfLines === 1 && styles.textOneLine, numberOfLines != null && numberOfLines > 1 && styles.textMultiLine, props.style, selectable === true && styles.selectable, selectable === false && styles.notSelectable, onPress && styles.pressable];
    if (props.href != null) {
      component = 'a';
      if (hrefAttrs != null) {
        var download = hrefAttrs.download,
          rel = hrefAttrs.rel,
          target = hrefAttrs.target;
        if (download != null) {
          supportedProps.download = download;
        }
        if (rel != null) {
          supportedProps.rel = rel;
        }
        if (typeof target === 'string') {
          supportedProps.target = target.charAt(0) !== '_' ? '_' + target : target;
        }
      }
    }
    var platformMethodsRef = (0, usePlatformMethods.default)(supportedProps);
    var setRef = (0, useMergeRefs.default)(hostRef, platformMethodsRef, forwardedRef);
    supportedProps.ref = setRef;
    var element = (0, createElement.default)(component, supportedProps, {
      writingDirection
    });
    return hasTextAncestor ? element : /*#__PURE__*/React.createElement(TextAncestorContext.default.Provider, {
      value: true
    }, element);
  });
  Text.displayName = 'Text';
  var textStyle = {
    backgroundColor: 'transparent',
    border: '0 solid black',
    boxSizing: 'border-box',
    color: 'black',
    display: 'inline',
    font: '14px System',
    listStyle: 'none',
    margin: 0,
    padding: 0,
    position: 'relative',
    textAlign: 'start',
    textDecoration: 'none',
    whiteSpace: 'pre-wrap',
    wordWrap: 'break-word'
  };
  var styles = StyleSheet.default.create({
    text$raw: textStyle,
    textHasAncestor$raw: (0, _objectSpread.default)((0, _objectSpread.default)({}, textStyle), {}, {
      color: 'inherit',
      font: 'inherit',
      textAlign: 'inherit',
      whiteSpace: 'inherit'
    }),
    textOneLine: {
      maxWidth: '100%',
      overflow: 'hidden',
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap',
      wordWrap: 'normal'
    },
    // See #13
    textMultiLine: {
      display: '-webkit-box',
      maxWidth: '100%',
      overflow: 'clip',
      textOverflow: 'ellipsis',
      WebkitBoxOrient: 'vertical'
    },
    notSelectable: {
      userSelect: 'none'
    },
    selectable: {
      userSelect: 'text'
    },
    pressable: {
      cursor: 'pointer'
    }
  });
  var _default = Text;
},216,[20,44,35,116,139,140,141,143,145,147,43,154,122]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  require(_dependencyMap[0]);
  var _exportsView = require(_dependencyMap[1]);
  var View = _interopDefault(_exportsView);
  var _createAnimatedComponent = require(_dependencyMap[2]);
  var createAnimatedComponent = _interopDefault(_createAnimatedComponent);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  var _default = (0, createAnimatedComponent.default)(View.default);
},217,[35,138,185]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _AnimatedEvent = require(_dependencyMap[1]);
  var _AnimatedImplementation = require(_dependencyMap[2]);
  var AnimatedImplementation = _interopDefault(_AnimatedImplementation);
  var _nodesAnimatedInterpolation = require(_dependencyMap[3]);
  var AnimatedInterpolation = _interopDefault(_nodesAnimatedInterpolation);
  var _nodesAnimatedNode = require(_dependencyMap[4]);
  var AnimatedNode = _interopDefault(_nodesAnimatedNode);
  var _nodesAnimatedValue = require(_dependencyMap[5]);
  var AnimatedValue = _interopDefault(_nodesAnimatedValue);
  var _nodesAnimatedValueXY = require(_dependencyMap[6]);
  var AnimatedValueXY = _interopDefault(_nodesAnimatedValueXY);
  var _createAnimatedComponent = require(_dependencyMap[7]);
  var createAnimatedComponent = _interopDefault(_createAnimatedComponent);
  var _nodesAnimatedColor = require(_dependencyMap[8]);
  var AnimatedColor = _interopDefault(_nodesAnimatedColor);
  /**
   * Animations are a source of flakiness in snapshot testing. This mock replaces
   * animation functions from AnimatedImplementation with empty animations for
   * predictability in tests. When possible the animation will run immediately
   * to the final state.
   */

  // Prevent any callback invocation from recursively triggering another
  // callback, which may trigger another animation
  var inAnimationCallback = false;
  function mockAnimationStart(start) {
    return callback => {
      var guardedCallback = callback == null ? callback : function () {
        if (inAnimationCallback) {
          console.warn('Ignoring recursive animation callback when running mock animations');
          return;
        }
        inAnimationCallback = true;
        try {
          callback(...arguments);
        } finally {
          inAnimationCallback = false;
        }
      };
      start(guardedCallback);
    };
  }
  var emptyAnimation = {
    start: () => {},
    stop: () => {},
    reset: () => {},
    _startNativeLoop: () => {},
    _isUsingNativeDriver: () => {
      return false;
    }
  };
  var mockCompositeAnimation = animations => (0, _objectSpread.default)((0, _objectSpread.default)({}, emptyAnimation), {}, {
    start: mockAnimationStart(callback => {
      animations.forEach(animation => animation.start());
      callback == null ? undefined : callback({
        finished: true
      });
    })
  });
  var spring = function spring(value, config) {
    var anyValue = value;
    return (0, _objectSpread.default)((0, _objectSpread.default)({}, emptyAnimation), {}, {
      start: mockAnimationStart(callback => {
        anyValue.setValue(config.toValue);
        callback == null ? undefined : callback({
          finished: true
        });
      })
    });
  };
  var timing = function timing(value, config) {
    var anyValue = value;
    return (0, _objectSpread.default)((0, _objectSpread.default)({}, emptyAnimation), {}, {
      start: mockAnimationStart(callback => {
        anyValue.setValue(config.toValue);
        callback == null ? undefined : callback({
          finished: true
        });
      })
    });
  };
  var decay = function decay(value, config) {
    return emptyAnimation;
  };
  var sequence = function sequence(animations) {
    return mockCompositeAnimation(animations);
  };
  var parallel = function parallel(animations, config) {
    return mockCompositeAnimation(animations);
  };
  var delay = function delay(time) {
    return emptyAnimation;
  };
  var stagger = function stagger(time, animations) {
    return mockCompositeAnimation(animations);
  };
  var loop = function loop(animation,
  // $FlowFixMe[prop-missing]
  _temp) {
    var _ref = _temp === undefined ? {} : _temp,
      _ref$iterations = _ref.iterations,
      iterations = _ref$iterations === undefined ? -1 : _ref$iterations;
    return emptyAnimation;
  };
  var _default = {
    Value: AnimatedValue.default,
    ValueXY: AnimatedValueXY.default,
    Color: AnimatedColor.default,
    Interpolation: AnimatedInterpolation.default,
    Node: AnimatedNode.default,
    decay,
    timing,
    spring,
    add: AnimatedImplementation.default.add,
    subtract: AnimatedImplementation.default.subtract,
    divide: AnimatedImplementation.default.divide,
    multiply: AnimatedImplementation.default.multiply,
    modulo: AnimatedImplementation.default.modulo,
    diffClamp: AnimatedImplementation.default.diffClamp,
    delay,
    sequence,
    parallel,
    stagger,
    loop,
    event: AnimatedImplementation.default.event,
    createAnimatedComponent: createAnimatedComponent.default,
    attachNativeEvent: _AnimatedEvent.attachNativeEvent,
    forkEvent: AnimatedImplementation.default.forkEvent,
    unforkEvent: AnimatedImplementation.default.unforkEvent,
    Event: _AnimatedEvent.AnimatedEvent
  };
},218,[20,188,219,190,192,189,227,185,232]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _AnimatedEvent = require(_dependencyMap[1]);
  var _nodesAnimatedAddition = require(_dependencyMap[2]);
  var AnimatedAddition = _interopDefault(_nodesAnimatedAddition);
  var _nodesAnimatedDiffClamp = require(_dependencyMap[3]);
  var AnimatedDiffClamp = _interopDefault(_nodesAnimatedDiffClamp);
  var _nodesAnimatedDivision = require(_dependencyMap[4]);
  var AnimatedDivision = _interopDefault(_nodesAnimatedDivision);
  var _nodesAnimatedInterpolation = require(_dependencyMap[5]);
  var AnimatedInterpolation = _interopDefault(_nodesAnimatedInterpolation);
  var _nodesAnimatedModulo = require(_dependencyMap[6]);
  var AnimatedModulo = _interopDefault(_nodesAnimatedModulo);
  var _nodesAnimatedMultiplication = require(_dependencyMap[7]);
  var AnimatedMultiplication = _interopDefault(_nodesAnimatedMultiplication);
  var _nodesAnimatedNode = require(_dependencyMap[8]);
  var AnimatedNode = _interopDefault(_nodesAnimatedNode);
  require(_dependencyMap[9]);
  var _nodesAnimatedSubtraction = require(_dependencyMap[10]);
  var AnimatedSubtraction = _interopDefault(_nodesAnimatedSubtraction);
  var _nodesAnimatedTracking = require(_dependencyMap[11]);
  var AnimatedTracking = _interopDefault(_nodesAnimatedTracking);
  var _nodesAnimatedValue = require(_dependencyMap[12]);
  var AnimatedValue = _interopDefault(_nodesAnimatedValue);
  var _nodesAnimatedValueXY = require(_dependencyMap[13]);
  var AnimatedValueXY = _interopDefault(_nodesAnimatedValueXY);
  var _animationsDecayAnimation = require(_dependencyMap[14]);
  var DecayAnimation = _interopDefault(_animationsDecayAnimation);
  var _animationsSpringAnimation = require(_dependencyMap[15]);
  var SpringAnimation = _interopDefault(_animationsSpringAnimation);
  var _animationsTimingAnimation = require(_dependencyMap[16]);
  var TimingAnimation = _interopDefault(_animationsTimingAnimation);
  var _createAnimatedComponent = require(_dependencyMap[17]);
  var createAnimatedComponent = _interopDefault(_createAnimatedComponent);
  var _nodesAnimatedColor = require(_dependencyMap[18]);
  var AnimatedColor = _interopDefault(_nodesAnimatedColor);
  var add = function add(a, b) {
    return new AnimatedAddition.default(a, b);
  };
  var subtract = function subtract(a, b) {
    return new AnimatedSubtraction.default(a, b);
  };
  var divide = function divide(a, b) {
    return new AnimatedDivision.default(a, b);
  };
  var multiply = function multiply(a, b) {
    return new AnimatedMultiplication.default(a, b);
  };
  var modulo = function modulo(a, modulus) {
    return new AnimatedModulo.default(a, modulus);
  };
  var diffClamp = function diffClamp(a, min, max) {
    return new AnimatedDiffClamp.default(a, min, max);
  };
  var _combineCallbacks = function _combineCallbacks(callback, config) {
    if (callback && config.onComplete) {
      return function () {
        config.onComplete && config.onComplete(...arguments);
        callback && callback(...arguments);
      };
    } else {
      return callback || config.onComplete;
    }
  };
  var maybeVectorAnim = function maybeVectorAnim(value, config, anim) {
    if (value instanceof AnimatedValueXY.default) {
      var configX = (0, _objectSpread.default)({}, config);
      var configY = (0, _objectSpread.default)({}, config);
      for (var key in config) {
        var _config$key = config[key],
          x = _config$key.x,
          y = _config$key.y;
        if (x !== undefined && y !== undefined) {
          configX[key] = x;
          configY[key] = y;
        }
      }
      var aX = anim(value.x, configX);
      var aY = anim(value.y, configY);
      // We use `stopTogether: false` here because otherwise tracking will break
      // because the second animation will get stopped before it can update.
      return parallel([aX, aY], {
        stopTogether: false
      });
    } else if (value instanceof AnimatedColor.default) {
      var configR = (0, _objectSpread.default)({}, config);
      var configG = (0, _objectSpread.default)({}, config);
      var configB = (0, _objectSpread.default)({}, config);
      var configA = (0, _objectSpread.default)({}, config);
      for (var _key in config) {
        var _config$_key = config[_key],
          r = _config$_key.r,
          g = _config$_key.g,
          b = _config$_key.b,
          a = _config$_key.a;
        if (r !== undefined && g !== undefined && b !== undefined && a !== undefined) {
          configR[_key] = r;
          configG[_key] = g;
          configB[_key] = b;
          configA[_key] = a;
        }
      }
      var aR = anim(value.r, configR);
      var aG = anim(value.g, configG);
      var aB = anim(value.b, configB);
      var aA = anim(value.a, configA);
      // We use `stopTogether: false` here because otherwise tracking will break
      // because the second animation will get stopped before it can update.
      return parallel([aR, aG, aB, aA], {
        stopTogether: false
      });
    }
    return null;
  };
  var spring = function spring(value, config) {
    var _start = function start(animatedValue, configuration, callback) {
      callback = _combineCallbacks(callback, configuration);
      var singleValue = animatedValue;
      var singleConfig = configuration;
      singleValue.stopTracking();
      if (configuration.toValue instanceof AnimatedNode.default) {
        singleValue.track(new AnimatedTracking.default(singleValue, configuration.toValue, SpringAnimation.default, singleConfig, callback));
      } else {
        singleValue.animate(new SpringAnimation.default(singleConfig), callback);
      }
    };
    return maybeVectorAnim(value, config, spring) || {
      start: function start(callback) {
        _start(value, config, callback);
      },
      stop: function stop() {
        value.stopAnimation();
      },
      reset: function reset() {
        value.resetAnimation();
      },
      _startNativeLoop: function _startNativeLoop(iterations) {
        var singleConfig = (0, _objectSpread.default)((0, _objectSpread.default)({}, config), {}, {
          iterations
        });
        _start(value, singleConfig);
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return config.useNativeDriver || false;
      }
    };
  };
  var timing = function timing(value, config) {
    var _start2 = function start(animatedValue, configuration, callback) {
      callback = _combineCallbacks(callback, configuration);
      var singleValue = animatedValue;
      var singleConfig = configuration;
      singleValue.stopTracking();
      if (configuration.toValue instanceof AnimatedNode.default) {
        singleValue.track(new AnimatedTracking.default(singleValue, configuration.toValue, TimingAnimation.default, singleConfig, callback));
      } else {
        singleValue.animate(new TimingAnimation.default(singleConfig), callback);
      }
    };
    return maybeVectorAnim(value, config, timing) || {
      start: function start(callback) {
        _start2(value, config, callback);
      },
      stop: function stop() {
        value.stopAnimation();
      },
      reset: function reset() {
        value.resetAnimation();
      },
      _startNativeLoop: function _startNativeLoop(iterations) {
        var singleConfig = (0, _objectSpread.default)((0, _objectSpread.default)({}, config), {}, {
          iterations
        });
        _start2(value, singleConfig);
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return config.useNativeDriver || false;
      }
    };
  };
  var decay = function decay(value, config) {
    var _start3 = function start(animatedValue, configuration, callback) {
      callback = _combineCallbacks(callback, configuration);
      var singleValue = animatedValue;
      var singleConfig = configuration;
      singleValue.stopTracking();
      singleValue.animate(new DecayAnimation.default(singleConfig), callback);
    };
    return maybeVectorAnim(value, config, decay) || {
      start: function start(callback) {
        _start3(value, config, callback);
      },
      stop: function stop() {
        value.stopAnimation();
      },
      reset: function reset() {
        value.resetAnimation();
      },
      _startNativeLoop: function _startNativeLoop(iterations) {
        var singleConfig = (0, _objectSpread.default)((0, _objectSpread.default)({}, config), {}, {
          iterations
        });
        _start3(value, singleConfig);
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return config.useNativeDriver || false;
      }
    };
  };
  var sequence = function sequence(animations) {
    var current = 0;
    return {
      start: function start(callback) {
        var onComplete = function onComplete(result) {
          if (!result.finished) {
            callback && callback(result);
            return;
          }
          current++;
          if (current === animations.length) {
            // if the start is called, even without a reset, it should start from the beginning
            current = 0;
            callback && callback(result);
            return;
          }
          animations[current].start(onComplete);
        };
        if (animations.length === 0) {
          callback && callback({
            finished: true
          });
        } else {
          animations[current].start(onComplete);
        }
      },
      stop: function stop() {
        if (current < animations.length) {
          animations[current].stop();
        }
      },
      reset: function reset() {
        animations.forEach((animation, idx) => {
          if (idx <= current) {
            animation.reset();
          }
        });
        current = 0;
      },
      _startNativeLoop: function _startNativeLoop() {
        throw new Error('Loops run using the native driver cannot contain Animated.sequence animations');
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return false;
      }
    };
  };
  var parallel = function parallel(animations, config) {
    var doneCount = 0;
    // Make sure we only call stop() at most once for each animation
    var hasEnded = {};
    var stopTogether = !(config && config.stopTogether === false);
    var result = {
      start: function start(callback) {
        if (doneCount === animations.length) {
          callback && callback({
            finished: true
          });
          return;
        }
        animations.forEach((animation, idx) => {
          var cb = function cb(endResult) {
            hasEnded[idx] = true;
            doneCount++;
            if (doneCount === animations.length) {
              doneCount = 0;
              callback && callback(endResult);
              return;
            }
            if (!endResult.finished && stopTogether) {
              result.stop();
            }
          };
          if (!animation) {
            cb({
              finished: true
            });
          } else {
            animation.start(cb);
          }
        });
      },
      stop: function stop() {
        animations.forEach((animation, idx) => {
          !hasEnded[idx] && animation.stop();
          hasEnded[idx] = true;
        });
      },
      reset: function reset() {
        animations.forEach((animation, idx) => {
          animation.reset();
          hasEnded[idx] = false;
          doneCount = 0;
        });
      },
      _startNativeLoop: function _startNativeLoop() {
        throw new Error('Loops run using the native driver cannot contain Animated.parallel animations');
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return false;
      }
    };
    return result;
  };
  var delay = function delay(time) {
    // Would be nice to make a specialized implementation
    return timing(new AnimatedValue.default(0), {
      toValue: 0,
      delay: time,
      duration: 0,
      useNativeDriver: false
    });
  };
  var stagger = function stagger(time, animations) {
    return parallel(animations.map((animation, i) => {
      return sequence([delay(time * i), animation]);
    }));
  };
  var loop = function loop(animation,
  // $FlowFixMe[prop-missing]
  _temp) {
    var _ref = _temp === undefined ? {} : _temp,
      _ref$iterations = _ref.iterations,
      iterations = _ref$iterations === undefined ? -1 : _ref$iterations,
      _ref$resetBeforeItera = _ref.resetBeforeIteration,
      resetBeforeIteration = _ref$resetBeforeItera === undefined ? true : _ref$resetBeforeItera;
    var isFinished = false;
    var iterationsSoFar = 0;
    return {
      start: function start(callback) {
        var restart = function restart(result) {
          if (result === undefined) {
            result = {
              finished: true
            };
          }
          if (isFinished || iterationsSoFar === iterations || result.finished === false) {
            callback && callback(result);
          } else {
            iterationsSoFar++;
            resetBeforeIteration && animation.reset();
            animation.start(restart);
          }
        };
        if (!animation || iterations === 0) {
          callback && callback({
            finished: true
          });
        } else {
          if (animation._isUsingNativeDriver()) {
            animation._startNativeLoop(iterations);
          } else {
            restart(); // Start looping recursively on the js thread
          }
        }
      },
      stop: function stop() {
        isFinished = true;
        animation.stop();
      },
      reset: function reset() {
        iterationsSoFar = 0;
        isFinished = false;
        animation.reset();
      },
      _startNativeLoop: function _startNativeLoop() {
        throw new Error('Loops run using the native driver cannot contain Animated.loop animations');
      },
      _isUsingNativeDriver: function _isUsingNativeDriver() {
        return animation._isUsingNativeDriver();
      }
    };
  };
  function forkEvent(event, listener) {
    if (!event) {
      return listener;
    } else if (event instanceof _AnimatedEvent.AnimatedEvent) {
      event.__addListener(listener);
      return event;
    } else {
      return function () {
        typeof event === 'function' && event(...arguments);
        listener(...arguments);
      };
    }
  }
  function unforkEvent(event, listener) {
    if (event && event instanceof _AnimatedEvent.AnimatedEvent) {
      event.__removeListener(listener);
    }
  }
  var event = function event(argMapping, config) {
    var animatedEvent = new _AnimatedEvent.AnimatedEvent(argMapping, config);
    if (animatedEvent.__isNative) {
      return animatedEvent;
    } else {
      return animatedEvent.__getHandler();
    }
  };

  // All types of animated nodes that represent scalar numbers and can be interpolated (etc)

  /**
   * The `Animated` library is designed to make animations fluid, powerful, and
   * easy to build and maintain. `Animated` focuses on declarative relationships
   * between inputs and outputs, with configurable transforms in between, and
   * simple `start`/`stop` methods to control time-based animation execution.
   * If additional transforms are added, be sure to include them in
   * AnimatedMock.js as well.
   *
   * See https://reactnative.dev/docs/animated
   */
  var _default = {
    /**
     * Standard value class for driving animations.  Typically initialized with
     * `new Animated.Value(0);`
     *
     * See https://reactnative.dev/docs/animated#value
     */
    Value: AnimatedValue.default,
    /**
     * 2D value class for driving 2D animations, such as pan gestures.
     *
     * See https://reactnative.dev/docs/animatedvaluexy
     */
    ValueXY: AnimatedValueXY.default,
    /**
     * Value class for driving color animations.
     */
    Color: AnimatedColor.default,
    /**
     * Exported to use the Interpolation type in flow.
     *
     * See https://reactnative.dev/docs/animated#interpolation
     */
    Interpolation: AnimatedInterpolation.default,
    /**
     * Exported for ease of type checking. All animated values derive from this
     * class.
     *
     * See https://reactnative.dev/docs/animated#node
     */
    Node: AnimatedNode.default,
    /**
     * Animates a value from an initial velocity to zero based on a decay
     * coefficient.
     *
     * See https://reactnative.dev/docs/animated#decay
     */
    decay,
    /**
     * Animates a value along a timed easing curve. The Easing module has tons of
     * predefined curves, or you can use your own function.
     *
     * See https://reactnative.dev/docs/animated#timing
     */
    timing,
    /**
     * Animates a value according to an analytical spring model based on
     * damped harmonic oscillation.
     *
     * See https://reactnative.dev/docs/animated#spring
     */
    spring,
    /**
     * Creates a new Animated value composed from two Animated values added
     * together.
     *
     * See https://reactnative.dev/docs/animated#add
     */
    add,
    /**
     * Creates a new Animated value composed by subtracting the second Animated
     * value from the first Animated value.
     *
     * See https://reactnative.dev/docs/animated#subtract
     */
    subtract,
    /**
     * Creates a new Animated value composed by dividing the first Animated value
     * by the second Animated value.
     *
     * See https://reactnative.dev/docs/animated#divide
     */
    divide,
    /**
     * Creates a new Animated value composed from two Animated values multiplied
     * together.
     *
     * See https://reactnative.dev/docs/animated#multiply
     */
    multiply,
    /**
     * Creates a new Animated value that is the (non-negative) modulo of the
     * provided Animated value.
     *
     * See https://reactnative.dev/docs/animated#modulo
     */
    modulo,
    /**
     * Create a new Animated value that is limited between 2 values. It uses the
     * difference between the last value so even if the value is far from the
     * bounds it will start changing when the value starts getting closer again.
     *
     * See https://reactnative.dev/docs/animated#diffclamp
     */
    diffClamp,
    /**
     * Starts an animation after the given delay.
     *
     * See https://reactnative.dev/docs/animated#delay
     */
    delay,
    /**
     * Starts an array of animations in order, waiting for each to complete
     * before starting the next. If the current running animation is stopped, no
     * following animations will be started.
     *
     * See https://reactnative.dev/docs/animated#sequence
     */
    sequence,
    /**
     * Starts an array of animations all at the same time. By default, if one
     * of the animations is stopped, they will all be stopped. You can override
     * this with the `stopTogether` flag.
     *
     * See https://reactnative.dev/docs/animated#parallel
     */
    parallel,
    /**
     * Array of animations may run in parallel (overlap), but are started in
     * sequence with successive delays.  Nice for doing trailing effects.
     *
     * See https://reactnative.dev/docs/animated#stagger
     */
    stagger,
    /**
     * Loops a given animation continuously, so that each time it reaches the
     * end, it resets and begins again from the start.
     *
     * See https://reactnative.dev/docs/animated#loop
     */
    loop,
    /**
     * Takes an array of mappings and extracts values from each arg accordingly,
     * then calls `setValue` on the mapped outputs.
     *
     * See https://reactnative.dev/docs/animated#event
     */
    event,
    /**
     * Make any React component Animatable.  Used to create `Animated.View`, etc.
     *
     * See https://reactnative.dev/docs/animated#createanimatedcomponent
     */
    createAnimatedComponent: createAnimatedComponent.default,
    /**
     * Imperative API to attach an animated value to an event on a view. Prefer
     * using `Animated.event` with `useNativeDrive: true` if possible.
     *
     * See https://reactnative.dev/docs/animated#attachnativeevent
     */
    attachNativeEvent: _AnimatedEvent.attachNativeEvent,
    /**
     * Advanced imperative API for snooping on animated events that are passed in
     * through props. Use values directly where possible.
     *
     * See https://reactnative.dev/docs/animated#forkevent
     */
    forkEvent,
    unforkEvent,
    /**
     * Expose Event class, so it can be used as a type for type checkers.
     */
    Event: _AnimatedEvent.AnimatedEvent
  };
},219,[20,188,220,221,222,190,223,224,192,187,225,226,189,227,228,230,233,185,232]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _AnimatedInterpolation = require(_dependencyMap[0]);
  var AnimatedInterpolation = _interopDefault(_AnimatedInterpolation);
  var _AnimatedValue = require(_dependencyMap[1]);
  var AnimatedValue = _interopDefault(_AnimatedValue);
  var _AnimatedWithChildren = require(_dependencyMap[2]);
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  class AnimatedAddition extends AnimatedWithChildren.default {
    constructor(a, b) {
      super();
      this._a = typeof a === 'number' ? new AnimatedValue.default(a) : a;
      this._b = typeof b === 'number' ? new AnimatedValue.default(b) : b;
    }
    __makeNative(platformConfig) {
      this._a.__makeNative(platformConfig);
      this._b.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    __getValue() {
      return this._a.__getValue() + this._b.__getValue();
    }
    interpolate(config) {
      return new AnimatedInterpolation.default(this, config);
    }
    __attach() {
      this._a.__addChild(this);
      this._b.__addChild(this);
    }
    __detach() {
      this._a.__removeChild(this);
      this._b.__removeChild(this);
      super.__detach();
    }
    __getNativeConfig() {
      return {
        type: 'addition',
        input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
      };
    }
  }
  var _default = AnimatedAddition;
},220,[190,189,191]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _AnimatedInterpolation = require(_dependencyMap[0]);
  var AnimatedInterpolation = _interopDefault(_AnimatedInterpolation);
  var _AnimatedWithChildren = require(_dependencyMap[1]);
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  class AnimatedDiffClamp extends AnimatedWithChildren.default {
    constructor(a, min, max) {
      super();
      this._a = a;
      this._min = min;
      this._max = max;
      this._value = this._lastValue = this._a.__getValue();
    }
    __makeNative(platformConfig) {
      this._a.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    interpolate(config) {
      return new AnimatedInterpolation.default(this, config);
    }
    __getValue() {
      var value = this._a.__getValue();
      var diff = value - this._lastValue;
      this._lastValue = value;
      this._value = Math.min(Math.max(this._value + diff, this._min), this._max);
      return this._value;
    }
    __attach() {
      this._a.__addChild(this);
    }
    __detach() {
      this._a.__removeChild(this);
      super.__detach();
    }
    __getNativeConfig() {
      return {
        type: 'diffclamp',
        input: this._a.__getNativeTag(),
        min: this._min,
        max: this._max
      };
    }
  }
  var _default = AnimatedDiffClamp;
},221,[190,191]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _AnimatedInterpolation = require(_dependencyMap[0]);
  var AnimatedInterpolation = _interopDefault(_AnimatedInterpolation);
  var _AnimatedNode = require(_dependencyMap[1]);
  var AnimatedNode = _interopDefault(_AnimatedNode);
  var _AnimatedValue = require(_dependencyMap[2]);
  var AnimatedValue = _interopDefault(_AnimatedValue);
  var _AnimatedWithChildren = require(_dependencyMap[3]);
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  class AnimatedDivision extends AnimatedWithChildren.default {
    constructor(a, b) {
      super();
      this._warnedAboutDivideByZero = false;
      if (b === 0 || b instanceof AnimatedNode.default && b.__getValue() === 0) {
        console.error('Detected potential division by zero in AnimatedDivision');
      }
      this._a = typeof a === 'number' ? new AnimatedValue.default(a) : a;
      this._b = typeof b === 'number' ? new AnimatedValue.default(b) : b;
    }
    __makeNative(platformConfig) {
      this._a.__makeNative(platformConfig);
      this._b.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    __getValue() {
      var a = this._a.__getValue();
      var b = this._b.__getValue();
      if (b === 0) {
        // Prevent spamming the console/LogBox
        if (!this._warnedAboutDivideByZero) {
          console.error('Detected division by zero in AnimatedDivision');
          this._warnedAboutDivideByZero = true;
        }
        // Passing infinity/NaN to Fabric will cause a native crash
        return 0;
      }
      this._warnedAboutDivideByZero = false;
      return a / b;
    }
    interpolate(config) {
      return new AnimatedInterpolation.default(this, config);
    }
    __attach() {
      this._a.__addChild(this);
      this._b.__addChild(this);
    }
    __detach() {
      this._a.__removeChild(this);
      this._b.__removeChild(this);
      super.__detach();
    }
    __getNativeConfig() {
      return {
        type: 'division',
        input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
      };
    }
  }
  var _default = AnimatedDivision;
},222,[190,192,189,191]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _AnimatedInterpolation = require(_dependencyMap[0]);
  var AnimatedInterpolation = _interopDefault(_AnimatedInterpolation);
  var _AnimatedWithChildren = require(_dependencyMap[1]);
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  class AnimatedModulo extends AnimatedWithChildren.default {
    constructor(a, modulus) {
      super();
      this._a = a;
      this._modulus = modulus;
    }
    __makeNative(platformConfig) {
      this._a.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    __getValue() {
      return (this._a.__getValue() % this._modulus + this._modulus) % this._modulus;
    }
    interpolate(config) {
      return new AnimatedInterpolation.default(this, config);
    }
    __attach() {
      this._a.__addChild(this);
    }
    __detach() {
      this._a.__removeChild(this);
      super.__detach();
    }
    __getNativeConfig() {
      return {
        type: 'modulus',
        input: this._a.__getNativeTag(),
        modulus: this._modulus
      };
    }
  }
  var _default = AnimatedModulo;
},223,[190,191]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _AnimatedInterpolation = require(_dependencyMap[0]);
  var AnimatedInterpolation = _interopDefault(_AnimatedInterpolation);
  var _AnimatedValue = require(_dependencyMap[1]);
  var AnimatedValue = _interopDefault(_AnimatedValue);
  var _AnimatedWithChildren = require(_dependencyMap[2]);
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  class AnimatedMultiplication extends AnimatedWithChildren.default {
    constructor(a, b) {
      super();
      this._a = typeof a === 'number' ? new AnimatedValue.default(a) : a;
      this._b = typeof b === 'number' ? new AnimatedValue.default(b) : b;
    }
    __makeNative(platformConfig) {
      this._a.__makeNative(platformConfig);
      this._b.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    __getValue() {
      return this._a.__getValue() * this._b.__getValue();
    }
    interpolate(config) {
      return new AnimatedInterpolation.default(this, config);
    }
    __attach() {
      this._a.__addChild(this);
      this._b.__addChild(this);
    }
    __detach() {
      this._a.__removeChild(this);
      this._b.__removeChild(this);
      super.__detach();
    }
    __getNativeConfig() {
      return {
        type: 'multiplication',
        input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
      };
    }
  }
  var _default = AnimatedMultiplication;
},224,[190,189,191]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _AnimatedInterpolation = require(_dependencyMap[0]);
  var AnimatedInterpolation = _interopDefault(_AnimatedInterpolation);
  var _AnimatedValue = require(_dependencyMap[1]);
  var AnimatedValue = _interopDefault(_AnimatedValue);
  var _AnimatedWithChildren = require(_dependencyMap[2]);
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  class AnimatedSubtraction extends AnimatedWithChildren.default {
    constructor(a, b) {
      super();
      this._a = typeof a === 'number' ? new AnimatedValue.default(a) : a;
      this._b = typeof b === 'number' ? new AnimatedValue.default(b) : b;
    }
    __makeNative(platformConfig) {
      this._a.__makeNative(platformConfig);
      this._b.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    __getValue() {
      return this._a.__getValue() - this._b.__getValue();
    }
    interpolate(config) {
      return new AnimatedInterpolation.default(this, config);
    }
    __attach() {
      this._a.__addChild(this);
      this._b.__addChild(this);
    }
    __detach() {
      this._a.__removeChild(this);
      this._b.__removeChild(this);
      super.__detach();
    }
    __getNativeConfig() {
      return {
        type: 'subtraction',
        input: [this._a.__getNativeTag(), this._b.__getNativeTag()]
      };
    }
  }
  var _default = AnimatedSubtraction;
},225,[190,189,191]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  require(_dependencyMap[1]);
  var _AnimatedNode = require(_dependencyMap[2]);
  var AnimatedNode = _interopDefault(_AnimatedNode);
  var _NativeAnimatedHelper = require(_dependencyMap[3]);
  class AnimatedTracking extends AnimatedNode.default {
    constructor(value, parent, animationClass, animationConfig, callback) {
      super();
      this._value = value;
      this._parent = parent;
      this._animationClass = animationClass;
      this._animationConfig = animationConfig;
      this._useNativeDriver = (0, _NativeAnimatedHelper.shouldUseNativeDriver)(animationConfig);
      this._callback = callback;
      this.__attach();
    }
    __makeNative() {
      this.__isNative = true;
      this._parent.__makeNative();
      super.__makeNative();
      this._value.__makeNative();
    }
    __getValue() {
      return this._parent.__getValue();
    }
    __attach() {
      this._parent.__addChild(this);
      if (this._useNativeDriver) {
        // when the tracking starts we need to convert this node to a "native node"
        // so that the parent node will be made "native" too. This is necessary as
        // if we don't do this `update` method will get called. At that point it
        // may be too late as it would mean the JS driver has already started
        // updating node values
        this.__makeNative();
      }
    }
    __detach() {
      this._parent.__removeChild(this);
      super.__detach();
    }
    update() {
      this._value.animate(new this._animationClass((0, _objectSpread.default)((0, _objectSpread.default)({}, this._animationConfig), {}, {
        toValue: this._animationConfig.toValue.__getValue()
      })), this._callback);
    }
    __getNativeConfig() {
      var animation = new this._animationClass((0, _objectSpread.default)((0, _objectSpread.default)({}, this._animationConfig), {}, {
        // remove toValue from the config as it's a ref to Animated.Value
        toValue: undefined
      }));
      var animationConfig = animation.__getNativeAnimationConfig();
      return {
        type: 'tracking',
        animationId: (0, _NativeAnimatedHelper.generateNewAnimationId)(),
        animationConfig,
        toValue: this._parent.__getNativeTag(),
        value: this._value.__getNativeTag()
      };
    }
  }
  var _default = AnimatedTracking;
},226,[20,189,192,193]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _AnimatedValue = require(_dependencyMap[0]);
  var AnimatedValue = _interopDefault(_AnimatedValue);
  var _AnimatedWithChildren = require(_dependencyMap[1]);
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  var _fbjsLibInvariant = require(_dependencyMap[2]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _uniqueId = 1;

  /**
   * 2D Value for driving 2D animations, such as pan gestures. Almost identical
   * API to normal `Animated.Value`, but multiplexed.
   *
   * See https://reactnative.dev/docs/animatedvaluexy.html
   */
  class AnimatedValueXY extends AnimatedWithChildren.default {
    constructor(valueIn) {
      super();
      var value = valueIn || {
        x: 0,
        y: 0
      }; // fixme: shouldn't need `: any`
      if (typeof value.x === 'number' && typeof value.y === 'number') {
        this.x = new AnimatedValue.default(value.x);
        this.y = new AnimatedValue.default(value.y);
      } else {
        (0, invariant.default)(value.x instanceof AnimatedValue.default && value.y instanceof AnimatedValue.default, "AnimatedValueXY must be initialized with an object of numbers or AnimatedValues.");
        this.x = value.x;
        this.y = value.y;
      }
      this._listeners = {};
    }

    /**
     * Directly set the value. This will stop any animations running on the value
     * and update all the bound properties.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#setvalue
     */
    setValue(value) {
      this.x.setValue(value.x);
      this.y.setValue(value.y);
    }

    /**
     * Sets an offset that is applied on top of whatever value is set, whether
     * via `setValue`, an animation, or `Animated.event`. Useful for compensating
     * things like the start of a pan gesture.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#setoffset
     */
    setOffset(offset) {
      this.x.setOffset(offset.x);
      this.y.setOffset(offset.y);
    }

    /**
     * Merges the offset value into the base value and resets the offset to zero.
     * The final output of the value is unchanged.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#flattenoffset
     */
    flattenOffset() {
      this.x.flattenOffset();
      this.y.flattenOffset();
    }

    /**
     * Sets the offset value to the base value, and resets the base value to
     * zero. The final output of the value is unchanged.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#extractoffset
     */
    extractOffset() {
      this.x.extractOffset();
      this.y.extractOffset();
    }
    __getValue() {
      return {
        x: this.x.__getValue(),
        y: this.y.__getValue()
      };
    }

    /**
     * Stops any animation and resets the value to its original.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#resetanimation
     */
    resetAnimation(callback) {
      this.x.resetAnimation();
      this.y.resetAnimation();
      callback && callback(this.__getValue());
    }

    /**
     * Stops any running animation or tracking. `callback` is invoked with the
     * final value after stopping the animation, which is useful for updating
     * state to match the animation position with layout.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#stopanimation
     */
    stopAnimation(callback) {
      this.x.stopAnimation();
      this.y.stopAnimation();
      callback && callback(this.__getValue());
    }

    /**
     * Adds an asynchronous listener to the value so you can observe updates from
     * animations.  This is useful because there is no way to synchronously read
     * the value because it might be driven natively.
     *
     * Returns a string that serves as an identifier for the listener.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#addlistener
     */
    addListener(callback) {
      var id = String(_uniqueId++);
      var jointCallback = _ref => {
        var number = _ref.value;
        callback(this.__getValue());
      };
      this._listeners[id] = {
        x: this.x.addListener(jointCallback),
        y: this.y.addListener(jointCallback)
      };
      return id;
    }

    /**
     * Unregister a listener. The `id` param shall match the identifier
     * previously returned by `addListener()`.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#removelistener
     */
    removeListener(id) {
      this.x.removeListener(this._listeners[id].x);
      this.y.removeListener(this._listeners[id].y);
      delete this._listeners[id];
    }

    /**
     * Remove all registered listeners.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#removealllisteners
     */
    removeAllListeners() {
      this.x.removeAllListeners();
      this.y.removeAllListeners();
      this._listeners = {};
    }

    /**
     * Converts `{x, y}` into `{left, top}` for use in style.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#getlayout
     */
    getLayout() {
      return {
        left: this.x,
        top: this.y
      };
    }

    /**
     * Converts `{x, y}` into a useable translation transform.
     *
     * See https://reactnative.dev/docs/animatedvaluexy.html#gettranslatetransform
     */
    getTranslateTransform() {
      return [{
        translateX: this.x
      }, {
        translateY: this.y
      }];
    }
  }
  var _default = AnimatedValueXY;
},227,[189,191,25]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _Animation = require(_dependencyMap[0]);
  var Animation = _interopDefault(_Animation);
  var _NativeAnimatedHelper = require(_dependencyMap[1]);
  class DecayAnimation extends Animation.default {
    constructor(config) {
      var _config$deceleration, _config$isInteraction, _config$iterations;
      super();
      this._deceleration = (_config$deceleration = config.deceleration) !== null && _config$deceleration !== undefined ? _config$deceleration : 0.998;
      this._velocity = config.velocity;
      this._useNativeDriver = (0, _NativeAnimatedHelper.shouldUseNativeDriver)(config);
      this.__isInteraction = (_config$isInteraction = config.isInteraction) !== null && _config$isInteraction !== undefined ? _config$isInteraction : !this._useNativeDriver;
      this.__iterations = (_config$iterations = config.iterations) !== null && _config$iterations !== undefined ? _config$iterations : 1;
    }
    __getNativeAnimationConfig() {
      return {
        type: 'decay',
        deceleration: this._deceleration,
        velocity: this._velocity,
        iterations: this.__iterations
      };
    }
    start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
      this.__active = true;
      this._lastValue = fromValue;
      this._fromValue = fromValue;
      this._onUpdate = onUpdate;
      this.__onEnd = onEnd;
      this._startTime = Date.now();
      if (this._useNativeDriver) {
        this.__startNativeAnimation(animatedValue);
      } else {
        this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
      }
    }
    onUpdate() {
      var now = Date.now();
      var value = this._fromValue + this._velocity / (1 - this._deceleration) * (1 - Math.exp(-(1 - this._deceleration) * (now - this._startTime)));
      this._onUpdate(value);
      if (Math.abs(this._lastValue - value) < 0.1) {
        this.__debouncedOnEnd({
          finished: true
        });
        return;
      }
      this._lastValue = value;
      if (this.__active) {
        this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
      }
    }
    stop() {
      super.stop();
      this.__active = false;
      global.cancelAnimationFrame(this._animationFrame);
      this.__debouncedOnEnd({
        finished: false
      });
    }
  }
  var _default = DecayAnimation;
},228,[229,193]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _NativeAnimatedHelper = require(_dependencyMap[0]);
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  var startNativeAnimationNextId = 1;

  // Important note: start() and stop() will only be called at most once.
  // Once an animation has been stopped or finished its course, it will
  // not be reused.
  class Animation {
    start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {}
    stop() {
      if (this.__nativeId) {
        NativeAnimatedHelper.default.API.stopAnimation(this.__nativeId);
      }
    }
    __getNativeAnimationConfig() {
      // Subclasses that have corresponding animation implementation done in native
      // should override this method
      throw new Error('This animation type cannot be offloaded to native');
    }
    // Helper function for subclasses to make sure onEnd is only called once.
    __debouncedOnEnd(result) {
      var onEnd = this.__onEnd;
      this.__onEnd = null;
      onEnd && onEnd(result);
    }
    __startNativeAnimation(animatedValue) {
      var startNativeAnimationWaitId = startNativeAnimationNextId + ":startAnimation";
      startNativeAnimationNextId += 1;
      NativeAnimatedHelper.default.API.setWaitingForIdentifier(startNativeAnimationWaitId);
      try {
        var config = this.__getNativeAnimationConfig();
        animatedValue.__makeNative(config.platformConfig);
        this.__nativeId = NativeAnimatedHelper.default.generateNewAnimationId();
        NativeAnimatedHelper.default.API.startAnimatingNode(this.__nativeId, animatedValue.__getNativeTag(), config,
        // $FlowFixMe[method-unbinding] added when improving typing for this parameters
        this.__debouncedOnEnd.bind(this));
      } catch (e) {
        throw e;
      } finally {
        NativeAnimatedHelper.default.API.unsetWaitingForIdentifier(startNativeAnimationWaitId);
      }
    }
  }
  var _default = Animation;
},229,[193]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _Animation = require(_dependencyMap[0]);
  var Animation = _interopDefault(_Animation);
  var _SpringConfig = require(_dependencyMap[1]);
  var SpringConfig = _interopDefault(_SpringConfig);
  var _fbjsLibInvariant = require(_dependencyMap[2]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _NativeAnimatedHelper = require(_dependencyMap[3]);
  require(_dependencyMap[4]);
  class SpringAnimation extends Animation.default {
    constructor(config) {
      var _config$overshootClam, _config$restDisplacem, _config$restSpeedThre, _config$velocity, _config$velocity2, _config$delay, _config$isInteraction, _config$iterations;
      super();
      this._overshootClamping = (_config$overshootClam = config.overshootClamping) !== null && _config$overshootClam !== undefined ? _config$overshootClam : false;
      this._restDisplacementThreshold = (_config$restDisplacem = config.restDisplacementThreshold) !== null && _config$restDisplacem !== undefined ? _config$restDisplacem : 0.001;
      this._restSpeedThreshold = (_config$restSpeedThre = config.restSpeedThreshold) !== null && _config$restSpeedThre !== undefined ? _config$restSpeedThre : 0.001;
      this._initialVelocity = (_config$velocity = config.velocity) !== null && _config$velocity !== undefined ? _config$velocity : 0;
      this._lastVelocity = (_config$velocity2 = config.velocity) !== null && _config$velocity2 !== undefined ? _config$velocity2 : 0;
      this._toValue = config.toValue;
      this._delay = (_config$delay = config.delay) !== null && _config$delay !== undefined ? _config$delay : 0;
      this._useNativeDriver = (0, _NativeAnimatedHelper.shouldUseNativeDriver)(config);
      this._platformConfig = config.platformConfig;
      this.__isInteraction = (_config$isInteraction = config.isInteraction) !== null && _config$isInteraction !== undefined ? _config$isInteraction : !this._useNativeDriver;
      this.__iterations = (_config$iterations = config.iterations) !== null && _config$iterations !== undefined ? _config$iterations : 1;
      if (config.stiffness !== undefined || config.damping !== undefined || config.mass !== undefined) {
        var _config$stiffness, _config$damping, _config$mass;
        (0, invariant.default)(config.bounciness === undefined && config.speed === undefined && config.tension === undefined && config.friction === undefined, 'You can define one of bounciness/speed, tension/friction, or stiffness/damping/mass, but not more than one');
        this._stiffness = (_config$stiffness = config.stiffness) !== null && _config$stiffness !== undefined ? _config$stiffness : 100;
        this._damping = (_config$damping = config.damping) !== null && _config$damping !== undefined ? _config$damping : 10;
        this._mass = (_config$mass = config.mass) !== null && _config$mass !== undefined ? _config$mass : 1;
      } else if (config.bounciness !== undefined || config.speed !== undefined) {
        var _config$bounciness, _config$speed;
        // Convert the origami bounciness/speed values to stiffness/damping
        // We assume mass is 1.
        (0, invariant.default)(config.tension === undefined && config.friction === undefined && config.stiffness === undefined && config.damping === undefined && config.mass === undefined, 'You can define one of bounciness/speed, tension/friction, or stiffness/damping/mass, but not more than one');
        var springConfig = SpringConfig.default.fromBouncinessAndSpeed((_config$bounciness = config.bounciness) !== null && _config$bounciness !== undefined ? _config$bounciness : 8, (_config$speed = config.speed) !== null && _config$speed !== undefined ? _config$speed : 12);
        this._stiffness = springConfig.stiffness;
        this._damping = springConfig.damping;
        this._mass = 1;
      } else {
        var _config$tension, _config$friction;
        // Convert the origami tension/friction values to stiffness/damping
        // We assume mass is 1.
        var _springConfig = SpringConfig.default.fromOrigamiTensionAndFriction((_config$tension = config.tension) !== null && _config$tension !== undefined ? _config$tension : 40, (_config$friction = config.friction) !== null && _config$friction !== undefined ? _config$friction : 7);
        this._stiffness = _springConfig.stiffness;
        this._damping = _springConfig.damping;
        this._mass = 1;
      }
      (0, invariant.default)(this._stiffness > 0, 'Stiffness value must be greater than 0');
      (0, invariant.default)(this._damping > 0, 'Damping value must be greater than 0');
      (0, invariant.default)(this._mass > 0, 'Mass value must be greater than 0');
    }
    __getNativeAnimationConfig() {
      var _this$_initialVelocit;
      return {
        type: 'spring',
        overshootClamping: this._overshootClamping,
        restDisplacementThreshold: this._restDisplacementThreshold,
        restSpeedThreshold: this._restSpeedThreshold,
        stiffness: this._stiffness,
        damping: this._damping,
        mass: this._mass,
        initialVelocity: (_this$_initialVelocit = this._initialVelocity) !== null && _this$_initialVelocit !== undefined ? _this$_initialVelocit : this._lastVelocity,
        toValue: this._toValue,
        iterations: this.__iterations,
        platformConfig: this._platformConfig
      };
    }
    start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
      this.__active = true;
      this._startPosition = fromValue;
      this._lastPosition = this._startPosition;
      this._onUpdate = onUpdate;
      this.__onEnd = onEnd;
      this._lastTime = Date.now();
      this._frameTime = 0.0;
      if (previousAnimation instanceof SpringAnimation) {
        var internalState = previousAnimation.getInternalState();
        this._lastPosition = internalState.lastPosition;
        this._lastVelocity = internalState.lastVelocity;
        // Set the initial velocity to the last velocity
        this._initialVelocity = this._lastVelocity;
        this._lastTime = internalState.lastTime;
      }
      var start = () => {
        if (this._useNativeDriver) {
          this.__startNativeAnimation(animatedValue);
        } else {
          this.onUpdate();
        }
      };

      //  If this._delay is more than 0, we start after the timeout.
      if (this._delay) {
        this._timeout = setTimeout(start, this._delay);
      } else {
        start();
      }
    }
    getInternalState() {
      return {
        lastPosition: this._lastPosition,
        lastVelocity: this._lastVelocity,
        lastTime: this._lastTime
      };
    }

    /**
     * This spring model is based off of a damped harmonic oscillator
     * (https://en.wikipedia.org/wiki/Harmonic_oscillator#Damped_harmonic_oscillator).
     *
     * We use the closed form of the second order differential equation:
     *
     * x'' + (2ζ⍵_0)x' + ⍵^2x = 0
     *
     * where
     *    ⍵_0 = √(k / m) (undamped angular frequency of the oscillator),
     *    ζ = c / 2√mk (damping ratio),
     *    c = damping constant
     *    k = stiffness
     *    m = mass
     *
     * The derivation of the closed form is described in detail here:
     * http://planetmath.org/sites/default/files/texpdf/39745.pdf
     *
     * This algorithm happens to match the algorithm used by CASpringAnimation,
     * a QuartzCore (iOS) API that creates spring animations.
     */
    onUpdate() {
      // If for some reason we lost a lot of frames (e.g. process large payload or
      // stopped in the debugger), we only advance by 4 frames worth of
      // computation and will continue on the next frame. It's better to have it
      // running at faster speed than jumping to the end.
      var MAX_STEPS = 64;
      var now = Date.now();
      if (now > this._lastTime + MAX_STEPS) {
        now = this._lastTime + MAX_STEPS;
      }
      var deltaTime = (now - this._lastTime) / 1000;
      this._frameTime += deltaTime;
      var c = this._damping;
      var m = this._mass;
      var k = this._stiffness;
      var v0 = -this._initialVelocity;
      var zeta = c / (2 * Math.sqrt(k * m)); // damping ratio
      var omega0 = Math.sqrt(k / m); // undamped angular frequency of the oscillator (rad/ms)
      var omega1 = omega0 * Math.sqrt(1.0 - zeta * zeta); // exponential decay
      var x0 = this._toValue - this._startPosition; // calculate the oscillation from x0 = 1 to x = 0

      var position = 0.0;
      var velocity = 0.0;
      var t = this._frameTime;
      if (zeta < 1) {
        // Under damped
        var envelope = Math.exp(-zeta * omega0 * t);
        position = this._toValue - envelope * ((v0 + zeta * omega0 * x0) / omega1 * Math.sin(omega1 * t) + x0 * Math.cos(omega1 * t));
        // This looks crazy -- it's actually just the derivative of the
        // oscillation function
        velocity = zeta * omega0 * envelope * (Math.sin(omega1 * t) * (v0 + zeta * omega0 * x0) / omega1 + x0 * Math.cos(omega1 * t)) - envelope * (Math.cos(omega1 * t) * (v0 + zeta * omega0 * x0) - omega1 * x0 * Math.sin(omega1 * t));
      } else {
        // Critically damped
        var _envelope = Math.exp(-omega0 * t);
        position = this._toValue - _envelope * (x0 + (v0 + omega0 * x0) * t);
        velocity = _envelope * (v0 * (t * omega0 - 1) + t * x0 * (omega0 * omega0));
      }
      this._lastTime = now;
      this._lastPosition = position;
      this._lastVelocity = velocity;
      this._onUpdate(position);
      if (!this.__active) {
        // a listener might have stopped us in _onUpdate
        return;
      }

      // Conditions for stopping the spring animation
      var isOvershooting = false;
      if (this._overshootClamping && this._stiffness !== 0) {
        if (this._startPosition < this._toValue) {
          isOvershooting = position > this._toValue;
        } else {
          isOvershooting = position < this._toValue;
        }
      }
      var isVelocity = Math.abs(velocity) <= this._restSpeedThreshold;
      var isDisplacement = true;
      if (this._stiffness !== 0) {
        isDisplacement = Math.abs(this._toValue - position) <= this._restDisplacementThreshold;
      }
      if (isOvershooting || isVelocity && isDisplacement) {
        if (this._stiffness !== 0) {
          // Ensure that we end up with a round value
          this._lastPosition = this._toValue;
          this._lastVelocity = 0;
          this._onUpdate(this._toValue);
        }
        this.__debouncedOnEnd({
          finished: true
        });
        return;
      }
      // $FlowFixMe[method-unbinding] added when improving typing for this parameters
      this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
    }
    stop() {
      super.stop();
      this.__active = false;
      clearTimeout(this._timeout);
      global.cancelAnimationFrame(this._animationFrame);
      this.__debouncedOnEnd({
        finished: false
      });
    }
  }
  var _default = SpringAnimation;
},230,[229,231,25,193,232]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  function stiffnessFromOrigamiValue(oValue) {
    return (oValue - 30) * 3.62 + 194;
  }
  function dampingFromOrigamiValue(oValue) {
    return (oValue - 8) * 3 + 25;
  }
  function fromOrigamiTensionAndFriction(tension, friction) {
    return {
      stiffness: stiffnessFromOrigamiValue(tension),
      damping: dampingFromOrigamiValue(friction)
    };
  }
  function fromBouncinessAndSpeed(bounciness, speed) {
    function normalize(value, startValue, endValue) {
      return (value - startValue) / (endValue - startValue);
    }
    function projectNormal(n, start, end) {
      return start + n * (end - start);
    }
    function linearInterpolation(t, start, end) {
      return t * end + (1 - t) * start;
    }
    function quadraticOutInterpolation(t, start, end) {
      return linearInterpolation(2 * t - t * t, start, end);
    }
    function b3Friction1(x) {
      return 0.0007 * Math.pow(x, 3) - 0.031 * Math.pow(x, 2) + 0.64 * x + 1.28;
    }
    function b3Friction2(x) {
      return 0.000044 * Math.pow(x, 3) - 0.006 * Math.pow(x, 2) + 0.36 * x + 2;
    }
    function b3Friction3(x) {
      return 0.00000045 * Math.pow(x, 3) - 0.000332 * Math.pow(x, 2) + 0.1078 * x + 5.84;
    }
    function b3Nobounce(tension) {
      if (tension <= 18) {
        return b3Friction1(tension);
      } else if (tension > 18 && tension <= 44) {
        return b3Friction2(tension);
      } else {
        return b3Friction3(tension);
      }
    }
    var b = normalize(bounciness / 1.7, 0, 20);
    b = projectNormal(b, 0, 0.8);
    var s = normalize(speed / 1.7, 0, 20);
    var bouncyTension = projectNormal(s, 0.5, 200);
    var bouncyFriction = quadraticOutInterpolation(b, b3Nobounce(bouncyTension), 0.01);
    return {
      stiffness: stiffnessFromOrigamiValue(bouncyTension),
      damping: dampingFromOrigamiValue(bouncyFriction)
    };
  }
  var _default = {
    fromOrigamiTensionAndFriction,
    fromBouncinessAndSpeed
  };
},231,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return AnimatedColor;
    }
  });
  var _AnimatedValue = require(_dependencyMap[0]);
  var AnimatedValue = _interopDefault(_AnimatedValue);
  var _AnimatedWithChildren = require(_dependencyMap[1]);
  var AnimatedWithChildren = _interopDefault(_AnimatedWithChildren);
  var _reactNativeNormalizeColors = require(_dependencyMap[2]);
  var normalizeColor = _interopDefault(_reactNativeNormalizeColors);
  var _NativeAnimatedHelper = require(_dependencyMap[3]);
  var NativeAnimatedHelper = _interopDefault(_NativeAnimatedHelper);
  var NativeAnimatedAPI = NativeAnimatedHelper.default.API;
  var defaultColor = {
    r: 0,
    g: 0,
    b: 0,
    a: 1.0
  };
  var _uniqueId = 1;
  var processColorObject = color => {
    return color;
  };

  /* eslint no-bitwise: 0 */
  function processColor(color) {
    if (color === undefined || color === null) {
      return null;
    }
    if (isRgbaValue(color)) {
      // $FlowIgnore[incompatible-cast] - Type is verified above
      return color;
    }
    var normalizedColor = (0, normalizeColor.default)(
    // $FlowIgnore[incompatible-cast] - Type is verified above
    color);
    if (normalizedColor === undefined || normalizedColor === null) {
      return null;
    }
    if (typeof normalizedColor === 'object') {
      var processedColorObj = processColorObject(normalizedColor);
      if (processedColorObj != null) {
        return processedColorObj;
      }
    } else if (typeof normalizedColor === 'number') {
      var r = (normalizedColor & 0xff000000) >>> 24;
      var g = (normalizedColor & 0x00ff0000) >>> 16;
      var b = (normalizedColor & 0x0000ff00) >>> 8;
      var a = (normalizedColor & 0x000000ff) / 255;
      return {
        r,
        g,
        b,
        a
      };
    }
    return null;
  }
  function isRgbaValue(value) {
    return value && typeof value.r === 'number' && typeof value.g === 'number' && typeof value.b === 'number' && typeof value.a === 'number';
  }
  function isRgbaAnimatedValue(value) {
    return value && value.r instanceof AnimatedValue.default && value.g instanceof AnimatedValue.default && value.b instanceof AnimatedValue.default && value.a instanceof AnimatedValue.default;
  }
  class AnimatedColor extends AnimatedWithChildren.default {
    constructor(valueIn, config) {
      super();
      this._listeners = {};
      var value = valueIn !== null && valueIn !== undefined ? valueIn : defaultColor;
      if (isRgbaAnimatedValue(value)) {
        // $FlowIgnore[incompatible-cast] - Type is verified above
        var rgbaAnimatedValue = value;
        this.r = rgbaAnimatedValue.r;
        this.g = rgbaAnimatedValue.g;
        this.b = rgbaAnimatedValue.b;
        this.a = rgbaAnimatedValue.a;
      } else {
        var _processColor;
        var processedColor =
        // $FlowIgnore[incompatible-cast] - Type is verified above
        (_processColor = processColor(value)) !== null && _processColor !== undefined ? _processColor : defaultColor;
        var initColor = defaultColor;
        if (isRgbaValue(processedColor)) {
          // $FlowIgnore[incompatible-cast] - Type is verified above
          initColor = processedColor;
        } else {
          // $FlowIgnore[incompatible-cast] - Type is verified above
          this.nativeColor = processedColor;
        }
        this.r = new AnimatedValue.default(initColor.r);
        this.g = new AnimatedValue.default(initColor.g);
        this.b = new AnimatedValue.default(initColor.b);
        this.a = new AnimatedValue.default(initColor.a);
      }
      if (this.nativeColor || config && config.useNativeDriver) {
        this.__makeNative();
      }
    }

    /**
     * Directly set the value. This will stop any animations running on the value
     * and update all the bound properties.
     */
    setValue(value) {
      var _processColor2;
      var shouldUpdateNodeConfig = false;
      if (this.__isNative) {
        var nativeTag = this.__getNativeTag();
        NativeAnimatedAPI.setWaitingForIdentifier(nativeTag.toString());
      }
      var processedColor = (_processColor2 = processColor(value)) !== null && _processColor2 !== undefined ? _processColor2 : defaultColor;
      if (isRgbaValue(processedColor)) {
        // $FlowIgnore[incompatible-type] - Type is verified above
        var rgbaValue = processedColor;
        this.r.setValue(rgbaValue.r);
        this.g.setValue(rgbaValue.g);
        this.b.setValue(rgbaValue.b);
        this.a.setValue(rgbaValue.a);
        if (this.nativeColor != null) {
          this.nativeColor = null;
          shouldUpdateNodeConfig = true;
        }
      } else {
        // $FlowIgnore[incompatible-type] - Type is verified above
        var nativeColor = processedColor;
        if (this.nativeColor !== nativeColor) {
          this.nativeColor = nativeColor;
          shouldUpdateNodeConfig = true;
        }
      }
      if (this.__isNative) {
        var _nativeTag = this.__getNativeTag();
        if (shouldUpdateNodeConfig) {
          NativeAnimatedAPI.updateAnimatedNodeConfig(_nativeTag, this.__getNativeConfig());
        }
        NativeAnimatedAPI.unsetWaitingForIdentifier(_nativeTag.toString());
      }
    }

    /**
     * Sets an offset that is applied on top of whatever value is set, whether
     * via `setValue`, an animation, or `Animated.event`. Useful for compensating
     * things like the start of a pan gesture.
     */
    setOffset(offset) {
      this.r.setOffset(offset.r);
      this.g.setOffset(offset.g);
      this.b.setOffset(offset.b);
      this.a.setOffset(offset.a);
    }

    /**
     * Merges the offset value into the base value and resets the offset to zero.
     * The final output of the value is unchanged.
     */
    flattenOffset() {
      this.r.flattenOffset();
      this.g.flattenOffset();
      this.b.flattenOffset();
      this.a.flattenOffset();
    }

    /**
     * Sets the offset value to the base value, and resets the base value to
     * zero. The final output of the value is unchanged.
     */
    extractOffset() {
      this.r.extractOffset();
      this.g.extractOffset();
      this.b.extractOffset();
      this.a.extractOffset();
    }

    /**
     * Adds an asynchronous listener to the value so you can observe updates from
     * animations.  This is useful because there is no way to synchronously read
     * the value because it might be driven natively.
     *
     * Returns a string that serves as an identifier for the listener.
     */
    addListener(callback) {
      var id = String(_uniqueId++);
      var jointCallback = _ref => {
        var number = _ref.value;
        callback(this.__getValue());
      };
      this._listeners[id] = {
        r: this.r.addListener(jointCallback),
        g: this.g.addListener(jointCallback),
        b: this.b.addListener(jointCallback),
        a: this.a.addListener(jointCallback)
      };
      return id;
    }

    /**
     * Unregister a listener. The `id` param shall match the identifier
     * previously returned by `addListener()`.
     */
    removeListener(id) {
      this.r.removeListener(this._listeners[id].r);
      this.g.removeListener(this._listeners[id].g);
      this.b.removeListener(this._listeners[id].b);
      this.a.removeListener(this._listeners[id].a);
      delete this._listeners[id];
    }

    /**
     * Remove all registered listeners.
     */
    removeAllListeners() {
      this.r.removeAllListeners();
      this.g.removeAllListeners();
      this.b.removeAllListeners();
      this.a.removeAllListeners();
      this._listeners = {};
    }

    /**
     * Stops any running animation or tracking. `callback` is invoked with the
     * final value after stopping the animation, which is useful for updating
     * state to match the animation position with layout.
     */
    stopAnimation(callback) {
      this.r.stopAnimation();
      this.g.stopAnimation();
      this.b.stopAnimation();
      this.a.stopAnimation();
      callback && callback(this.__getValue());
    }

    /**
     * Stops any animation and resets the value to its original.
     */
    resetAnimation(callback) {
      this.r.resetAnimation();
      this.g.resetAnimation();
      this.b.resetAnimation();
      this.a.resetAnimation();
      callback && callback(this.__getValue());
    }
    __getValue() {
      if (this.nativeColor != null) {
        return this.nativeColor;
      } else {
        return "rgba(" + this.r.__getValue() + ", " + this.g.__getValue() + ", " + this.b.__getValue() + ", " + this.a.__getValue() + ")";
      }
    }
    __attach() {
      this.r.__addChild(this);
      this.g.__addChild(this);
      this.b.__addChild(this);
      this.a.__addChild(this);
      super.__attach();
    }
    __detach() {
      this.r.__removeChild(this);
      this.g.__removeChild(this);
      this.b.__removeChild(this);
      this.a.__removeChild(this);
      super.__detach();
    }
    __makeNative(platformConfig) {
      this.r.__makeNative(platformConfig);
      this.g.__makeNative(platformConfig);
      this.b.__makeNative(platformConfig);
      this.a.__makeNative(platformConfig);
      super.__makeNative(platformConfig);
    }
    __getNativeConfig() {
      return {
        type: 'color',
        r: this.r.__getNativeTag(),
        g: this.g.__getNativeTag(),
        b: this.b.__getNativeTag(),
        a: this.a.__getNativeTag(),
        nativeColor: this.nativeColor
      };
    }
  }
},232,[189,191,52,193]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  require(_dependencyMap[0]);
  require(_dependencyMap[1]);
  require(_dependencyMap[2]);
  var _exportsEasing = require(_dependencyMap[3]);
  var Easing = _interopDefault(_exportsEasing);
  var _Animation = require(_dependencyMap[4]);
  var Animation = _interopDefault(_Animation);
  var _NativeAnimatedHelper = require(_dependencyMap[5]);
  require(_dependencyMap[6]);
  var _easeInOut;
  function easeInOut() {
    if (!_easeInOut) {
      _easeInOut = Easing.default.inOut(Easing.default.ease);
    }
    return _easeInOut;
  }
  class TimingAnimation extends Animation.default {
    constructor(config) {
      var _config$easing, _config$duration, _config$delay, _config$iterations, _config$isInteraction;
      super();
      this._toValue = config.toValue;
      this._easing = (_config$easing = config.easing) !== null && _config$easing !== undefined ? _config$easing : easeInOut();
      this._duration = (_config$duration = config.duration) !== null && _config$duration !== undefined ? _config$duration : 500;
      this._delay = (_config$delay = config.delay) !== null && _config$delay !== undefined ? _config$delay : 0;
      this.__iterations = (_config$iterations = config.iterations) !== null && _config$iterations !== undefined ? _config$iterations : 1;
      this._useNativeDriver = (0, _NativeAnimatedHelper.shouldUseNativeDriver)(config);
      this._platformConfig = config.platformConfig;
      this.__isInteraction = (_config$isInteraction = config.isInteraction) !== null && _config$isInteraction !== undefined ? _config$isInteraction : !this._useNativeDriver;
    }
    __getNativeAnimationConfig() {
      var frameDuration = 16.666666666666668;
      var frames = [];
      var numFrames = Math.round(this._duration / frameDuration);
      for (var frame = 0; frame < numFrames; frame++) {
        frames.push(this._easing(frame / numFrames));
      }
      frames.push(this._easing(1));
      return {
        type: 'frames',
        frames,
        toValue: this._toValue,
        iterations: this.__iterations,
        platformConfig: this._platformConfig
      };
    }
    start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
      this.__active = true;
      this._fromValue = fromValue;
      this._onUpdate = onUpdate;
      this.__onEnd = onEnd;
      var start = () => {
        // Animations that sometimes have 0 duration and sometimes do not
        // still need to use the native driver when duration is 0 so as to
        // not cause intermixed JS and native animations.
        if (this._duration === 0 && !this._useNativeDriver) {
          this._onUpdate(this._toValue);
          this.__debouncedOnEnd({
            finished: true
          });
        } else {
          this._startTime = Date.now();
          if (this._useNativeDriver) {
            this.__startNativeAnimation(animatedValue);
          } else {
            this._animationFrame = requestAnimationFrame(
            // $FlowFixMe[method-unbinding] added when improving typing for this parameters
            this.onUpdate.bind(this));
          }
        }
      };
      if (this._delay) {
        this._timeout = setTimeout(start, this._delay);
      } else {
        start();
      }
    }
    onUpdate() {
      var now = Date.now();
      if (now >= this._startTime + this._duration) {
        if (this._duration === 0) {
          this._onUpdate(this._toValue);
        } else {
          this._onUpdate(this._fromValue + this._easing(1) * (this._toValue - this._fromValue));
        }
        this.__debouncedOnEnd({
          finished: true
        });
        return;
      }
      this._onUpdate(this._fromValue + this._easing((now - this._startTime) / this._duration) * (this._toValue - this._fromValue));
      if (this.__active) {
        // $FlowFixMe[method-unbinding] added when improving typing for this parameters
        this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
      }
    }
    stop() {
      super.stop();
      this.__active = false;
      clearTimeout(this._timeout);
      global.cancelAnimationFrame(this._animationFrame);
      this.__debouncedOnEnd({
        finished: false
      });
    }
  }
  var _default = TimingAnimation;
},233,[189,227,190,234,229,193,232]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativeAnimatedEasing = require(_dependencyMap[0]);
  var Easing = _interopDefault(_vendorReactNativeAnimatedEasing);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var _default = Easing.default;
},234,[235]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _bezier2 = require(_dependencyMap[0]);
  var _bezier = _interopDefault(_bezier2);
  var ease;

  /**
   * The `Easing` module implements common easing functions. This module is used
   * by [Animate.timing()](docs/animate.html#timing) to convey physically
   * believable motion in animations.
   *
   * You can find a visualization of some common easing functions at
   * http://easings.net/
   *
   * ### Predefined animations
   *
   * The `Easing` module provides several predefined animations through the
   * following methods:
   *
   * - [`back`](docs/easing.html#back) provides a simple animation where the
   *   object goes slightly back before moving forward
   * - [`bounce`](docs/easing.html#bounce) provides a bouncing animation
   * - [`ease`](docs/easing.html#ease) provides a simple inertial animation
   * - [`elastic`](docs/easing.html#elastic) provides a simple spring interaction
   *
   * ### Standard functions
   *
   * Three standard easing functions are provided:
   *
   * - [`linear`](docs/easing.html#linear)
   * - [`quad`](docs/easing.html#quad)
   * - [`cubic`](docs/easing.html#cubic)
   *
   * The [`poly`](docs/easing.html#poly) function can be used to implement
   * quartic, quintic, and other higher power functions.
   *
   * ### Additional functions
   *
   * Additional mathematical functions are provided by the following methods:
   *
   * - [`bezier`](docs/easing.html#bezier) provides a cubic bezier curve
   * - [`circle`](docs/easing.html#circle) provides a circular function
   * - [`sin`](docs/easing.html#sin) provides a sinusoidal function
   * - [`exp`](docs/easing.html#exp) provides an exponential function
   *
   * The following helpers are used to modify other easing functions.
   *
   * - [`in`](docs/easing.html#in) runs an easing function forwards
   * - [`inOut`](docs/easing.html#inout) makes any easing function symmetrical
   * - [`out`](docs/easing.html#out) runs an easing function backwards
   */
  class Easing {
    /**
     * A stepping function, returns 1 for any positive value of `n`.
     */
    static step0(n) {
      return n > 0 ? 1 : 0;
    }

    /**
     * A stepping function, returns 1 if `n` is greater than or equal to 1.
     */
    static step1(n) {
      return n >= 1 ? 1 : 0;
    }

    /**
     * A linear function, `f(t) = t`. Position correlates to elapsed time one to
     * one.
     *
     * http://cubic-bezier.com/#0,0,1,1
     */
    static linear(t) {
      return t;
    }

    /**
     * A simple inertial interaction, similar to an object slowly accelerating to
     * speed.
     *
     * http://cubic-bezier.com/#.42,0,1,1
     */
    static ease(t) {
      if (!ease) {
        ease = Easing.bezier(0.42, 0, 1, 1);
      }
      return ease(t);
    }

    /**
     * A quadratic function, `f(t) = t * t`. Position equals the square of elapsed
     * time.
     *
     * http://easings.net/#easeInQuad
     */
    static quad(t) {
      return t * t;
    }

    /**
     * A cubic function, `f(t) = t * t * t`. Position equals the cube of elapsed
     * time.
     *
     * http://easings.net/#easeInCubic
     */
    static cubic(t) {
      return t * t * t;
    }

    /**
     * A power function. Position is equal to the Nth power of elapsed time.
     *
     * n = 4: http://easings.net/#easeInQuart
     * n = 5: http://easings.net/#easeInQuint
     */
    static poly(n) {
      return t => Math.pow(t, n);
    }

    /**
     * A sinusoidal function.
     *
     * http://easings.net/#easeInSine
     */
    static sin(t) {
      return 1 - Math.cos(t * Math.PI / 2);
    }

    /**
     * A circular function.
     *
     * http://easings.net/#easeInCirc
     */
    static circle(t) {
      return 1 - Math.sqrt(1 - t * t);
    }

    /**
     * An exponential function.
     *
     * http://easings.net/#easeInExpo
     */
    static exp(t) {
      return Math.pow(2, 10 * (t - 1));
    }

    /**
     * A simple elastic interaction, similar to a spring oscillating back and
     * forth.
     *
     * Default bounciness is 1, which overshoots a little bit once. 0 bounciness
     * doesn't overshoot at all, and bounciness of N > 1 will overshoot about N
     * times.
     *
     * http://easings.net/#easeInElastic
     */
    static elastic(bounciness) {
      if (bounciness === undefined) {
        bounciness = 1;
      }
      var p = bounciness * Math.PI;
      return t => 1 - Math.pow(Math.cos(t * Math.PI / 2), 3) * Math.cos(t * p);
    }

    /**
     * Use with `Animated.parallel()` to create a simple effect where the object
     * animates back slightly as the animation starts.
     *
     * Wolfram Plot:
     *
     * - http://tiny.cc/back_default (s = 1.70158, default)
     */
    static back(s) {
      if (s === undefined) {
        s = 1.70158;
      }
      return t => t * t * ((s + 1) * t - s);
    }

    /**
     * Provides a simple bouncing effect.
     *
     * http://easings.net/#easeInBounce
     */
    static bounce(t) {
      if (t < 0.36363636363636365) {
        return 7.5625 * t * t;
      }
      if (t < 0.7272727272727273) {
        var _t = t - 0.5454545454545454;
        return 7.5625 * _t * _t + 0.75;
      }
      if (t < 0.9090909090909091) {
        var _t2 = t - 0.8181818181818182;
        return 7.5625 * _t2 * _t2 + 0.9375;
      }
      var t2 = t - 0.9545454545454546;
      return 7.5625 * t2 * t2 + 0.984375;
    }

    /**
     * Provides a cubic bezier curve, equivalent to CSS Transitions'
     * `transition-timing-function`.
     *
     * A useful tool to visualize cubic bezier curves can be found at
     * http://cubic-bezier.com/
     */
    static bezier(x1, y1, x2, y2) {
      return (0, _bezier.default)(x1, y1, x2, y2);
    }

    /**
     * Runs an easing function forwards.
     */
    static in(easing) {
      return easing;
    }

    /**
     * Runs an easing function backwards.
     */
    static out(easing) {
      return t => 1 - easing(1 - t);
    }

    /**
     * Makes any easing function symmetrical. The easing function will run
     * forwards for half of the duration, then backwards for the rest of the
     * duration.
     */
    static inOut(easing) {
      return t => {
        if (t < 0.5) {
          return easing(t * 2) / 2;
        }
        return 1 - easing((1 - t) * 2) / 2;
      };
    }
  }
  var _default = Easing;
},235,[236]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Portions Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  /**
   * BezierEasing - use bezier curve for transition easing function
   * https://github.com/gre/bezier-easing
   * @copyright 2014-2015 Gaëtan Renaudeau. MIT License.
   */

  'use strict';

  // These values are established by empiricism with tests (tradeoff: performance VS precision)
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return bezier;
    }
  });
  var NEWTON_ITERATIONS = 4;
  var NEWTON_MIN_SLOPE = 0.001;
  var SUBDIVISION_PRECISION = 0.0000001;
  var SUBDIVISION_MAX_ITERATIONS = 10;
  var kSplineTableSize = 11;
  var kSampleStepSize = 0.1;
  var float32ArraySupported = typeof Float32Array === 'function';
  function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }
  function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }
  function C(aA1) {
    return 3.0 * aA1;
  }

  // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  }

  // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }
  function binarySubdivide(aX, _aA, _aB, mX1, mX2) {
    var currentX,
      currentT,
      i = 0,
      aA = _aA,
      aB = _aB;
    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
    return currentT;
  }
  function newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {
    var aGuessT = _aGuessT;
    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);
      if (currentSlope === 0.0) {
        return aGuessT;
      }
      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  }
  function bezier(mX1, mY1, mX2, mY2) {
    if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {
      throw new Error('bezier x values must be in [0, 1] range');
    }

    // Precompute samples table
    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
    if (mX1 !== mY1 || mX2 !== mY2) {
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }
    function getTForX(aX) {
      var intervalStart = 0.0;
      var currentSample = 1;
      var lastSample = 10;
      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }
      --currentSample;

      // Interpolate to provide an initial guess for t
      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);
      if (initialSlope >= NEWTON_MIN_SLOPE) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }
    }
    return function BezierEasing(x) {
      if (mX1 === mY1 && mX2 === mY2) {
        return x; // linear
      }
      // Because JavaScript number are imprecise, we should guarantee the extremes are right.
      if (x === 0) {
        return 0;
      }
      if (x === 1) {
        return 1;
      }
      return calcBezier(getTForX(x), mY1, mY2);
    };
  }
  ;
},236,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _modulesCanUseDom = require(_dependencyMap[0]);
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  function getQuery() {
    return canUseDOM.default && window.matchMedia != null ? window.matchMedia('(prefers-color-scheme: dark)') : null;
  }
  var query = getQuery();
  var listenerMapping = new WeakMap();
  var Appearance = {
    getColorScheme() {
      return query && query.matches ? 'dark' : 'light';
    },
    addChangeListener(listener) {
      var mappedListener = listenerMapping.get(listener);
      if (!mappedListener) {
        mappedListener = _ref => {
          var matches = _ref.matches;
          listener({
            colorScheme: matches ? 'dark' : 'light'
          });
        };
        listenerMapping.set(listener, mappedListener);
      }
      if (query) {
        query.addListener(mappedListener);
      }
      function remove() {
        var mappedListener = listenerMapping.get(listener);
        if (query && mappedListener) {
          query.removeListener(mappedListener);
        }
        listenerMapping.delete(listener);
      }
      return {
        remove
      };
    }
  };
  var _default = Appearance;
},237,[40]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return AppState;
    }
  });
  var _fbjsLibInvariant = require(_dependencyMap[0]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _vendorReactNativeVendorEmitterEventEmitter = require(_dependencyMap[1]);
  var EventEmitter = _interopDefault(_vendorReactNativeVendorEmitterEventEmitter);
  var _modulesCanUseDom = require(_dependencyMap[2]);
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  // Android 4.4 browser
  var isPrefixed = canUseDOM.default && !document.hasOwnProperty('hidden') && document.hasOwnProperty('webkitHidden');
  var EVENT_TYPES = ['change', 'memoryWarning'];
  var VISIBILITY_CHANGE_EVENT = isPrefixed ? 'webkitvisibilitychange' : 'visibilitychange';
  var VISIBILITY_STATE_PROPERTY = isPrefixed ? 'webkitVisibilityState' : 'visibilityState';
  var AppStates = {
    BACKGROUND: 'background',
    ACTIVE: 'active'
  };
  var changeEmitter = null;
  class AppState {
    static get currentState() {
      if (!AppState.isAvailable) {
        return AppStates.ACTIVE;
      }
      switch (document[VISIBILITY_STATE_PROPERTY]) {
        case 'hidden':
        case 'prerender':
        case 'unloaded':
          return AppStates.BACKGROUND;
        default:
          return AppStates.ACTIVE;
      }
    }
    static addEventListener(type, handler) {
      if (AppState.isAvailable) {
        (0, invariant.default)(EVENT_TYPES.indexOf(type) !== -1, 'Trying to subscribe to unknown event: "%s"', type);
        if (type === 'change') {
          if (!changeEmitter) {
            changeEmitter = new EventEmitter.default();
            document.addEventListener(VISIBILITY_CHANGE_EVENT, () => {
              if (changeEmitter) {
                changeEmitter.emit('change', AppState.currentState);
              }
            }, false);
          }
          return changeEmitter.addListener(type, handler);
        }
      }
    }
  }
  AppState.isAvailable = canUseDOM.default && !!document[VISIBILITY_STATE_PROPERTY];
},238,[25,171,40]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  function emptyFunction() {}
  var BackHandler = {
    exitApp: emptyFunction,
    addEventListener: () => ({
      remove: emptyFunction
    }),
    removeEventListener: emptyFunction
  };
  var _default = BackHandler;
},239,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return Clipboard;
    }
  });
  var clipboardAvailable;
  class Clipboard {
    static isAvailable() {
      if (clipboardAvailable === undefined) {
        clipboardAvailable = typeof document.queryCommandSupported === 'function' && document.queryCommandSupported('copy');
      }
      return clipboardAvailable;
    }
    static getString() {
      return Promise.resolve('');
    }
    static setString(text) {
      var success = false;
      var body = document.body;
      if (body) {
        // add the text to a hidden node
        var node = document.createElement('span');
        node.textContent = text;
        node.style.opacity = '0';
        node.style.position = 'absolute';
        node.style.whiteSpace = 'pre-wrap';
        node.style.userSelect = 'auto';
        body.appendChild(node);

        // select the text
        var selection = window.getSelection();
        selection.removeAllRanges();
        var range = document.createRange();
        range.selectNodeContents(node);
        selection.addRange(range);

        // attempt to copy
        try {
          document.execCommand('copy');
          success = true;
        } catch (e) {}

        // remove selection and node
        selection.removeAllRanges();
        body.removeChild(node);
      }
      return success;
    }
  }
},240,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var I18nManager = {
    allowRTL() {
      return;
    },
    forceRTL() {
      return;
    },
    getConstants() {
      return {
        isRTL: false
      };
    }
  };
  var _default = I18nManager;
},241,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _modulesDismissKeyboard = require(_dependencyMap[0]);
  var dismissKeyboard = _interopDefault(_modulesDismissKeyboard);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  // in the future we can use https://github.com/w3c/virtual-keyboard
  var Keyboard = {
    isVisible() {
      return false;
    },
    addListener() {
      return {
        remove: () => {}
      };
    },
    dismiss() {
      (0, dismissKeyboard.default)();
    },
    removeAllListeners() {},
    removeListener() {}
  };
  var _default = Keyboard;
},242,[163]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativeLayoutAnimation = require(_dependencyMap[0]);
  var LayoutAnimation = _interopDefault(_vendorReactNativeLayoutAnimation);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var _default = LayoutAnimation.default;
},243,[244]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _exportsPlatform = require(_dependencyMap[0]);
  var Platform = _interopDefault(_exportsPlatform);
  var _exportsUIManager = require(_dependencyMap[1]);
  var UIManager = _interopDefault(_exportsUIManager);
  var __DEV__ = false;
  function configureNext(config, onAnimationDidEnd) {
    if (!Platform.default.isTesting) {
      UIManager.default.configureNextLayoutAnimation(config, onAnimationDidEnd !== null && onAnimationDidEnd !== undefined ? onAnimationDidEnd : function () {}, function () {} /* unused onError */);
    }
  }
  function create(duration, type, property) {
    return {
      duration,
      create: {
        type,
        property
      },
      update: {
        type
      },
      delete: {
        type,
        property
      }
    };
  }
  var Presets = {
    easeInEaseOut: create(300, 'easeInEaseOut', 'opacity'),
    linear: create(500, 'linear', 'opacity'),
    spring: {
      duration: 700,
      create: {
        type: 'linear',
        property: 'opacity'
      },
      update: {
        type: 'spring',
        springDamping: 0.4
      },
      delete: {
        type: 'linear',
        property: 'opacity'
      }
    }
  };

  /**
   * Automatically animates views to their new positions when the
   * next layout happens.
   *
   * A common way to use this API is to call it before calling `setState`.
   *
   * Note that in order to get this to work on **Android** you need to set the following flags via `UIManager`:
   *
   *     UIManager.setLayoutAnimationEnabledExperimental && UIManager.setLayoutAnimationEnabledExperimental(true);
   */
  var LayoutAnimation = {
    /**
     * Schedules an animation to happen on the next layout.
     *
     * @param config Specifies animation properties:
     *
     *   - `duration` in milliseconds
     *   - `create`, `AnimationConfig` for animating in new views
     *   - `update`, `AnimationConfig` for animating views that have been updated
     *
     * @param onAnimationDidEnd Called when the animation finished.
     * Only supported on iOS.
     * @param onError Called on error. Only supported on iOS.
     */
    configureNext,
    /**
     * Helper for creating a config for `configureNext`.
     */
    create,
    Types: Object.freeze({
      spring: 'spring',
      linear: 'linear',
      easeInEaseOut: 'easeInEaseOut',
      easeIn: 'easeIn',
      easeOut: 'easeOut',
      keyboard: 'keyboard'
    }),
    Properties: Object.freeze({
      opacity: 'opacity',
      scaleX: 'scaleX',
      scaleY: 'scaleY',
      scaleXY: 'scaleXY'
    }),
    checkConfig() {
      console.error('LayoutAnimation.checkConfig(...) has been disabled.');
    },
    Presets,
    easeInEaseOut: configureNext.bind(null, Presets.easeInEaseOut),
    linear: configureNext.bind(null, Presets.linear),
    spring: configureNext.bind(null, Presets.spring)
  };
  var _default = LayoutAnimation;
},244,[96,126]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _fbjsLibInvariant = require(_dependencyMap[0]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  var _modulesCanUseDom = require(_dependencyMap[1]);
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var initialURL = canUseDOM.default ? window.location.href : '';
  class Linking {
    constructor() {
      this._eventCallbacks = {};
    }
    /**
     * An object mapping of event name
     * and all the callbacks subscribing to it
     */
    _dispatchEvent(event) {
      for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data[_key - 1] = arguments[_key];
      }
      var listeners = this._eventCallbacks[event];
      if (listeners != null && Array.isArray(listeners)) {
        listeners.map(listener => {
          listener(...data);
        });
      }
    }

    /**
     * Adds a event listener for the specified event. The callback will be called when the
     * said event is dispatched.
     */
    addEventListener(eventType, callback) {
      var _this = this;
      if (!_this._eventCallbacks[eventType]) {
        _this._eventCallbacks[eventType] = [callback];
      }
      _this._eventCallbacks[eventType].push(callback);
      return {
        remove() {
          var callbacks = _this._eventCallbacks[eventType];
          var filteredCallbacks = callbacks.filter(c => c.toString() !== callback.toString());
          _this._eventCallbacks[eventType] = filteredCallbacks;
        }
      };
    }

    /**
     * Removes a previously added event listener for the specified event. The callback must
     * be the same object as the one passed to `addEventListener`.
     */
    removeEventListener(eventType, callback) {
      console.error("Linking.removeEventListener('" + eventType + "', ...): Method has been " + 'deprecated. Please instead use `remove()` on the subscription ' + 'returned by `Linking.addEventListener`.');
      var callbacks = this._eventCallbacks[eventType];
      var filteredCallbacks = callbacks.filter(c => c.toString() !== callback.toString());
      this._eventCallbacks[eventType] = filteredCallbacks;
    }
    canOpenURL() {
      return Promise.resolve(true);
    }
    getInitialURL() {
      return Promise.resolve(initialURL);
    }

    /**
     * Try to open the given url in a secure fashion. The method returns a Promise object.
     * If a target is passed (including undefined) that target will be used, otherwise '_blank'.
     * If the url opens, the promise is resolved. If not, the promise is rejected.
     * Dispatches the `onOpen` event if `url` is opened successfully.
     */
    openURL(url, target) {
      if (arguments.length === 1) {
        target = '_blank';
      }
      try {
        open(url, target);
        this._dispatchEvent('onOpen', url);
        return Promise.resolve();
      } catch (e) {
        return Promise.reject(e);
      }
    }
    _validateURL(url) {
      (0, invariant.default)(typeof url === 'string', 'Invalid URL: should be a string. Was: ' + url);
      (0, invariant.default)(url, 'Invalid URL: cannot be empty');
    }
  }
  var open = (url, target) => {
    if (canUseDOM.default) {
      var urlToOpen = new URL(url, window.location).toString();
      if (urlToOpen.indexOf('tel:') === 0) {
        window.location = urlToOpen;
      } else {
        window.open(urlToOpen, target, 'noopener');
      }
    }
  };
  var _default = new Linking();
},245,[25,40]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativeEventEmitterNativeEventEmitter = require(_dependencyMap[0]);
  var NativeEventEmitter = _interopDefault(_vendorReactNativeEventEmitterNativeEventEmitter);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var _default = NativeEventEmitter.default;
},246,[197]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativePanResponder = require(_dependencyMap[0]);
  var PanResponder = _interopDefault(_vendorReactNativePanResponder);
  var _default = PanResponder.default;
},247,[248]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _exportsInteractionManager = require(_dependencyMap[0]);
  var InteractionManager = _interopDefault(_exportsInteractionManager);
  var _TouchHistoryMath = require(_dependencyMap[1]);
  var TouchHistoryMath = _interopDefault(_TouchHistoryMath);
  var currentCentroidXOfTouchesChangedAfter = TouchHistoryMath.default.currentCentroidXOfTouchesChangedAfter;
  var currentCentroidYOfTouchesChangedAfter = TouchHistoryMath.default.currentCentroidYOfTouchesChangedAfter;
  var previousCentroidXOfTouchesChangedAfter = TouchHistoryMath.default.previousCentroidXOfTouchesChangedAfter;
  var previousCentroidYOfTouchesChangedAfter = TouchHistoryMath.default.previousCentroidYOfTouchesChangedAfter;
  var currentCentroidX = TouchHistoryMath.default.currentCentroidX;
  var currentCentroidY = TouchHistoryMath.default.currentCentroidY;

  /**
   * `PanResponder` reconciles several touches into a single gesture. It makes
   * single-touch gestures resilient to extra touches, and can be used to
   * recognize simple multi-touch gestures.
   *
   * By default, `PanResponder` holds an `InteractionManager` handle to block
   * long-running JS events from interrupting active gestures.
   *
   * It provides a predictable wrapper of the responder handlers provided by the
   * [gesture responder system](docs/gesture-responder-system.html).
   * For each handler, it provides a new `gestureState` object alongside the
   * native event object:
   *
   * ```
   * onPanResponderMove: (event, gestureState) => {}
   * ```
   *
   * A native event is a synthetic touch event with the following form:
   *
   *  - `nativeEvent`
   *      + `changedTouches` - Array of all touch events that have changed since the last event
   *      + `identifier` - The ID of the touch
   *      + `locationX` - The X position of the touch, relative to the element
   *      + `locationY` - The Y position of the touch, relative to the element
   *      + `pageX` - The X position of the touch, relative to the root element
   *      + `pageY` - The Y position of the touch, relative to the root element
   *      + `target` - The node id of the element receiving the touch event
   *      + `timestamp` - A time identifier for the touch, useful for velocity calculation
   *      + `touches` - Array of all current touches on the screen
   *
   * A `gestureState` object has the following:
   *
   *  - `stateID` - ID of the gestureState- persisted as long as there at least
   *     one touch on screen
   *  - `moveX` - the latest screen coordinates of the recently-moved touch
   *  - `moveY` - the latest screen coordinates of the recently-moved touch
   *  - `x0` - the screen coordinates of the responder grant
   *  - `y0` - the screen coordinates of the responder grant
   *  - `dx` - accumulated distance of the gesture since the touch started
   *  - `dy` - accumulated distance of the gesture since the touch started
   *  - `vx` - current velocity of the gesture
   *  - `vy` - current velocity of the gesture
   *  - `numberActiveTouches` - Number of touches currently on screen
   *
   * ### Basic Usage
   *
   * ```
   *   componentWillMount: function() {
   *     this._panResponder = PanResponder.create({
   *       // Ask to be the responder:
   *       onStartShouldSetPanResponder: (evt, gestureState) => true,
   *       onStartShouldSetPanResponderCapture: (evt, gestureState) => true,
   *       onMoveShouldSetPanResponder: (evt, gestureState) => true,
   *       onMoveShouldSetPanResponderCapture: (evt, gestureState) => true,
   *
   *       onPanResponderGrant: (evt, gestureState) => {
   *         // The gesture has started. Show visual feedback so the user knows
   *         // what is happening!
   *
   *         // gestureState.d{x,y} will be set to zero now
   *       },
   *       onPanResponderMove: (evt, gestureState) => {
   *         // The most recent move distance is gestureState.move{X,Y}
   *
   *         // The accumulated gesture distance since becoming responder is
   *         // gestureState.d{x,y}
   *       },
   *       onPanResponderTerminationRequest: (evt, gestureState) => true,
   *       onPanResponderRelease: (evt, gestureState) => {
   *         // The user has released all touches while this view is the
   *         // responder. This typically means a gesture has succeeded
   *       },
   *       onPanResponderTerminate: (evt, gestureState) => {
   *         // Another component has become the responder, so this gesture
   *         // should be cancelled
   *       },
   *       onShouldBlockNativeResponder: (evt, gestureState) => {
   *         // Returns whether this component should block native components from becoming the JS
   *         // responder. Returns true by default. Is currently only supported on android.
   *         return true;
   *       },
   *     });
   *   },
   *
   *   render: function() {
   *     return (
   *       <View {...this._panResponder.panHandlers} />
   *     );
   *   },
   *
   * ```
   *
   * ### Working Example
   *
   * To see it in action, try the
   * [PanResponder example in RNTester](https://github.com/facebook/react-native/blob/master/RNTester/js/PanResponderExample.js)
   */

  var PanResponder = {
    /**
     *
     * A graphical explanation of the touch data flow:
     *
     * +----------------------------+             +--------------------------------+
     * | ResponderTouchHistoryStore |             |TouchHistoryMath                |
     * +----------------------------+             +----------+---------------------+
     * |Global store of touchHistory|             |Allocation-less math util       |
     * |including activeness, start |             |on touch history (centroids     |
     * |position, prev/cur position.|             |and multitouch movement etc)    |
     * |                            |             |                                |
     * +----^-----------------------+             +----^---------------------------+
     *      |                                          |
     *      | (records relevant history                |
     *      |  of touches relevant for                 |
     *      |  implementing higher level               |
     *      |  gestures)                               |
     *      |                                          |
     * +----+-----------------------+             +----|---------------------------+
     * | ResponderEventPlugin       |             |    |   Your App/Component      |
     * +----------------------------+             +----|---------------------------+
     * |Negotiates which view gets  | Low level   |    |             High level    |
     * |onResponderMove events.     | events w/   |  +-+-------+     events w/     |
     * |Also records history into   | touchHistory|  |   Pan   |     multitouch +  |
     * |ResponderTouchHistoryStore. +---------------->Responder+-----> accumulative|
     * +----------------------------+ attached to |  |         |     distance and  |
     *                                 each event |  +---------+     velocity.     |
     *                                            |                                |
     *                                            |                                |
     *                                            +--------------------------------+
     *
     *
     *
     * Gesture that calculates cumulative movement over time in a way that just
     * "does the right thing" for multiple touches. The "right thing" is very
     * nuanced. When moving two touches in opposite directions, the cumulative
     * distance is zero in each dimension. When two touches move in parallel five
     * pixels in the same direction, the cumulative distance is five, not ten. If
     * two touches start, one moves five in a direction, then stops and the other
     * touch moves fives in the same direction, the cumulative distance is ten.
     *
     * This logic requires a kind of processing of time "clusters" of touch events
     * so that two touch moves that essentially occur in parallel but move every
     * other frame respectively, are considered part of the same movement.
     *
     * Explanation of some of the non-obvious fields:
     *
     * - moveX/moveY: If no move event has been observed, then `(moveX, moveY)` is
     *   invalid. If a move event has been observed, `(moveX, moveY)` is the
     *   centroid of the most recently moved "cluster" of active touches.
     *   (Currently all move have the same timeStamp, but later we should add some
     *   threshold for what is considered to be "moving"). If a palm is
     *   accidentally counted as a touch, but a finger is moving greatly, the palm
     *   will move slightly, but we only want to count the single moving touch.
     * - x0/y0: Centroid location (non-cumulative) at the time of becoming
     *   responder.
     * - dx/dy: Cumulative touch distance - not the same thing as sum of each touch
     *   distance. Accounts for touch moves that are clustered together in time,
     *   moving the same direction. Only valid when currently responder (otherwise,
     *   it only represents the drag distance below the threshold).
     * - vx/vy: Velocity.
     */

    _initializeGestureState(gestureState) {
      gestureState.moveX = 0;
      gestureState.moveY = 0;
      gestureState.x0 = 0;
      gestureState.y0 = 0;
      gestureState.dx = 0;
      gestureState.dy = 0;
      gestureState.vx = 0;
      gestureState.vy = 0;
      gestureState.numberActiveTouches = 0;
      // All `gestureState` accounts for timeStamps up until:
      gestureState._accountsForMovesUpTo = 0;
    },
    /**
     * This is nuanced and is necessary. It is incorrect to continuously take all
     * active *and* recently moved touches, find the centroid, and track how that
     * result changes over time. Instead, we must take all recently moved
     * touches, and calculate how the centroid has changed just for those
     * recently moved touches, and append that change to an accumulator. This is
     * to (at least) handle the case where the user is moving three fingers, and
     * then one of the fingers stops but the other two continue.
     *
     * This is very different than taking all of the recently moved touches and
     * storing their centroid as `dx/dy`. For correctness, we must *accumulate
     * changes* in the centroid of recently moved touches.
     *
     * There is also some nuance with how we handle multiple moved touches in a
     * single event. With the way `ReactNativeEventEmitter` dispatches touches as
     * individual events, multiple touches generate two 'move' events, each of
     * them triggering `onResponderMove`. But with the way `PanResponder` works,
     * all of the gesture inference is performed on the first dispatch, since it
     * looks at all of the touches (even the ones for which there hasn't been a
     * native dispatch yet). Therefore, `PanResponder` does not call
     * `onResponderMove` passed the first dispatch. This diverges from the
     * typical responder callback pattern (without using `PanResponder`), but
     * avoids more dispatches than necessary.
     */
    _updateGestureStateOnMove(gestureState, touchHistory) {
      gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
      gestureState.moveX = currentCentroidXOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);
      gestureState.moveY = currentCentroidYOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);
      var movedAfter = gestureState._accountsForMovesUpTo;
      var prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);
      var x = currentCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);
      var prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);
      var y = currentCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);
      var nextDX = gestureState.dx + (x - prevX);
      var nextDY = gestureState.dy + (y - prevY);

      // TODO: This must be filtered intelligently.
      var dt = touchHistory.mostRecentTimeStamp - gestureState._accountsForMovesUpTo;
      gestureState.vx = (nextDX - gestureState.dx) / dt;
      gestureState.vy = (nextDY - gestureState.dy) / dt;
      gestureState.dx = nextDX;
      gestureState.dy = nextDY;
      gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;
    },
    /**
     * @param {object} config Enhanced versions of all of the responder callbacks
     * that provide not only the typical `ResponderSyntheticEvent`, but also the
     * `PanResponder` gesture state.  Simply replace the word `Responder` with
     * `PanResponder` in each of the typical `onResponder*` callbacks. For
     * example, the `config` object would look like:
     *
     *  - `onMoveShouldSetPanResponder: (e, gestureState) => {...}`
     *  - `onMoveShouldSetPanResponderCapture: (e, gestureState) => {...}`
     *  - `onStartShouldSetPanResponder: (e, gestureState) => {...}`
     *  - `onStartShouldSetPanResponderCapture: (e, gestureState) => {...}`
     *  - `onPanResponderReject: (e, gestureState) => {...}`
     *  - `onPanResponderGrant: (e, gestureState) => {...}`
     *  - `onPanResponderStart: (e, gestureState) => {...}`
     *  - `onPanResponderEnd: (e, gestureState) => {...}`
     *  - `onPanResponderRelease: (e, gestureState) => {...}`
     *  - `onPanResponderMove: (e, gestureState) => {...}`
     *  - `onPanResponderTerminate: (e, gestureState) => {...}`
     *  - `onPanResponderTerminationRequest: (e, gestureState) => {...}`
     *  - `onShouldBlockNativeResponder: (e, gestureState) => {...}`
     *
     *  In general, for events that have capture equivalents, we update the
     *  gestureState once in the capture phase and can use it in the bubble phase
     *  as well.
     *
     *  Be careful with onStartShould* callbacks. They only reflect updated
     *  `gestureState` for start/end events that bubble/capture to the Node.
     *  Once the node is the responder, you can rely on every start/end event
     *  being processed by the gesture and `gestureState` being updated
     *  accordingly. (numberActiveTouches) may not be totally accurate unless you
     *  are the responder.
     */
    create(config) {
      var interactionState = {
        handle: null,
        shouldCancelClick: false,
        timeout: null
      };
      var gestureState = {
        // Useful for debugging
        stateID: Math.random(),
        moveX: 0,
        moveY: 0,
        x0: 0,
        y0: 0,
        dx: 0,
        dy: 0,
        vx: 0,
        vy: 0,
        numberActiveTouches: 0,
        _accountsForMovesUpTo: 0
      };
      var panHandlers = {
        onStartShouldSetResponder(event) {
          return config.onStartShouldSetPanResponder == null ? false : config.onStartShouldSetPanResponder(event, gestureState);
        },
        onMoveShouldSetResponder(event) {
          return config.onMoveShouldSetPanResponder == null ? false : config.onMoveShouldSetPanResponder(event, gestureState);
        },
        onStartShouldSetResponderCapture(event) {
          // TODO: Actually, we should reinitialize the state any time
          // touches.length increases from 0 active to > 0 active.
          if (event.nativeEvent.touches.length === 1) {
            PanResponder._initializeGestureState(gestureState);
          }
          gestureState.numberActiveTouches = event.touchHistory.numberActiveTouches;
          return config.onStartShouldSetPanResponderCapture != null ? config.onStartShouldSetPanResponderCapture(event, gestureState) : false;
        },
        onMoveShouldSetResponderCapture(event) {
          var touchHistory = event.touchHistory;
          // Responder system incorrectly dispatches should* to current responder
          // Filter out any touch moves past the first one - we would have
          // already processed multi-touch geometry during the first event.
          if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {
            return false;
          }
          PanResponder._updateGestureStateOnMove(gestureState, touchHistory);
          return config.onMoveShouldSetPanResponderCapture ? config.onMoveShouldSetPanResponderCapture(event, gestureState) : false;
        },
        onResponderGrant(event) {
          if (!interactionState.handle) {
            interactionState.handle = InteractionManager.default.createInteractionHandle();
          }
          if (interactionState.timeout) {
            clearInteractionTimeout(interactionState);
          }
          interactionState.shouldCancelClick = true;
          gestureState.x0 = currentCentroidX(event.touchHistory);
          gestureState.y0 = currentCentroidY(event.touchHistory);
          gestureState.dx = 0;
          gestureState.dy = 0;
          if (config.onPanResponderGrant) {
            config.onPanResponderGrant(event, gestureState);
          }
          // TODO: t7467124 investigate if this can be removed
          return config.onShouldBlockNativeResponder == null ? true : config.onShouldBlockNativeResponder(event, gestureState);
        },
        onResponderReject(event) {
          clearInteractionHandle(interactionState, config.onPanResponderReject, event, gestureState);
        },
        onResponderRelease(event) {
          clearInteractionHandle(interactionState, config.onPanResponderRelease, event, gestureState);
          setInteractionTimeout(interactionState);
          PanResponder._initializeGestureState(gestureState);
        },
        onResponderStart(event) {
          var touchHistory = event.touchHistory;
          gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
          if (config.onPanResponderStart) {
            config.onPanResponderStart(event, gestureState);
          }
        },
        onResponderMove(event) {
          var touchHistory = event.touchHistory;
          // Guard against the dispatch of two touch moves when there are two
          // simultaneously changed touches.
          if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {
            return;
          }
          // Filter out any touch moves past the first one - we would have
          // already processed multi-touch geometry during the first event.
          PanResponder._updateGestureStateOnMove(gestureState, touchHistory);
          if (config.onPanResponderMove) {
            config.onPanResponderMove(event, gestureState);
          }
        },
        onResponderEnd(event) {
          var touchHistory = event.touchHistory;
          gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
          clearInteractionHandle(interactionState, config.onPanResponderEnd, event, gestureState);
        },
        onResponderTerminate(event) {
          clearInteractionHandle(interactionState, config.onPanResponderTerminate, event, gestureState);
          setInteractionTimeout(interactionState);
          PanResponder._initializeGestureState(gestureState);
        },
        onResponderTerminationRequest(event) {
          return config.onPanResponderTerminationRequest == null ? true : config.onPanResponderTerminationRequest(event, gestureState);
        },
        // We do not want to trigger 'click' activated gestures or native behaviors
        // on any pan target that is under a mouse cursor when it is released.
        // Browsers will natively cancel 'click' events on a target if a non-mouse
        // active pointer moves.
        onClickCapture: event => {
          if (interactionState.shouldCancelClick === true) {
            event.stopPropagation();
            event.preventDefault();
          }
        }
      };
      return {
        panHandlers,
        getInteractionHandle() {
          return interactionState.handle;
        }
      };
    }
  };
  function clearInteractionHandle(interactionState, callback, event, gestureState) {
    if (interactionState.handle) {
      InteractionManager.default.clearInteractionHandle(interactionState.handle);
      interactionState.handle = null;
    }
    if (callback) {
      callback(event, gestureState);
    }
  }
  function clearInteractionTimeout(interactionState) {
    clearTimeout(interactionState.timeout);
  }
  function setInteractionTimeout(interactionState) {
    interactionState.timeout = setTimeout(() => {
      interactionState.shouldCancelClick = false;
    }, 250);
  }
  var _default = PanResponder;
},248,[169,249]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   */

  var TouchHistoryMath = {
    /**
     * This code is optimized and not intended to look beautiful. This allows
     * computing of touch centroids that have moved after `touchesChangedAfter`
     * timeStamp. You can compute the current centroid involving all touches
     * moves after `touchesChangedAfter`, or you can compute the previous
     * centroid of all touches that were moved after `touchesChangedAfter`.
     *
     * @param {TouchHistoryMath} touchHistory Standard Responder touch track
     * data.
     * @param {number} touchesChangedAfter timeStamp after which moved touches
     * are considered "actively moving" - not just "active".
     * @param {boolean} isXAxis Consider `x` dimension vs. `y` dimension.
     * @param {boolean} ofCurrent Compute current centroid for actively moving
     * touches vs. previous centroid of now actively moving touches.
     * @return {number} value of centroid in specified dimension.
     */
    centroidDimension: function centroidDimension(touchHistory, touchesChangedAfter, isXAxis, ofCurrent) {
      var touchBank = touchHistory.touchBank;
      var total = 0;
      var count = 0;
      var oneTouchData = touchHistory.numberActiveTouches === 1 ? touchHistory.touchBank[touchHistory.indexOfSingleActiveTouch] : null;
      if (oneTouchData !== null) {
        if (oneTouchData.touchActive && oneTouchData.currentTimeStamp > touchesChangedAfter) {
          total += ofCurrent && isXAxis ? oneTouchData.currentPageX : ofCurrent && !isXAxis ? oneTouchData.currentPageY : !ofCurrent && isXAxis ? oneTouchData.previousPageX : oneTouchData.previousPageY;
          count = 1;
        }
      } else {
        for (var i = 0; i < touchBank.length; i++) {
          var touchTrack = touchBank[i];
          if (touchTrack !== null && touchTrack !== undefined && touchTrack.touchActive && touchTrack.currentTimeStamp >= touchesChangedAfter) {
            var toAdd = undefined; // Yuck, program temporarily in invalid state.
            if (ofCurrent && isXAxis) {
              toAdd = touchTrack.currentPageX;
            } else if (ofCurrent && !isXAxis) {
              toAdd = touchTrack.currentPageY;
            } else if (!ofCurrent && isXAxis) {
              toAdd = touchTrack.previousPageX;
            } else {
              toAdd = touchTrack.previousPageY;
            }
            total += toAdd;
            count++;
          }
        }
      }
      return count > 0 ? total / count : TouchHistoryMath.noCentroid;
    },
    currentCentroidXOfTouchesChangedAfter: function currentCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true,
      // isXAxis
      true // ofCurrent
      );
    },
    currentCentroidYOfTouchesChangedAfter: function currentCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false,
      // isXAxis
      true // ofCurrent
      );
    },
    previousCentroidXOfTouchesChangedAfter: function previousCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true,
      // isXAxis
      false // ofCurrent
      );
    },
    previousCentroidYOfTouchesChangedAfter: function previousCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
      return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false,
      // isXAxis
      false // ofCurrent
      );
    },
    currentCentroidX: function currentCentroidX(touchHistory) {
      return TouchHistoryMath.centroidDimension(touchHistory, 0,
      // touchesChangedAfter
      true,
      // isXAxis
      true // ofCurrent
      );
    },
    currentCentroidY: function currentCentroidY(touchHistory) {
      return TouchHistoryMath.centroidDimension(touchHistory, 0,
      // touchesChangedAfter
      false,
      // isXAxis
      true // ofCurrent
      );
    },
    noCentroid: -1
  };
  var _default = TouchHistoryMath;
},249,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _fbjsLibInvariant = require(_dependencyMap[0]);
  var invariant = _interopDefault(_fbjsLibInvariant);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  class Share {
    static share(content, options) {
      if (options === undefined) {
        options = {};
      }
      (0, invariant.default)(typeof content === 'object' && content !== null, 'Content to share must be a valid object');
      (0, invariant.default)(typeof content.url === 'string' || typeof content.message === 'string', 'At least one of URL and message is required');
      (0, invariant.default)(typeof options === 'object' && options !== null, 'Options must be a valid object');
      (0, invariant.default)(!content.title || typeof content.title === 'string', 'Invalid title: title should be a string.');
      if (window.navigator.share !== undefined) {
        return window.navigator.share({
          title: content.title,
          text: content.message,
          url: content.url
        });
      } else {
        return Promise.reject(new Error('Share is not supported in this browser'));
      }
    }

    /**
     * The content was successfully shared.
     */
    static get sharedAction() {
      return 'sharedAction';
    }

    /**
     * The dialog has been dismissed.
     * @platform ios
     */
    static get dismissedAction() {
      return 'dismissedAction';
    }
  }
  var _default = Share;
},250,[25]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var vibrate = pattern => {
    if ('vibrate' in window.navigator) {
      window.navigator.vibrate(pattern);
    }
  };
  var Vibration = {
    cancel() {
      vibrate(0);
    },
    vibrate(pattern) {
      if (pattern === undefined) {
        pattern = 400;
      }
      vibrate(pattern);
    }
  };
  var _default = Vibration;
},251,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2]);
  var React = _interopNamespace(_react);
  var _StyleSheet = require(_dependencyMap[3]);
  var StyleSheet = _interopDefault(_StyleSheet);
  var _View = require(_dependencyMap[4]);
  var View = _interopDefault(_View);
  var _excluded = ["animating", "color", "hidesWhenStopped", "size", "style"];
  var createSvgCircle = style => /*#__PURE__*/React.createElement("circle", {
    cx: "16",
    cy: "16",
    fill: "none",
    r: "14",
    strokeWidth: "4",
    style: style
  });
  var ActivityIndicator = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var _props$animating = props.animating,
      animating = _props$animating === undefined ? true : _props$animating,
      _props$color = props.color,
      color = _props$color === undefined ? '#1976D2' : _props$color,
      _props$hidesWhenStopp = props.hidesWhenStopped,
      hidesWhenStopped = _props$hidesWhenStopp === undefined ? true : _props$hidesWhenStopp,
      _props$size = props.size,
      size = _props$size === undefined ? 'small' : _props$size,
      style = props.style,
      other = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    var svg = /*#__PURE__*/React.createElement("svg", {
      height: "100%",
      viewBox: "0 0 32 32",
      width: "100%"
    }, createSvgCircle({
      stroke: color,
      opacity: 0.2
    }), createSvgCircle({
      stroke: color,
      strokeDasharray: 80,
      strokeDashoffset: 60
    }));
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, other, {
      "aria-valuemax": 1,
      "aria-valuemin": 0,
      ref: forwardedRef,
      role: "progressbar",
      style: [styles.container, style]
    }), /*#__PURE__*/React.createElement(View.default, {
      children: svg,
      style: [typeof size === 'number' ? {
        height: size,
        width: size
      } : indicatorSizes[size], styles.animation, !animating && styles.animationPause, !animating && hidesWhenStopped && styles.hidesWhenStopped]
    }));
  });
  ActivityIndicator.displayName = 'ActivityIndicator';
  var styles = StyleSheet.default.create({
    container: {
      alignItems: 'center',
      justifyContent: 'center'
    },
    hidesWhenStopped: {
      visibility: 'hidden'
    },
    animation: {
      animationDuration: '0.75s',
      animationKeyframes: [{
        '0%': {
          transform: 'rotate(0deg)'
        },
        '100%': {
          transform: 'rotate(360deg)'
        }
      }],
      animationTimingFunction: 'linear',
      animationIterationCount: 'infinite'
    },
    animationPause: {
      animationPlayState: 'paused'
    }
  });
  var indicatorSizes = StyleSheet.default.create({
    small: {
      width: 20,
      height: 20
    },
    large: {
      width: 36,
      height: 36
    }
  });
  var _default = ActivityIndicator;
},252,[28,44,35,43,138]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _react = require(_dependencyMap[0]);
  var React = _interopNamespace(_react);
  var _StyleSheet = require(_dependencyMap[1]);
  var StyleSheet = _interopDefault(_StyleSheet);
  var _TouchableOpacity = require(_dependencyMap[2]);
  var TouchableOpacity = _interopDefault(_TouchableOpacity);
  var _Text = require(_dependencyMap[3]);
  var Text = _interopDefault(_Text);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  //import { warnOnce } from '../../modules/warnOnce';

  var Button = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    // warnOnce('Button', 'Button is deprecated. Please use Pressable.');

    var accessibilityLabel = props.accessibilityLabel,
      color = props.color,
      disabled = props.disabled,
      onPress = props.onPress,
      testID = props.testID,
      title = props.title;
    return /*#__PURE__*/React.createElement(TouchableOpacity.default, {
      accessibilityLabel: accessibilityLabel,
      accessibilityRole: "button",
      disabled: disabled,
      focusable: !disabled,
      onPress: onPress,
      ref: forwardedRef,
      style: [styles.button, color && {
        backgroundColor: color
      }, disabled && styles.buttonDisabled],
      testID: testID
    }, /*#__PURE__*/React.createElement(Text.default, {
      style: [styles.text, disabled && styles.textDisabled]
    }, title));
  });
  Button.displayName = 'Button';
  var styles = StyleSheet.default.create({
    button: {
      backgroundColor: '#2196F3',
      borderRadius: 2
    },
    text: {
      color: '#fff',
      fontWeight: '500',
      padding: 8,
      textAlign: 'center',
      textTransform: 'uppercase'
    },
    buttonDisabled: {
      backgroundColor: '#dfdfdf'
    },
    textDisabled: {
      color: '#a1a1a1'
    }
  });
  var _default = Button;
},253,[35,43,254,216]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2]);
  var React = _interopNamespace(_react);
  var _modulesUseMergeRefs = require(_dependencyMap[3]);
  var useMergeRefs = _interopDefault(_modulesUseMergeRefs);
  var _modulesUsePressEvents = require(_dependencyMap[4]);
  var usePressEvents = _interopDefault(_modulesUsePressEvents);
  var _StyleSheet = require(_dependencyMap[5]);
  var StyleSheet = _interopDefault(_StyleSheet);
  var _View = require(_dependencyMap[6]);
  var View = _interopDefault(_View);
  var _excluded = ["activeOpacity", "delayPressIn", "delayPressOut", "delayLongPress", "disabled", "focusable", "onLongPress", "onPress", "onPressIn", "onPressOut", "rejectResponderTermination", "style"];
  //import { warnOnce } from '../../modules/warnOnce';

  /**
   * A wrapper for making views respond properly to touches.
   * On press down, the opacity of the wrapped view is decreased, dimming it.
   */
  function TouchableOpacity(props, forwardedRef) {
    /*
    warnOnce(
      'TouchableOpacity',
      'TouchableOpacity is deprecated. Please use Pressable.'
    );
    */

    var activeOpacity = props.activeOpacity,
      delayPressIn = props.delayPressIn,
      delayPressOut = props.delayPressOut,
      delayLongPress = props.delayLongPress,
      disabled = props.disabled,
      focusable = props.focusable,
      onLongPress = props.onLongPress,
      onPress = props.onPress,
      onPressIn = props.onPressIn,
      onPressOut = props.onPressOut,
      rejectResponderTermination = props.rejectResponderTermination,
      style = props.style,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    var hostRef = (0, _react.useRef)(null);
    var setRef = (0, useMergeRefs.default)(forwardedRef, hostRef);
    var _useState = (0, _react.useState)('0s'),
      duration = _useState[0],
      setDuration = _useState[1];
    var _useState2 = (0, _react.useState)(null),
      opacityOverride = _useState2[0],
      setOpacityOverride = _useState2[1];
    var setOpacityTo = (0, _react.useCallback)((value, duration) => {
      setOpacityOverride(value);
      setDuration(duration ? duration / 1000 + "s" : '0s');
    }, [setOpacityOverride, setDuration]);
    var setOpacityActive = (0, _react.useCallback)(duration => {
      setOpacityTo(activeOpacity !== null && activeOpacity !== undefined ? activeOpacity : 0.2, duration);
    }, [activeOpacity, setOpacityTo]);
    var setOpacityInactive = (0, _react.useCallback)(duration => {
      setOpacityTo(null, duration);
    }, [setOpacityTo]);
    var pressConfig = (0, _react.useMemo)(() => ({
      cancelable: !rejectResponderTermination,
      disabled,
      delayLongPress,
      delayPressStart: delayPressIn,
      delayPressEnd: delayPressOut,
      onLongPress,
      onPress,
      onPressStart(event) {
        var isGrant = event.dispatchConfig != null ? event.dispatchConfig.registrationName === 'onResponderGrant' : event.type === 'keydown';
        setOpacityActive(isGrant ? 0 : 150);
        if (onPressIn != null) {
          onPressIn(event);
        }
      },
      onPressEnd(event) {
        setOpacityInactive(250);
        if (onPressOut != null) {
          onPressOut(event);
        }
      }
    }), [delayLongPress, delayPressIn, delayPressOut, disabled, onLongPress, onPress, onPressIn, onPressOut, rejectResponderTermination, setOpacityActive, setOpacityInactive]);
    var pressEventHandlers = (0, usePressEvents.default)(hostRef, pressConfig);
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, rest, pressEventHandlers, {
      accessibilityDisabled: disabled,
      focusable: !disabled && focusable !== false,
      pointerEvents: disabled ? 'box-none' : undefined,
      ref: setRef,
      style: [styles.root, !disabled && styles.actionable, style, opacityOverride != null && {
        opacity: opacityOverride
      }, {
        transitionDuration: duration
      }]
    }));
  }
  var styles = StyleSheet.default.create({
    root: {
      transitionProperty: 'opacity',
      transitionDuration: '0.15s',
      userSelect: 'none'
    },
    actionable: {
      cursor: 'pointer',
      touchAction: 'manipulation'
    }
  });
  var MemoedTouchableOpacity = /*#__PURE__*/React.memo(/*#__PURE__*/React.forwardRef(TouchableOpacity));
  MemoedTouchableOpacity.displayName = 'TouchableOpacity';
  var _default = MemoedTouchableOpacity;
},254,[28,44,35,143,255,43,138]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return usePressEvents;
    }
  });
  var _PressResponder = require(_dependencyMap[0]);
  var PressResponder = _interopDefault(_PressResponder);
  var _react = require(_dependencyMap[1]);
  function usePressEvents(hostRef, config) {
    var pressResponderRef = (0, _react.useRef)(null);
    if (pressResponderRef.current == null) {
      pressResponderRef.current = new PressResponder.default(config);
    }
    var pressResponder = pressResponderRef.current;

    // Re-configure to use the current node and configuration.
    (0, _react.useEffect)(() => {
      pressResponder.configure(config);
    }, [config, pressResponder]);

    // Reset the `pressResponder` when cleanup needs to occur. This is
    // a separate effect because we do not want to rest the responder when `config` changes.
    (0, _react.useEffect)(() => {
      return () => {
        pressResponder.reset();
      };
    }, [pressResponder]);
    (0, _react.useDebugValue)(config);
    return pressResponder.getEventHandlers();
  }
},255,[256,35]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return PressResponder;
    }
  });
  var DELAY = 'DELAY';
  var ERROR = 'ERROR';
  var LONG_PRESS_DETECTED = 'LONG_PRESS_DETECTED';
  var NOT_RESPONDER = 'NOT_RESPONDER';
  var RESPONDER_ACTIVE_LONG_PRESS_START = 'RESPONDER_ACTIVE_LONG_PRESS_START';
  var RESPONDER_ACTIVE_PRESS_START = 'RESPONDER_ACTIVE_PRESS_START';
  var RESPONDER_INACTIVE_PRESS_START = 'RESPONDER_INACTIVE_PRESS_START';
  var RESPONDER_GRANT = 'RESPONDER_GRANT';
  var RESPONDER_RELEASE = 'RESPONDER_RELEASE';
  var RESPONDER_TERMINATED = 'RESPONDER_TERMINATED';
  var Transitions = Object.freeze({
    NOT_RESPONDER: {
      DELAY: ERROR,
      RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,
      RESPONDER_RELEASE: ERROR,
      RESPONDER_TERMINATED: ERROR,
      LONG_PRESS_DETECTED: ERROR
    },
    RESPONDER_INACTIVE_PRESS_START: {
      DELAY: RESPONDER_ACTIVE_PRESS_START,
      RESPONDER_GRANT: ERROR,
      RESPONDER_RELEASE: NOT_RESPONDER,
      RESPONDER_TERMINATED: NOT_RESPONDER,
      LONG_PRESS_DETECTED: ERROR
    },
    RESPONDER_ACTIVE_PRESS_START: {
      DELAY: ERROR,
      RESPONDER_GRANT: ERROR,
      RESPONDER_RELEASE: NOT_RESPONDER,
      RESPONDER_TERMINATED: NOT_RESPONDER,
      LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START
    },
    RESPONDER_ACTIVE_LONG_PRESS_START: {
      DELAY: ERROR,
      RESPONDER_GRANT: ERROR,
      RESPONDER_RELEASE: NOT_RESPONDER,
      RESPONDER_TERMINATED: NOT_RESPONDER,
      LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START
    },
    ERROR: {
      DELAY: NOT_RESPONDER,
      RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,
      RESPONDER_RELEASE: NOT_RESPONDER,
      RESPONDER_TERMINATED: NOT_RESPONDER,
      LONG_PRESS_DETECTED: NOT_RESPONDER
    }
  });
  var getElementRole = element => element.getAttribute('role');
  var getElementType = element => element.tagName.toLowerCase();
  var isActiveSignal = signal => signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;
  var isButtonRole = element => getElementRole(element) === 'button';
  var isPressStartSignal = signal => signal === RESPONDER_INACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;
  var isTerminalSignal = signal => signal === RESPONDER_TERMINATED || signal === RESPONDER_RELEASE;
  var isValidKeyPress = event => {
    var key = event.key,
      target = event.target;
    var isSpacebar = key === ' ' || key === 'Spacebar';
    var isButtonish = getElementType(target) === 'button' || isButtonRole(target);
    return key === 'Enter' || isSpacebar && isButtonish;
  };
  var DEFAULT_LONG_PRESS_DELAY_MS = 450; // 500 - 50
  var DEFAULT_PRESS_DELAY_MS = 50;

  /**
   * =========================== PressResponder Tutorial ===========================
   *
   * The `PressResponder` class helps you create press interactions by analyzing the
   * geometry of elements and observing when another responder (e.g. ScrollView)
   * has stolen the touch lock. It offers hooks for your component to provide
   * interaction feedback to the user:
   *
   * - When a press has activated (e.g. highlight an element)
   * - When a press has deactivated (e.g. un-highlight an element)
   * - When a press sould trigger an action, meaning it activated and deactivated
   *   while within the geometry of the element without the lock being stolen.
   *
   * A high quality interaction isn't as simple as you might think. There should
   * be a slight delay before activation. Moving your finger beyond an element's
   * bounds should trigger deactivation, but moving the same finger back within an
   * element's bounds should trigger reactivation.
   *
   * In order to use `PressResponder`, do the following:
   *
   *     const pressResponder = new PressResponder(config);
   *
   * 2. Choose the rendered component who should collect the press events. On that
   *    element, spread `pressability.getEventHandlers()` into its props.
   *
   *    return (
   *      <View {...this.state.pressResponder.getEventHandlers()} />
   *    );
   *
   * 3. Reset `PressResponder` when your component unmounts.
   *
   *    componentWillUnmount() {
   *      this.state.pressResponder.reset();
   *    }
   *
   * ==================== Implementation Details ====================
   *
   * `PressResponder` only assumes that there exists a `HitRect` node. The `PressRect`
   * is an abstract box that is extended beyond the `HitRect`.
   *
   * # Geometry
   *
   *  ┌────────────────────────┐
   *  │  ┌──────────────────┐  │ - Presses start anywhere within `HitRect`.
   *  │  │  ┌────────────┐  │  │
   *  │  │  │ VisualRect │  │  │
   *  │  │  └────────────┘  │  │ - When pressed down for sufficient amount of time
   *  │  │    HitRect       │  │   before letting up, `VisualRect` activates.
   *  │  └──────────────────┘  │
   *  │       Out Region   o   │
   *  └────────────────────│───┘
   *                       └────── When the press is released outside the `HitRect`,
   *                               the responder is NOT eligible for a "press".
   *
   * # State Machine
   *
   * ┌───────────────┐ ◀──── RESPONDER_RELEASE
   * │ NOT_RESPONDER │
   * └───┬───────────┘ ◀──── RESPONDER_TERMINATED
   *     │
   *     │ RESPONDER_GRANT (HitRect)
   *     │
   *     ▼
   * ┌─────────────────────┐          ┌───────────────────┐              ┌───────────────────┐
   * │ RESPONDER_INACTIVE_ │  DELAY   │ RESPONDER_ACTIVE_ │  T + DELAY   │ RESPONDER_ACTIVE_ │
   * │ PRESS_START         ├────────▶ │ PRESS_START       ├────────────▶ │ LONG_PRESS_START  │
   * └─────────────────────┘          └───────────────────┘              └───────────────────┘
   *
   * T + DELAY => LONG_PRESS_DELAY + DELAY
   *
   * Not drawn are the side effects of each transition. The most important side
   * effect is the invocation of `onLongPress`. Only when the browser produces a
   * `click` event is `onPress` invoked.
   */
  class PressResponder {
    constructor(config) {
      this._eventHandlers = null;
      this._isPointerTouch = false;
      this._longPressDelayTimeout = null;
      this._longPressDispatched = false;
      this._pressDelayTimeout = null;
      this._pressOutDelayTimeout = null;
      this._touchState = NOT_RESPONDER;
      this._responderElement = null;
      this.configure(config);
    }
    configure(config) {
      this._config = config;
    }

    /**
     * Resets any pending timers. This should be called on unmount.
     */
    reset() {
      this._cancelLongPressDelayTimeout();
      this._cancelPressDelayTimeout();
      this._cancelPressOutDelayTimeout();
    }

    /**
     * Returns a set of props to spread into the interactive element.
     */
    getEventHandlers() {
      if (this._eventHandlers == null) {
        this._eventHandlers = this._createEventHandlers();
      }
      return this._eventHandlers;
    }
    _createEventHandlers() {
      var start = (event, shouldDelay) => {
        event.persist();
        this._cancelPressOutDelayTimeout();
        this._longPressDispatched = false;
        this._selectionTerminated = false;
        this._touchState = NOT_RESPONDER;
        this._isPointerTouch = event.nativeEvent.type === 'touchstart';
        this._receiveSignal(RESPONDER_GRANT, event);
        var delayPressStart = normalizeDelay(this._config.delayPressStart, 0, DEFAULT_PRESS_DELAY_MS);
        if (shouldDelay !== false && delayPressStart > 0) {
          this._pressDelayTimeout = setTimeout(() => {
            this._receiveSignal(DELAY, event);
          }, delayPressStart);
        } else {
          this._receiveSignal(DELAY, event);
        }
        var delayLongPress = normalizeDelay(this._config.delayLongPress, 10, DEFAULT_LONG_PRESS_DELAY_MS);
        this._longPressDelayTimeout = setTimeout(() => {
          this._handleLongPress(event);
        }, delayLongPress + delayPressStart);
      };
      var end = event => {
        this._receiveSignal(RESPONDER_RELEASE, event);
      };
      var keyupHandler = event => {
        var onPress = this._config.onPress;
        var target = event.target;
        if (this._touchState !== NOT_RESPONDER && isValidKeyPress(event)) {
          end(event);
          document.removeEventListener('keyup', keyupHandler);
          var role = target.getAttribute('role');
          var elementType = getElementType(target);
          var isNativeInteractiveElement = role === 'link' || elementType === 'a' || elementType === 'button' || elementType === 'input' || elementType === 'select' || elementType === 'textarea';
          var isActiveElement = this._responderElement === target;
          if (onPress != null && !isNativeInteractiveElement && isActiveElement) {
            onPress(event);
          }
          this._responderElement = null;
        }
      };
      return {
        onStartShouldSetResponder: event => {
          var disabled = this._config.disabled;
          if (disabled && isButtonRole(event.currentTarget)) {
            event.stopPropagation();
          }
          if (disabled == null) {
            return true;
          }
          return !disabled;
        },
        onKeyDown: event => {
          var disabled = this._config.disabled;
          var key = event.key,
            target = event.target;
          if (!disabled && isValidKeyPress(event)) {
            if (this._touchState === NOT_RESPONDER) {
              start(event, false);
              this._responderElement = target;
              // Listen to 'keyup' on document to account for situations where
              // focus is moved to another element during 'keydown'.
              document.addEventListener('keyup', keyupHandler);
            }
            var isSpacebarKey = key === ' ' || key === 'Spacebar';
            var role = getElementRole(target);
            var isButtonLikeRole = role === 'button' || role === 'menuitem';
            if (isSpacebarKey && isButtonLikeRole && getElementType(target) !== 'button') {
              // Prevent spacebar scrolling the window if using non-native button
              event.preventDefault();
            }
            event.stopPropagation();
          }
        },
        onResponderGrant: event => start(event),
        onResponderMove: event => {
          if (this._config.onPressMove != null) {
            this._config.onPressMove(event);
          }
          var touch = getTouchFromResponderEvent(event);
          if (this._touchActivatePosition != null) {
            var deltaX = this._touchActivatePosition.pageX - touch.pageX;
            var deltaY = this._touchActivatePosition.pageY - touch.pageY;
            if (Math.hypot(deltaX, deltaY) > 10) {
              this._cancelLongPressDelayTimeout();
            }
          }
        },
        onResponderRelease: event => end(event),
        onResponderTerminate: event => {
          if (event.nativeEvent.type === 'selectionchange') {
            this._selectionTerminated = true;
          }
          this._receiveSignal(RESPONDER_TERMINATED, event);
        },
        onResponderTerminationRequest: event => {
          var _this$_config = this._config,
            cancelable = _this$_config.cancelable,
            disabled = _this$_config.disabled,
            onLongPress = _this$_config.onLongPress;
          // If `onLongPress` is provided, don't terminate on `contextmenu` as default
          // behavior will be prevented for non-mouse pointers.
          if (!disabled && onLongPress != null && this._isPointerTouch && event.nativeEvent.type === 'contextmenu') {
            return false;
          }
          if (cancelable == null) {
            return true;
          }
          return cancelable;
        },
        // NOTE: this diverges from react-native in 3 significant ways:
        // * The `onPress` callback is not connected to the responder system (the native
        //  `click` event must be used but is dispatched in many scenarios where no pointers
        //   are on the screen.) Therefore, it's possible for `onPress` to be called without
        //   `onPress{Start,End}` being called first.
        // * The `onPress` callback is only be called on the first ancestor of the native
        //   `click` target that is using the PressResponder.
        // * The event's `nativeEvent` is a `MouseEvent` not a `TouchEvent`.
        onClick: event => {
          var _this$_config2 = this._config,
            disabled = _this$_config2.disabled,
            onPress = _this$_config2.onPress;
          if (!disabled) {
            // If long press dispatched, cancel default click behavior.
            // If the responder terminated because text was selected during the gesture,
            // cancel the default click behavior.
            event.stopPropagation();
            if (this._longPressDispatched || this._selectionTerminated) {
              event.preventDefault();
            } else if (onPress != null && event.altKey === false) {
              onPress(event);
            }
          } else {
            if (isButtonRole(event.currentTarget)) {
              event.stopPropagation();
            }
          }
        },
        // If `onLongPress` is provided and a touch pointer is being used, prevent the
        // default context menu from opening.
        onContextMenu: event => {
          var _this$_config3 = this._config,
            disabled = _this$_config3.disabled,
            onLongPress = _this$_config3.onLongPress;
          if (!disabled) {
            if (onLongPress != null && this._isPointerTouch && !event.defaultPrevented) {
              event.preventDefault();
              event.stopPropagation();
            }
          } else {
            if (isButtonRole(event.currentTarget)) {
              event.stopPropagation();
            }
          }
        }
      };
    }

    /**
     * Receives a state machine signal, performs side effects of the transition
     * and stores the new state. Validates the transition as well.
     */
    _receiveSignal(signal, event) {
      var prevState = this._touchState;
      var nextState = null;
      if (Transitions[prevState] != null) {
        nextState = Transitions[prevState][signal];
      }
      if (this._touchState === NOT_RESPONDER && signal === RESPONDER_RELEASE) {
        return;
      }
      if (nextState == null || nextState === ERROR) {
        console.error("PressResponder: Invalid signal " + signal + " for state " + prevState + " on responder");
      } else if (prevState !== nextState) {
        this._performTransitionSideEffects(prevState, nextState, signal, event);
        this._touchState = nextState;
      }
    }

    /**
     * Performs a transition between touchable states and identify any activations
     * or deactivations (and callback invocations).
     */
    _performTransitionSideEffects(prevState, nextState, signal, event) {
      if (isTerminalSignal(signal)) {
        // Pressable suppression of contextmenu on windows.
        // On Windows, the contextmenu is displayed after pointerup.
        // https://github.com/necolas/react-native-web/issues/2296
        setTimeout(() => {
          this._isPointerTouch = false;
        }, 0);
        this._touchActivatePosition = null;
        this._cancelLongPressDelayTimeout();
      }
      if (isPressStartSignal(prevState) && signal === LONG_PRESS_DETECTED) {
        var onLongPress = this._config.onLongPress;
        // Long press is not supported for keyboards because 'click' can be dispatched
        // immediately (and multiple times) after 'keydown'.
        if (onLongPress != null && event.nativeEvent.key == null) {
          onLongPress(event);
          this._longPressDispatched = true;
        }
      }
      var isPrevActive = isActiveSignal(prevState);
      var isNextActive = isActiveSignal(nextState);
      if (!isPrevActive && isNextActive) {
        this._activate(event);
      } else if (isPrevActive && !isNextActive) {
        this._deactivate(event);
      }
      if (isPressStartSignal(prevState) && signal === RESPONDER_RELEASE) {
        var _this$_config4 = this._config,
          _onLongPress = _this$_config4.onLongPress,
          onPress = _this$_config4.onPress;
        if (onPress != null) {
          var isPressCanceledByLongPress = _onLongPress != null && prevState === RESPONDER_ACTIVE_LONG_PRESS_START;
          if (!isPressCanceledByLongPress) {
            // If we never activated (due to delays), activate and deactivate now.
            if (!isNextActive && !isPrevActive) {
              this._activate(event);
              this._deactivate(event);
            }
          }
        }
      }
      this._cancelPressDelayTimeout();
    }
    _activate(event) {
      var _this$_config5 = this._config,
        onPressChange = _this$_config5.onPressChange,
        onPressStart = _this$_config5.onPressStart;
      var touch = getTouchFromResponderEvent(event);
      this._touchActivatePosition = {
        pageX: touch.pageX,
        pageY: touch.pageY
      };
      if (onPressStart != null) {
        onPressStart(event);
      }
      if (onPressChange != null) {
        onPressChange(true);
      }
    }
    _deactivate(event) {
      var _this$_config6 = this._config,
        onPressChange = _this$_config6.onPressChange,
        onPressEnd = _this$_config6.onPressEnd;
      function end() {
        if (onPressEnd != null) {
          onPressEnd(event);
        }
        if (onPressChange != null) {
          onPressChange(false);
        }
      }
      var delayPressEnd = normalizeDelay(this._config.delayPressEnd);
      if (delayPressEnd > 0) {
        this._pressOutDelayTimeout = setTimeout(() => {
          end();
        }, delayPressEnd);
      } else {
        end();
      }
    }
    _handleLongPress(event) {
      if (this._touchState === RESPONDER_ACTIVE_PRESS_START || this._touchState === RESPONDER_ACTIVE_LONG_PRESS_START) {
        this._receiveSignal(LONG_PRESS_DETECTED, event);
      }
    }
    _cancelLongPressDelayTimeout() {
      if (this._longPressDelayTimeout != null) {
        clearTimeout(this._longPressDelayTimeout);
        this._longPressDelayTimeout = null;
      }
    }
    _cancelPressDelayTimeout() {
      if (this._pressDelayTimeout != null) {
        clearTimeout(this._pressDelayTimeout);
        this._pressDelayTimeout = null;
      }
    }
    _cancelPressOutDelayTimeout() {
      if (this._pressOutDelayTimeout != null) {
        clearTimeout(this._pressOutDelayTimeout);
        this._pressOutDelayTimeout = null;
      }
    }
  }
  function normalizeDelay(delay, min, fallback) {
    if (min === undefined) {
      min = 0;
    }
    if (fallback === undefined) {
      fallback = 0;
    }
    return Math.max(min, delay !== null && delay !== undefined ? delay : fallback);
  }
  function getTouchFromResponderEvent(event) {
    var _event$nativeEvent = event.nativeEvent,
      changedTouches = _event$nativeEvent.changedTouches,
      touches = _event$nativeEvent.touches;
    if (touches != null && touches.length > 0) {
      return touches[0];
    }
    if (changedTouches != null && changedTouches.length > 0) {
      return changedTouches[0];
    }
    return event.nativeEvent;
  }
},256,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _babelRuntimeHelpersExtends = require(_dependencyMap[1]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[2]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[3]);
  var React = _interopNamespace(_react);
  var _createElement = require(_dependencyMap[4]);
  var createElement = _interopDefault(_createElement);
  var _StyleSheet = require(_dependencyMap[5]);
  var StyleSheet = _interopDefault(_StyleSheet);
  var _View = require(_dependencyMap[6]);
  var View = _interopDefault(_View);
  var _excluded = ["aria-readonly", "color", "disabled", "onChange", "onValueChange", "readOnly", "style", "value"];
  var CheckBox = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var ariaReadOnly = props['aria-readonly'],
      color = props.color,
      disabled = props.disabled,
      onChange = props.onChange,
      onValueChange = props.onValueChange,
      readOnly = props.readOnly,
      style = props.style,
      value = props.value,
      other = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    function handleChange(event) {
      var value = event.nativeEvent.target.checked;
      event.nativeEvent.value = value;
      onChange && onChange(event);
      onValueChange && onValueChange(value);
    }
    var fakeControl = /*#__PURE__*/React.createElement(View.default, {
      style: [styles.fakeControl, value && styles.fakeControlChecked,
      // custom color
      value && color && {
        backgroundColor: color,
        borderColor: color
      }, disabled && styles.fakeControlDisabled, value && disabled && styles.fakeControlCheckedAndDisabled]
    });
    var nativeControl = (0, createElement.default)('input', {
      checked: value,
      disabled: disabled,
      onChange: handleChange,
      readOnly: readOnly === true || ariaReadOnly === true || other.accessibilityReadOnly === true,
      ref: forwardedRef,
      style: [styles.nativeControl, styles.cursorInherit],
      type: 'checkbox'
    });
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, other, {
      "aria-disabled": disabled,
      "aria-readonly": ariaReadOnly,
      style: [styles.root, style, disabled && styles.cursorDefault]
    }), fakeControl, nativeControl);
  });
  CheckBox.displayName = 'CheckBox';
  var styles = StyleSheet.default.create({
    root: {
      cursor: 'pointer',
      height: 16,
      userSelect: 'none',
      width: 16
    },
    cursorDefault: {
      cursor: 'default'
    },
    cursorInherit: {
      cursor: 'inherit'
    },
    fakeControl: {
      alignItems: 'center',
      backgroundColor: '#fff',
      borderColor: '#657786',
      borderRadius: 2,
      borderStyle: 'solid',
      borderWidth: 2,
      height: '100%',
      justifyContent: 'center',
      width: '100%'
    },
    fakeControlChecked: {
      backgroundColor: '#009688',
      backgroundImage: 'url("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgdmVyc2lvbj0iMS4xIgogICB2aWV3Qm94PSIwIDAgMSAxIgogICBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJ4TWluWU1pbiBtZWV0Ij4KICA8cGF0aAogICAgIGQ9Ik0gMC4wNDAzODA1OSwwLjYyNjc3NjcgMC4xNDY0NDY2MSwwLjUyMDcxMDY4IDAuNDI5Mjg5MzIsMC44MDM1NTMzOSAwLjMyMzIyMzMsMC45MDk2MTk0MSB6IE0gMC4yMTcxNTcyOSwwLjgwMzU1MzM5IDAuODUzNTUzMzksMC4xNjcxNTcyOSAwLjk1OTYxOTQxLDAuMjczMjIzMyAwLjMyMzIyMzMsMC45MDk2MTk0MSB6IgogICAgIGlkPSJyZWN0Mzc4MCIKICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lIiAvPgo8L3N2Zz4K")',
      backgroundRepeat: 'no-repeat',
      borderColor: '#009688'
    },
    fakeControlDisabled: {
      borderColor: '#CCD6DD'
    },
    fakeControlCheckedAndDisabled: {
      backgroundColor: '#AAB8C2',
      borderColor: '#AAB8C2'
    },
    nativeControl: (0, _objectSpread.default)((0, _objectSpread.default)({}, StyleSheet.default.absoluteFillObject), {}, {
      height: '100%',
      margin: 0,
      appearance: 'none',
      padding: 0,
      width: '100%'
    })
  });
  var _default = CheckBox;
},257,[20,28,44,35,116,43,138]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2]);
  var React = _interopNamespace(_react);
  var _Image = require(_dependencyMap[3]);
  var Image = _interopDefault(_Image);
  var _StyleSheet = require(_dependencyMap[4]);
  var StyleSheet = _interopDefault(_StyleSheet);
  var _View = require(_dependencyMap[5]);
  var View = _interopDefault(_View);
  var _excluded = ["children", "style", "imageStyle", "imageRef"];
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var emptyObject = {};

  /**
   * Very simple drop-in replacement for <Image> which supports nesting views.
   */
  var ImageBackground = /*#__PURE__*/(0, _react.forwardRef)((props, forwardedRef) => {
    var children = props.children,
      _props$style = props.style,
      style = _props$style === undefined ? emptyObject : _props$style,
      imageStyle = props.imageStyle,
      imageRef = props.imageRef,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    var _StyleSheet$flatten = StyleSheet.default.flatten(style),
      height = _StyleSheet$flatten.height,
      width = _StyleSheet$flatten.width;
    return /*#__PURE__*/React.createElement(View.default, {
      ref: forwardedRef,
      style: style
    }, /*#__PURE__*/React.createElement(Image.default, (0, _extends.default)({}, rest, {
      ref: imageRef,
      style: [{
        // Temporary Workaround:
        // Current (imperfect yet) implementation of <Image> overwrites width and height styles
        // (which is not quite correct), and these styles conflict with explicitly set styles
        // of <ImageBackground> and with our internal layout model here.
        // So, we have to proxy/reapply these styles explicitly for actual <Image> component.
        // This workaround should be removed after implementing proper support of
        // intrinsic content size of the <Image>.
        width,
        height,
        zIndex: -1
      }, StyleSheet.default.absoluteFill, imageStyle]
    })), children);
  });
  ImageBackground.displayName = 'ImageBackground';
  var _default = ImageBackground;
},258,[28,44,35,206,43,138]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2]);
  var React = _interopNamespace(_react);
  var _View = require(_dependencyMap[3]);
  var View = _interopDefault(_View);
  var _excluded = ["behavior", "contentContainerStyle", "keyboardVerticalOffset"];
  class KeyboardAvoidingView extends React.Component {
    constructor() {
      super(...arguments);
      this.frame = null;
      this.onLayout = event => {
        this.frame = event.nativeEvent.layout;
      };
    }
    relativeKeyboardHeight(keyboardFrame) {
      var frame = this.frame;
      if (!frame || !keyboardFrame) {
        return 0;
      }
      var keyboardY = keyboardFrame.screenY - (this.props.keyboardVerticalOffset || 0);
      return Math.max(frame.y + frame.height - keyboardY, 0);
    }
    onKeyboardChange(event) {}
    render() {
      var _this$props = this.props,
        behavior = _this$props.behavior,
        contentContainerStyle = _this$props.contentContainerStyle,
        keyboardVerticalOffset = _this$props.keyboardVerticalOffset,
        rest = (0, _objectWithoutPropertiesLoose.default)(_this$props, _excluded);
      return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({
        onLayout: this.onLayout
      }, rest));
    }
  }
  var _default = KeyboardAvoidingView;
},259,[28,44,35,138]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2]);
  var React = _interopNamespace(_react);
  var _ModalPortal = require(_dependencyMap[3]);
  var ModalPortal = _interopDefault(_ModalPortal);
  var _ModalAnimation = require(_dependencyMap[4]);
  var ModalAnimation = _interopDefault(_ModalAnimation);
  var _ModalContent = require(_dependencyMap[5]);
  var ModalContent = _interopDefault(_ModalContent);
  var _ModalFocusTrap = require(_dependencyMap[6]);
  var ModalFocusTrap = _interopDefault(_ModalFocusTrap);
  var _excluded = ["animationType", "children", "onDismiss", "onRequestClose", "onShow", "transparent", "visible"];
  var uniqueModalIdentifier = 0;
  var activeModalStack = [];
  var activeModalListeners = {};
  function notifyActiveModalListeners() {
    if (activeModalStack.length === 0) {
      return;
    }
    var activeModalId = activeModalStack[activeModalStack.length - 1];
    activeModalStack.forEach(modalId => {
      if (modalId in activeModalListeners) {
        activeModalListeners[modalId](modalId === activeModalId);
      }
    });
  }
  function removeActiveModal(modalId) {
    if (modalId in activeModalListeners) {
      // Before removing this listener we should probably tell it
      // that it's no longer the active modal for sure.
      activeModalListeners[modalId](false);
      delete activeModalListeners[modalId];
    }
    var index = activeModalStack.indexOf(modalId);
    if (index !== -1) {
      activeModalStack.splice(index, 1);
      notifyActiveModalListeners();
    }
  }
  function addActiveModal(modalId, listener) {
    removeActiveModal(modalId);
    activeModalStack.push(modalId);
    activeModalListeners[modalId] = listener;
    notifyActiveModalListeners();
  }
  var Modal = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var animationType = props.animationType,
      children = props.children,
      onDismiss = props.onDismiss,
      onRequestClose = props.onRequestClose,
      onShow = props.onShow,
      transparent = props.transparent,
      _props$visible = props.visible,
      visible = _props$visible === undefined ? true : _props$visible,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);

    // Set a unique model identifier so we can correctly route
    // dismissals and check the layering of modals.
    var modalId = React.useMemo(() => uniqueModalIdentifier++, []);
    var _React$useState = React.useState(false),
      isActive = _React$useState[0],
      setIsActive = _React$useState[1];
    var onDismissCallback = React.useCallback(() => {
      removeActiveModal(modalId);
      if (onDismiss) {
        onDismiss();
      }
    }, [modalId, onDismiss]);
    var onShowCallback = React.useCallback(() => {
      addActiveModal(modalId, setIsActive);
      if (onShow) {
        onShow();
      }
    }, [modalId, onShow]);
    React.useEffect(() => {
      return () => removeActiveModal(modalId);
    }, [modalId]);
    return /*#__PURE__*/React.createElement(ModalPortal.default, null, /*#__PURE__*/React.createElement(ModalAnimation.default, {
      animationType: animationType,
      onDismiss: onDismissCallback,
      onShow: onShowCallback,
      visible: visible
    }, /*#__PURE__*/React.createElement(ModalFocusTrap.default, {
      active: isActive
    }, /*#__PURE__*/React.createElement(ModalContent.default, (0, _extends.default)({}, rest, {
      active: isActive,
      onRequestClose: onRequestClose,
      ref: forwardedRef,
      transparent: transparent
    }), children))));
  });
  var _default = Modal;
},260,[28,44,35,261,262,263,264]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _react = require(_dependencyMap[0]);
  var React = _interopNamespace(_react);
  var _reactDom = require(_dependencyMap[1]);
  var _modulesCanUseDom = require(_dependencyMap[2]);
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function ModalPortal(props) {
    var children = props.children;
    var elementRef = React.useRef(null);
    if (canUseDOM.default && !elementRef.current) {
      var element = document.createElement('div');
      if (element && document.body) {
        document.body.appendChild(element);
        elementRef.current = element;
      }
    }
    React.useEffect(() => {
      if (canUseDOM.default) {
        return () => {
          if (document.body && elementRef.current) {
            document.body.removeChild(elementRef.current);
            elementRef.current = null;
          }
        };
      }
    }, []);
    return elementRef.current && canUseDOM.default ? /*#__PURE__*/(0, _reactDom.createPortal)(children, elementRef.current) : null;
  }
  var _default = ModalPortal;
},261,[35,37,40]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _react = require(_dependencyMap[0]);
  var React = _interopNamespace(_react);
  var _StyleSheet = require(_dependencyMap[1]);
  var StyleSheet = _interopDefault(_StyleSheet);
  var _createElement = require(_dependencyMap[2]);
  var createElement = _interopDefault(_createElement);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var ANIMATION_DURATION = 300;
  function getAnimationStyle(animationType, visible) {
    if (animationType === 'slide') {
      return visible ? animatedSlideInStyles : animatedSlideOutStyles;
    }
    if (animationType === 'fade') {
      return visible ? animatedFadeInStyles : animatedFadeOutStyles;
    }
    return visible ? styles.container : styles.hidden;
  }
  function ModalAnimation(props) {
    var animationType = props.animationType,
      children = props.children,
      onDismiss = props.onDismiss,
      onShow = props.onShow,
      visible = props.visible;
    var _React$useState = React.useState(false),
      isRendering = _React$useState[0],
      setIsRendering = _React$useState[1];
    var wasVisible = React.useRef(false);
    var wasRendering = React.useRef(false);
    var isAnimated = animationType && animationType !== 'none';
    var animationEndCallback = React.useCallback(e => {
      if (e && e.currentTarget !== e.target) {
        // If the event was generated for something NOT this element we
        // should ignore it as it's not relevant to us
        return;
      }
      if (visible) {
        if (onShow) {
          onShow();
        }
      } else {
        setIsRendering(false);
      }
    }, [onShow, visible]);
    React.useEffect(() => {
      if (wasRendering.current && !isRendering && onDismiss) {
        onDismiss();
      }
      wasRendering.current = isRendering;
    }, [isRendering, onDismiss]);
    React.useEffect(() => {
      if (visible) {
        setIsRendering(true);
      }
      if (visible !== wasVisible.current && !isAnimated) {
        // Manually call `animationEndCallback` if no animation is used
        animationEndCallback();
      }
      wasVisible.current = visible;
    }, [isAnimated, visible, animationEndCallback]);
    return isRendering || visible ? (0, createElement.default)('div', {
      style: isRendering ? getAnimationStyle(animationType, visible) : styles.hidden,
      onAnimationEnd: animationEndCallback,
      children
    }) : null;
  }
  var styles = StyleSheet.default.create({
    container: {
      position: 'fixed',
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      zIndex: 9999
    },
    animatedIn: {
      animationDuration: "300ms",
      animationTimingFunction: 'ease-in'
    },
    animatedOut: {
      pointerEvents: 'none',
      animationDuration: "300ms",
      animationTimingFunction: 'ease-out'
    },
    fadeIn: {
      opacity: 1,
      animationKeyframes: {
        '0%': {
          opacity: 0
        },
        '100%': {
          opacity: 1
        }
      }
    },
    fadeOut: {
      opacity: 0,
      animationKeyframes: {
        '0%': {
          opacity: 1
        },
        '100%': {
          opacity: 0
        }
      }
    },
    slideIn: {
      transform: 'translateY(0%)',
      animationKeyframes: {
        '0%': {
          transform: 'translateY(100%)'
        },
        '100%': {
          transform: 'translateY(0%)'
        }
      }
    },
    slideOut: {
      transform: 'translateY(100%)',
      animationKeyframes: {
        '0%': {
          transform: 'translateY(0%)'
        },
        '100%': {
          transform: 'translateY(100%)'
        }
      }
    },
    hidden: {
      opacity: 0
    }
  });
  var animatedSlideInStyles = [styles.container, styles.animatedIn, styles.slideIn];
  var animatedSlideOutStyles = [styles.container, styles.animatedOut, styles.slideOut];
  var animatedFadeInStyles = [styles.container, styles.animatedIn, styles.fadeIn];
  var animatedFadeOutStyles = [styles.container, styles.animatedOut, styles.fadeOut];
  var _default = ModalAnimation;
},262,[35,43,116]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2]);
  var React = _interopNamespace(_react);
  var _View = require(_dependencyMap[3]);
  var View = _interopDefault(_View);
  var _StyleSheet = require(_dependencyMap[4]);
  var StyleSheet = _interopDefault(_StyleSheet);
  var _modulesCanUseDom = require(_dependencyMap[5]);
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  var _excluded = ["active", "children", "onRequestClose", "transparent"];
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var ModalContent = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var active = props.active,
      children = props.children,
      onRequestClose = props.onRequestClose,
      transparent = props.transparent,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    React.useEffect(() => {
      if (canUseDOM.default) {
        var closeOnEscape = e => {
          if (active && e.key === 'Escape') {
            e.stopPropagation();
            if (onRequestClose) {
              onRequestClose();
            }
          }
        };
        document.addEventListener('keyup', closeOnEscape, false);
        return () => document.removeEventListener('keyup', closeOnEscape, false);
      }
    }, [active, onRequestClose]);
    var style = React.useMemo(() => {
      return [styles.modal, transparent ? styles.modalTransparent : styles.modalOpaque];
    }, [transparent]);
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, rest, {
      "aria-modal": true,
      ref: forwardedRef,
      role: active ? 'dialog' : null,
      style: style
    }), /*#__PURE__*/React.createElement(View.default, {
      style: styles.container
    }, children));
  });
  var styles = StyleSheet.default.create({
    modal: {
      position: 'fixed',
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    },
    modalTransparent: {
      backgroundColor: 'transparent'
    },
    modalOpaque: {
      backgroundColor: 'white'
    },
    container: {
      top: 0,
      flex: 1
    }
  });
  var _default = ModalContent;
},263,[28,44,35,138,43,40]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _react = require(_dependencyMap[0]);
  var React = _interopNamespace(_react);
  var _View = require(_dependencyMap[1]);
  var View = _interopDefault(_View);
  var _createElement = require(_dependencyMap[2]);
  var createElement = _interopDefault(_createElement);
  var _StyleSheet = require(_dependencyMap[3]);
  var StyleSheet = _interopDefault(_StyleSheet);
  var _UIManager = require(_dependencyMap[4]);
  var UIManager = _interopDefault(_UIManager);
  var _modulesCanUseDom = require(_dependencyMap[5]);
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * This Component is used to "wrap" the modal we're opening
   * so that changing focus via tab will never leave the document.
   *
   * This allows us to properly trap the focus within a modal
   * even if the modal is at the start or end of a document.
   */

  var FocusBracket = () => {
    return (0, createElement.default)('div', {
      role: 'none',
      tabIndex: 0,
      style: styles.focusBracket
    });
  };
  function attemptFocus(element) {
    if (!canUseDOM.default) {
      return false;
    }
    try {
      element.focus();
    } catch (e) {
      // Do nothing
    }
    return document.activeElement === element;
  }
  function focusFirstDescendant(element) {
    for (var i = 0; i < element.childNodes.length; i++) {
      var child = element.childNodes[i];
      if (attemptFocus(child) || focusFirstDescendant(child)) {
        return true;
      }
    }
    return false;
  }
  function focusLastDescendant(element) {
    for (var i = element.childNodes.length - 1; i >= 0; i--) {
      var child = element.childNodes[i];
      if (attemptFocus(child) || focusLastDescendant(child)) {
        return true;
      }
    }
    return false;
  }
  var ModalFocusTrap = _ref => {
    var active = _ref.active,
      children = _ref.children;
    var trapElementRef = React.useRef();
    var focusRef = React.useRef({
      trapFocusInProgress: false,
      lastFocusedElement: null
    });
    React.useEffect(() => {
      if (canUseDOM.default) {
        var trapFocus = () => {
          // We should not trap focus if:
          // - The modal hasn't fully initialized with an HTMLElement ref
          // - Focus is already in the process of being trapped (e.g., we're refocusing)
          // - isTrapActive prop being falsey tells us to do nothing
          if (trapElementRef.current == null || focusRef.current.trapFocusInProgress || !active) {
            return;
          }
          try {
            focusRef.current.trapFocusInProgress = true;
            if (document.activeElement instanceof Node && !trapElementRef.current.contains(document.activeElement)) {
              // To handle keyboard focusing we can make an assumption here.
              // If you're tabbing through the focusable elements, the previously
              // active element will either be the first or the last.
              // If the previously selected element is the "first" descendant
              // and we're leaving it - this means that we should be looping
              // around to the other side of the modal.
              var hasFocused = focusFirstDescendant(trapElementRef.current);
              if (focusRef.current.lastFocusedElement === document.activeElement) {
                hasFocused = focusLastDescendant(trapElementRef.current);
              }
              // If we couldn't focus a new element then we need to focus onto the trap target
              if (!hasFocused && trapElementRef.current != null && document.activeElement) {
                UIManager.default.focus(trapElementRef.current);
              }
            }
          } finally {
            focusRef.current.trapFocusInProgress = false;
          }
          focusRef.current.lastFocusedElement = document.activeElement;
        };

        // Call the trapFocus callback at least once when this modal has been activated.
        trapFocus();
        document.addEventListener('focus', trapFocus, true);
        return () => document.removeEventListener('focus', trapFocus, true);
      }
    }, [active]);

    // To be fully compliant with WCAG we need to refocus element that triggered opening modal
    // after closing it
    React.useEffect(function () {
      if (canUseDOM.default) {
        var lastFocusedElementOutsideTrap = document.activeElement;
        return function () {
          if (lastFocusedElementOutsideTrap && document.contains(lastFocusedElementOutsideTrap)) {
            UIManager.default.focus(lastFocusedElementOutsideTrap);
          }
        };
      }
    }, []);
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(FocusBracket, null), /*#__PURE__*/React.createElement(View.default, {
      ref: trapElementRef
    }, children), /*#__PURE__*/React.createElement(FocusBracket, null));
  };
  var _default = ModalFocusTrap;
  var styles = StyleSheet.default.create({
    focusBracket: {
      outlineStyle: 'none'
    }
  });
},264,[35,138,116,43,126,40]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2]);
  var React = _interopNamespace(_react);
  var _createElement = require(_dependencyMap[3]);
  var createElement = _interopDefault(_createElement);
  var _modulesUseMergeRefs = require(_dependencyMap[4]);
  var useMergeRefs = _interopDefault(_modulesUseMergeRefs);
  var _modulesUsePlatformMethods = require(_dependencyMap[5]);
  var usePlatformMethods = _interopDefault(_modulesUsePlatformMethods);
  var _PickerItem = require(_dependencyMap[6]);
  var PickerItem = _interopDefault(_PickerItem);
  var _StyleSheet = require(_dependencyMap[7]);
  var StyleSheet = _interopDefault(_StyleSheet);
  var _excluded = ["children", "enabled", "onValueChange", "selectedValue", "style", "testID", "itemStyle", "mode", "prompt"];
  var Picker = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var children = props.children,
      enabled = props.enabled,
      onValueChange = props.onValueChange,
      selectedValue = props.selectedValue,
      style = props.style,
      testID = props.testID,
      itemStyle = props.itemStyle,
      mode = props.mode,
      prompt = props.prompt,
      other = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    var hostRef = React.useRef(null);
    function handleChange(e) {
      var _e$target = e.target,
        selectedIndex = _e$target.selectedIndex,
        value = _e$target.value;
      if (onValueChange) {
        onValueChange(value, selectedIndex);
      }
    }

    // $FlowFixMe
    var supportedProps = (0, _objectSpread.default)({
      children,
      disabled: enabled === false ? true : undefined,
      onChange: handleChange,
      style: [styles.initial, style],
      testID,
      value: selectedValue
    }, other);
    var platformMethodsRef = (0, usePlatformMethods.default)(supportedProps);
    var setRef = (0, useMergeRefs.default)(hostRef, platformMethodsRef, forwardedRef);
    supportedProps.ref = setRef;
    return (0, createElement.default)('select', supportedProps);
  });

  // $FlowFixMe
  Picker.Item = PickerItem.default;
  var styles = StyleSheet.default.create({
    initial: {
      fontFamily: 'System',
      fontSize: 'inherit',
      margin: 0
    }
  });
  var _default = Picker;
},265,[20,44,35,116,143,145,266,43]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return PickerItem;
    }
  });
  var _createElement = require(_dependencyMap[0]);
  var createElement = _interopDefault(_createElement);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function PickerItem(props) {
    var color = props.color,
      label = props.label,
      testID = props.testID,
      value = props.value;
    var style = {
      color
    };
    return (0, createElement.default)('option', {
      children: label,
      style,
      testID,
      value
    });
  }
},266,[116]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2]);
  var React = _interopNamespace(_react);
  var _modulesUseMergeRefs = require(_dependencyMap[3]);
  var useMergeRefs = _interopDefault(_modulesUseMergeRefs);
  var _modulesUseHover = require(_dependencyMap[4]);
  var useHover = _interopDefault(_modulesUseHover);
  var _modulesUsePressEvents = require(_dependencyMap[5]);
  var usePressEvents = _interopDefault(_modulesUsePressEvents);
  var _StyleSheet = require(_dependencyMap[6]);
  var StyleSheet = _interopDefault(_StyleSheet);
  var _View = require(_dependencyMap[7]);
  var View = _interopDefault(_View);
  var _excluded = ["children", "delayLongPress", "delayPressIn", "delayPressOut", "disabled", "onBlur", "onContextMenu", "onFocus", "onHoverIn", "onHoverOut", "onKeyDown", "onLongPress", "onPress", "onPressMove", "onPressIn", "onPressOut", "style", "tabIndex", "testOnly_hovered", "testOnly_pressed"];
  /**
   * Component used to build display components that should respond to whether the
   * component is currently pressed or not.
   */
  function Pressable(props, forwardedRef) {
    var children = props.children,
      delayLongPress = props.delayLongPress,
      delayPressIn = props.delayPressIn,
      delayPressOut = props.delayPressOut,
      disabled = props.disabled,
      onBlur = props.onBlur,
      onContextMenu = props.onContextMenu,
      onFocus = props.onFocus,
      onHoverIn = props.onHoverIn,
      onHoverOut = props.onHoverOut,
      onKeyDown = props.onKeyDown,
      onLongPress = props.onLongPress,
      onPress = props.onPress,
      onPressMove = props.onPressMove,
      onPressIn = props.onPressIn,
      onPressOut = props.onPressOut,
      style = props.style,
      tabIndex = props.tabIndex,
      testOnly_hovered = props.testOnly_hovered,
      testOnly_pressed = props.testOnly_pressed,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    var _useForceableState = useForceableState(testOnly_hovered === true),
      hovered = _useForceableState[0],
      setHovered = _useForceableState[1];
    var _useForceableState2 = useForceableState(false),
      focused = _useForceableState2[0],
      setFocused = _useForceableState2[1];
    var _useForceableState3 = useForceableState(testOnly_pressed === true),
      pressed = _useForceableState3[0],
      setPressed = _useForceableState3[1];
    var hostRef = (0, _react.useRef)(null);
    var setRef = (0, useMergeRefs.default)(forwardedRef, hostRef);
    var pressConfig = (0, _react.useMemo)(() => ({
      delayLongPress,
      delayPressStart: delayPressIn,
      delayPressEnd: delayPressOut,
      disabled,
      onLongPress,
      onPress,
      onPressChange: setPressed,
      onPressStart: onPressIn,
      onPressMove,
      onPressEnd: onPressOut
    }), [delayLongPress, delayPressIn, delayPressOut, disabled, onLongPress, onPress, onPressIn, onPressMove, onPressOut, setPressed]);
    var pressEventHandlers = (0, usePressEvents.default)(hostRef, pressConfig);
    var onContextMenuPress = pressEventHandlers.onContextMenu,
      onKeyDownPress = pressEventHandlers.onKeyDown;
    (0, useHover.default)(hostRef, {
      contain: true,
      disabled,
      onHoverChange: setHovered,
      onHoverStart: onHoverIn,
      onHoverEnd: onHoverOut
    });
    var interactionState = {
      hovered,
      focused,
      pressed
    };
    var blurHandler = React.useCallback(e => {
      if (e.nativeEvent.target === hostRef.current) {
        setFocused(false);
        if (onBlur != null) {
          onBlur(e);
        }
      }
    }, [hostRef, setFocused, onBlur]);
    var focusHandler = React.useCallback(e => {
      if (e.nativeEvent.target === hostRef.current) {
        setFocused(true);
        if (onFocus != null) {
          onFocus(e);
        }
      }
    }, [hostRef, setFocused, onFocus]);
    var contextMenuHandler = React.useCallback(e => {
      if (onContextMenuPress != null) {
        onContextMenuPress(e);
      }
      if (onContextMenu != null) {
        onContextMenu(e);
      }
    }, [onContextMenu, onContextMenuPress]);
    var keyDownHandler = React.useCallback(e => {
      if (onKeyDownPress != null) {
        onKeyDownPress(e);
      }
      if (onKeyDown != null) {
        onKeyDown(e);
      }
    }, [onKeyDown, onKeyDownPress]);
    var _tabIndex;
    if (tabIndex !== undefined) {
      _tabIndex = tabIndex;
    } else {
      _tabIndex = disabled ? -1 : 0;
    }
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, rest, pressEventHandlers, {
      "aria-disabled": disabled,
      onBlur: blurHandler,
      onContextMenu: contextMenuHandler,
      onFocus: focusHandler,
      onKeyDown: keyDownHandler,
      ref: setRef,
      style: [disabled ? styles.disabled : styles.active, typeof style === 'function' ? style(interactionState) : style],
      tabIndex: _tabIndex
    }), typeof children === 'function' ? children(interactionState) : children);
  }
  function useForceableState(forced) {
    var _useState = (0, _react.useState)(false),
      bool = _useState[0],
      setBool = _useState[1];
    return [bool || forced, setBool];
  }
  var styles = StyleSheet.default.create({
    active: {
      cursor: 'pointer',
      touchAction: 'manipulation'
    },
    disabled: {
      pointerEvents: 'box-none'
    }
  });
  var MemoedPressable = /*#__PURE__*/(0, _react.memo)(/*#__PURE__*/(0, _react.forwardRef)(Pressable));
  MemoedPressable.displayName = 'Pressable';
  var _default = MemoedPressable;
},267,[28,44,35,143,268,255,43,138]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useHover;
    }
  });
  var _modality = require(_dependencyMap[0]);
  var _useEvent = require(_dependencyMap[1]);
  var useEvent = _interopDefault(_useEvent);
  var _useLayoutEffect = require(_dependencyMap[2]);
  var useLayoutEffect = _interopDefault(_useLayoutEffect);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * Types
   */

  /**
   * Implementation
   */

  var emptyObject = {};
  var opts = {
    passive: true
  };
  var lockEventType = 'react-gui:hover:lock';
  var unlockEventType = 'react-gui:hover:unlock';
  var supportsPointerEvent = () => !!(typeof window !== 'undefined' && window.PointerEvent != null);
  function dispatchCustomEvent(target, type, payload) {
    var event = document.createEvent('CustomEvent');
    var _ref = payload || emptyObject,
      _ref$bubbles = _ref.bubbles,
      bubbles = _ref$bubbles === undefined ? true : _ref$bubbles,
      _ref$cancelable = _ref.cancelable,
      cancelable = _ref$cancelable === undefined ? true : _ref$cancelable,
      detail = _ref.detail;
    event.initCustomEvent(type, bubbles, cancelable, detail);
    target.dispatchEvent(event);
  }

  // This accounts for the non-PointerEvent fallback events.
  function getPointerType(event) {
    var pointerType = event.pointerType;
    return pointerType != null ? pointerType : (0, _modality.getModality)();
  }
  function useHover(targetRef, config) {
    var contain = config.contain,
      disabled = config.disabled,
      onHoverStart = config.onHoverStart,
      onHoverChange = config.onHoverChange,
      onHoverUpdate = config.onHoverUpdate,
      onHoverEnd = config.onHoverEnd;
    var canUsePE = supportsPointerEvent();
    var addMoveListener = (0, useEvent.default)(canUsePE ? 'pointermove' : 'mousemove', opts);
    var addEnterListener = (0, useEvent.default)(canUsePE ? 'pointerenter' : 'mouseenter', opts);
    var addLeaveListener = (0, useEvent.default)(canUsePE ? 'pointerleave' : 'mouseleave', opts);
    // These custom events are used to implement the "contain" prop.
    var addLockListener = (0, useEvent.default)(lockEventType, opts);
    var addUnlockListener = (0, useEvent.default)(unlockEventType, opts);
    (0, useLayoutEffect.default)(() => {
      var target = targetRef.current;
      if (target !== null) {
        /**
         * End the hover gesture
         */
        var hoverEnd = function hoverEnd(e) {
          if (onHoverEnd != null) {
            onHoverEnd(e);
          }
          if (onHoverChange != null) {
            onHoverChange(false);
          }
          // Remove the listeners once finished.
          addMoveListener(target, null);
          addLeaveListener(target, null);
        };

        /**
         * Leave element
         */
        var leaveListener = function leaveListener(e) {
          var target = targetRef.current;
          if (target != null && getPointerType(e) !== 'touch') {
            if (contain) {
              dispatchCustomEvent(target, unlockEventType);
            }
            hoverEnd(e);
          }
        };

        /**
         * Move within element
         */
        var moveListener = function moveListener(e) {
          if (getPointerType(e) !== 'touch') {
            if (onHoverUpdate != null) {
              // Not all browsers have these properties
              if (e.x == null) {
                e.x = e.clientX;
              }
              if (e.y == null) {
                e.y = e.clientY;
              }
              onHoverUpdate(e);
            }
          }
        };

        /**
         * Start the hover gesture
         */
        var hoverStart = function hoverStart(e) {
          if (onHoverStart != null) {
            onHoverStart(e);
          }
          if (onHoverChange != null) {
            onHoverChange(true);
          }
          // Set the listeners needed for the rest of the hover gesture.
          if (onHoverUpdate != null) {
            addMoveListener(target, !disabled ? moveListener : null);
          }
          addLeaveListener(target, !disabled ? leaveListener : null);
        };

        /**
         * Enter element
         */
        var enterListener = function enterListener(e) {
          var target = targetRef.current;
          if (target != null && getPointerType(e) !== 'touch') {
            if (contain) {
              dispatchCustomEvent(target, lockEventType);
            }
            hoverStart(e);
            var lockListener = function lockListener(lockEvent) {
              if (lockEvent.target !== target) {
                hoverEnd(e);
              }
            };
            var unlockListener = function unlockListener(lockEvent) {
              if (lockEvent.target !== target) {
                hoverStart(e);
              }
            };
            addLockListener(target, !disabled ? lockListener : null);
            addUnlockListener(target, !disabled ? unlockListener : null);
          }
        };
        addEnterListener(target, !disabled ? enterListener : null);
      }
    }, [addEnterListener, addMoveListener, addLeaveListener, addLockListener, addUnlockListener, contain, disabled, onHoverStart, onHoverChange, onHoverUpdate, onHoverEnd, targetRef]);
  }
},268,[269,271,142]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.getActiveModality = getActiveModality;
  exports.getModality = getModality;
  exports.addModalityListener = addModalityListener;
  exports.testOnly_resetActiveModality = testOnly_resetActiveModality;
  var _addEventListener = require(_dependencyMap[0]);
  var _canUseDom = require(_dependencyMap[1]);
  var canUseDOM = _interopDefault(_canUseDom);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var supportsPointerEvent = () => !!(typeof window !== 'undefined' && window.PointerEvent != null);
  var activeModality = 'keyboard';
  var modality = 'keyboard';
  var previousModality;
  var previousActiveModality;
  var isEmulatingMouseEvents = false;
  var listeners = new Set();
  var KEYBOARD = 'keyboard';
  var MOUSE = 'mouse';
  var TOUCH = 'touch';
  var BLUR = 'blur';
  var CONTEXTMENU = 'contextmenu';
  var FOCUS = 'focus';
  var KEYDOWN = 'keydown';
  var MOUSEDOWN = 'mousedown';
  var MOUSEMOVE = 'mousemove';
  var MOUSEUP = 'mouseup';
  var POINTERDOWN = 'pointerdown';
  var POINTERMOVE = 'pointermove';
  var SCROLL = 'scroll';
  var SELECTIONCHANGE = 'selectionchange';
  var TOUCHCANCEL = 'touchcancel';
  var TOUCHMOVE = 'touchmove';
  var TOUCHSTART = 'touchstart';
  var VISIBILITYCHANGE = 'visibilitychange';
  var bubbleOptions = {
    passive: true
  };
  var captureOptions = {
    capture: true,
    passive: true
  };
  function restoreModality() {
    if (previousModality != null || previousActiveModality != null) {
      if (previousModality != null) {
        modality = previousModality;
        previousModality = null;
      }
      if (previousActiveModality != null) {
        activeModality = previousActiveModality;
        previousActiveModality = null;
      }
      callListeners();
    }
  }
  function onBlurWindow() {
    previousModality = modality;
    previousActiveModality = activeModality;
    activeModality = KEYBOARD;
    modality = KEYBOARD;
    callListeners();
    // for fallback events
    isEmulatingMouseEvents = false;
  }
  function onFocusWindow() {
    restoreModality();
  }
  function onKeyDown(event) {
    if (event.metaKey || event.altKey || event.ctrlKey) {
      return;
    }
    if (modality !== KEYBOARD) {
      modality = KEYBOARD;
      activeModality = KEYBOARD;
      callListeners();
    }
  }
  function onVisibilityChange() {
    if (document.visibilityState !== 'hidden') {
      restoreModality();
    }
  }
  function onPointerish(event) {
    var eventType = event.type;
    if (supportsPointerEvent()) {
      if (eventType === POINTERDOWN) {
        if (activeModality !== event.pointerType) {
          modality = event.pointerType;
          activeModality = event.pointerType;
          callListeners();
        }
        return;
      }
      if (eventType === POINTERMOVE) {
        if (modality !== event.pointerType) {
          modality = event.pointerType;
          callListeners();
        }
        return;
      }
    }
    // Fallback for non-PointerEvent environment
    else {
      if (!isEmulatingMouseEvents) {
        if (eventType === MOUSEDOWN) {
          if (activeModality !== MOUSE) {
            modality = MOUSE;
            activeModality = MOUSE;
            callListeners();
          }
        }
        if (eventType === MOUSEMOVE) {
          if (modality !== MOUSE) {
            modality = MOUSE;
            callListeners();
          }
        }
      }

      // Flag when browser may produce emulated events
      if (eventType === TOUCHSTART) {
        isEmulatingMouseEvents = true;
        if (event.touches && event.touches.length > 1) {
          isEmulatingMouseEvents = false;
        }
        if (activeModality !== TOUCH) {
          modality = TOUCH;
          activeModality = TOUCH;
          callListeners();
        }
        return;
      }

      // Remove flag after emulated events are finished or cancelled, and if an
      // event occurs that cuts short a touch event sequence.
      if (eventType === CONTEXTMENU || eventType === MOUSEUP || eventType === SELECTIONCHANGE || eventType === SCROLL || eventType === TOUCHCANCEL || eventType === TOUCHMOVE) {
        isEmulatingMouseEvents = false;
      }
    }
  }
  if (canUseDOM.default) {
    // Window events
    (0, _addEventListener.addEventListener)(window, BLUR, onBlurWindow, bubbleOptions);
    (0, _addEventListener.addEventListener)(window, FOCUS, onFocusWindow, bubbleOptions);
    // Must be capture phase because 'stopPropagation' might prevent these
    // events bubbling to the document.
    (0, _addEventListener.addEventListener)(document, KEYDOWN, onKeyDown, captureOptions);
    (0, _addEventListener.addEventListener)(document, VISIBILITYCHANGE, onVisibilityChange, captureOptions);
    (0, _addEventListener.addEventListener)(document, POINTERDOWN, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, POINTERMOVE, onPointerish, captureOptions);
    // Fallback events
    (0, _addEventListener.addEventListener)(document, CONTEXTMENU, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, MOUSEDOWN, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, MOUSEMOVE, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, MOUSEUP, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, TOUCHCANCEL, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, TOUCHMOVE, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, TOUCHSTART, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, SELECTIONCHANGE, onPointerish, captureOptions);
    (0, _addEventListener.addEventListener)(document, SCROLL, onPointerish, captureOptions);
  }
  function callListeners() {
    var value = {
      activeModality,
      modality
    };
    listeners.forEach(listener => {
      listener(value);
    });
  }
  function getActiveModality() {
    return activeModality;
  }
  function getModality() {
    return modality;
  }
  function addModalityListener(listener) {
    listeners.add(listener);
    return () => {
      listeners.delete(listener);
    };
  }
  function testOnly_resetActiveModality() {
    isEmulatingMouseEvents = false;
    activeModality = KEYBOARD;
    modality = KEYBOARD;
  }
},269,[270,40]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.addEventListener = addEventListener;
  var _canUseDom = require(_dependencyMap[0]);
  var canUseDOM = _interopDefault(_canUseDom);
  var emptyFunction = () => {};
  function supportsPassiveEvents() {
    var supported = false;
    // Check if browser supports event with passive listeners
    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
    if (canUseDOM.default) {
      try {
        var options = {};
        Object.defineProperty(options, 'passive', {
          get() {
            supported = true;
            return false;
          }
        });
        window.addEventListener('test', null, options);
        window.removeEventListener('test', null, options);
      } catch (e) {}
    }
    return supported;
  }
  var canUsePassiveEvents = supportsPassiveEvents();
  function getOptions(options) {
    if (options == null) {
      return false;
    }
    return canUsePassiveEvents ? options : Boolean(options.capture);
  }

  /**
   * Shim generic API compatibility with ReactDOM's synthetic events, without needing the
   * large amount of code ReactDOM uses to do this. Ideally we wouldn't use a synthetic
   * event wrapper at all.
   */
  function isPropagationStopped() {
    return this.cancelBubble;
  }
  function isDefaultPrevented() {
    return this.defaultPrevented;
  }
  function normalizeEvent(event) {
    event.nativeEvent = event;
    event.persist = emptyFunction;
    event.isDefaultPrevented = isDefaultPrevented;
    event.isPropagationStopped = isPropagationStopped;
    return event;
  }

  /**
   *
   */
  function addEventListener(target, type, listener, options) {
    var opts = getOptions(options);
    var compatListener = e => listener(normalizeEvent(e));
    target.addEventListener(type, compatListener, opts);
    return function removeEventListener() {
      if (target != null) {
        target.removeEventListener(type, compatListener, opts);
      }
    };
  }
},270,[40]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useEvent;
    }
  });
  var _addEventListener = require(_dependencyMap[0]);
  var _useLayoutEffect = require(_dependencyMap[1]);
  var useLayoutEffect = _interopDefault(_useLayoutEffect);
  var _useStable = require(_dependencyMap[2]);
  var useStable = _interopDefault(_useStable);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * This can be used with any event type include custom events.
   *
   * const click = useEvent('click', options);
   * useEffect(() => {
   *   click.setListener(target, onClick);
   *   return () => click.clear();
   * }).
   */
  function useEvent(eventType, options) {
    var targetListeners = (0, useStable.default)(() => new Map());
    var addListener = (0, useStable.default)(() => {
      return (target, callback) => {
        var removeTargetListener = targetListeners.get(target);
        if (removeTargetListener != null) {
          removeTargetListener();
        }
        if (callback == null) {
          targetListeners.delete(target);
          callback = () => {};
        }
        var removeEventListener = (0, _addEventListener.addEventListener)(target, eventType, callback, options);
        targetListeners.set(target, removeEventListener);
        return removeEventListener;
      };
    });
    (0, useLayoutEffect.default)(() => {
      return () => {
        targetListeners.forEach(removeListener => {
          removeListener();
        });
        targetListeners.clear();
      };
    }, [targetListeners]);
    return addListener;
  }
},271,[270,142,146]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2]);
  var React = _interopNamespace(_react);
  var _StyleSheet = require(_dependencyMap[3]);
  var StyleSheet = _interopDefault(_StyleSheet);
  var _View = require(_dependencyMap[4]);
  var View = _interopDefault(_View);
  var _excluded = ["color", "indeterminate", "progress", "trackColor", "style"];
  var ProgressBar = /*#__PURE__*/React.forwardRef((props, ref) => {
    var _props$color = props.color,
      color = _props$color === undefined ? '#1976D2' : _props$color,
      _props$indeterminate = props.indeterminate,
      indeterminate = _props$indeterminate === undefined ? false : _props$indeterminate,
      _props$progress = props.progress,
      progress = _props$progress === undefined ? 0 : _props$progress,
      _props$trackColor = props.trackColor,
      trackColor = _props$trackColor === undefined ? 'transparent' : _props$trackColor,
      style = props.style,
      other = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    var percentageProgress = progress * 100;
    var width = indeterminate ? '25%' : percentageProgress + "%";
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, other, {
      "aria-valuemax": 100,
      "aria-valuemin": 0,
      "aria-valuenow": indeterminate ? null : percentageProgress,
      ref: ref,
      role: "progressbar",
      style: [styles.track, style, {
        backgroundColor: trackColor
      }]
    }), /*#__PURE__*/React.createElement(View.default, {
      style: [{
        backgroundColor: color,
        width
      }, styles.progress, indeterminate && styles.animation]
    }));
  });
  ProgressBar.displayName = 'ProgressBar';
  var styles = StyleSheet.default.create({
    track: {
      forcedColorAdjust: 'none',
      height: 5,
      overflow: 'hidden',
      userSelect: 'none',
      zIndex: 0
    },
    progress: {
      forcedColorAdjust: 'none',
      height: '100%',
      zIndex: -1
    },
    animation: {
      animationDuration: '1s',
      animationKeyframes: [{
        '0%': {
          transform: 'translateX(-100%)'
        },
        '100%': {
          transform: 'translateX(400%)'
        }
      }],
      animationTimingFunction: 'linear',
      animationIterationCount: 'infinite'
    }
  });
  var _default = ProgressBar;
},272,[28,44,35,43,138]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2]);
  var React = _interopNamespace(_react);
  var _StyleSheet = require(_dependencyMap[3]);
  var StyleSheet = _interopDefault(_StyleSheet);
  var _View = require(_dependencyMap[4]);
  var View = _interopDefault(_View);
  var _modulesCanUseDom = require(_dependencyMap[5]);
  var canUseDOM = _interopDefault(_modulesCanUseDom);
  var _excluded = ["style"];
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var cssFunction = function () {
    if (canUseDOM.default && window.CSS && window.CSS.supports && window.CSS.supports('top: constant(safe-area-inset-top)')) {
      return 'constant';
    }
    return 'env';
  }();
  var SafeAreaView = /*#__PURE__*/React.forwardRef((props, ref) => {
    var style = props.style,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, rest, {
      ref: ref,
      style: [styles.root, style]
    }));
  });
  SafeAreaView.displayName = 'SafeAreaView';
  var styles = StyleSheet.default.create({
    root: {
      paddingTop: cssFunction + "(safe-area-inset-top)",
      paddingRight: cssFunction + "(safe-area-inset-right)",
      paddingBottom: cssFunction + "(safe-area-inset-bottom)",
      paddingLeft: cssFunction + "(safe-area-inset-left)"
    }
  });
  var _default = SafeAreaView;
},273,[28,44,35,43,138,40]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var emptyFunction = () => {};
  function StatusBar() {
    return null;
  }
  StatusBar.setBackgroundColor = emptyFunction;
  StatusBar.setBarStyle = emptyFunction;
  StatusBar.setHidden = emptyFunction;
  StatusBar.setNetworkActivityIndicatorVisible = emptyFunction;
  StatusBar.setTranslucent = emptyFunction;
  var _default = StatusBar;
},274,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[0]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _babelRuntimeHelpersExtends = require(_dependencyMap[1]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[2]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[3]);
  var React = _interopNamespace(_react);
  var _createElement = require(_dependencyMap[4]);
  var createElement = _interopDefault(_createElement);
  var _modulesMultiplyStyleLengthValue = require(_dependencyMap[5]);
  var multiplyStyleLengthValue = _interopDefault(_modulesMultiplyStyleLengthValue);
  var _StyleSheet = require(_dependencyMap[6]);
  var StyleSheet = _interopDefault(_StyleSheet);
  var _View = require(_dependencyMap[7]);
  var View = _interopDefault(_View);
  var _excluded = ["aria-label", "accessibilityLabel", "activeThumbColor", "activeTrackColor", "disabled", "onValueChange", "style", "thumbColor", "trackColor", "value"];
  var emptyObject = {};
  var thumbDefaultBoxShadow = '0px 1px 3px rgba(0,0,0,0.5)';
  var thumbFocusedBoxShadow = "0px 1px 3px rgba(0,0,0,0.5), 0 0 0 10px rgba(0,0,0,0.1)";
  var defaultActiveTrackColor = '#A3D3CF';
  var defaultTrackColor = '#939393';
  var defaultDisabledTrackColor = '#D5D5D5';
  var defaultActiveThumbColor = '#009688';
  var defaultThumbColor = '#FAFAFA';
  var defaultDisabledThumbColor = '#BDBDBD';
  var Switch = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var ariaLabel = props['aria-label'],
      accessibilityLabel = props.accessibilityLabel,
      activeThumbColor = props.activeThumbColor,
      activeTrackColor = props.activeTrackColor,
      _props$disabled = props.disabled,
      disabled = _props$disabled === undefined ? false : _props$disabled,
      onValueChange = props.onValueChange,
      _props$style = props.style,
      style = _props$style === undefined ? emptyObject : _props$style,
      thumbColor = props.thumbColor,
      trackColor = props.trackColor,
      _props$value = props.value,
      value = _props$value === undefined ? false : _props$value,
      other = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    var thumbRef = React.useRef(null);
    function handleChange(event) {
      if (onValueChange != null) {
        onValueChange(event.nativeEvent.target.checked);
      }
    }
    function handleFocusState(event) {
      var isFocused = event.nativeEvent.type === 'focus';
      var boxShadow = isFocused ? thumbFocusedBoxShadow : thumbDefaultBoxShadow;
      if (thumbRef.current != null) {
        thumbRef.current.style.boxShadow = boxShadow;
      }
    }
    var _StyleSheet$flatten = StyleSheet.default.flatten(style),
      styleHeight = _StyleSheet$flatten.height,
      styleWidth = _StyleSheet$flatten.width;
    var height = styleHeight || '20px';
    var minWidth = (0, multiplyStyleLengthValue.default)(height, 2);
    var width = styleWidth > minWidth ? styleWidth : minWidth;
    var trackBorderRadius = (0, multiplyStyleLengthValue.default)(height, 0.5);
    var trackCurrentColor = function () {
      if (value === true) {
        if (trackColor != null && typeof trackColor === 'object') {
          return trackColor.true;
        } else {
          return activeTrackColor !== null && activeTrackColor !== undefined ? activeTrackColor : defaultActiveTrackColor;
        }
      } else {
        if (trackColor != null && typeof trackColor === 'object') {
          return trackColor.false;
        } else {
          return trackColor !== null && trackColor !== undefined ? trackColor : defaultTrackColor;
        }
      }
    }();
    var thumbCurrentColor = value ? activeThumbColor !== null && activeThumbColor !== undefined ? activeThumbColor : defaultActiveThumbColor : thumbColor !== null && thumbColor !== undefined ? thumbColor : defaultThumbColor;
    var thumbHeight = height;
    var thumbWidth = thumbHeight;
    var rootStyle = [styles.root, style, disabled && styles.cursorDefault, {
      height,
      width
    }];
    var disabledTrackColor = function () {
      if (value === true) {
        if (typeof activeTrackColor === 'string' && activeTrackColor != null || typeof trackColor === 'object' && trackColor != null && trackColor.true) {
          return trackCurrentColor;
        } else {
          return defaultDisabledTrackColor;
        }
      } else {
        if (typeof trackColor === 'string' && trackColor != null || typeof trackColor === 'object' && trackColor != null && trackColor.false) {
          return trackCurrentColor;
        } else {
          return defaultDisabledTrackColor;
        }
      }
    }();
    var disabledThumbColor = function () {
      if (value === true) {
        if (activeThumbColor == null) {
          return defaultDisabledThumbColor;
        } else {
          return thumbCurrentColor;
        }
      } else {
        if (thumbColor == null) {
          return defaultDisabledThumbColor;
        } else {
          return thumbCurrentColor;
        }
      }
    }();
    var trackStyle = [styles.track, {
      backgroundColor: disabled ? disabledTrackColor : trackCurrentColor,
      borderRadius: trackBorderRadius
    }];
    var thumbStyle = [styles.thumb, value && styles.thumbActive, {
      backgroundColor: disabled ? disabledThumbColor : thumbCurrentColor,
      height: thumbHeight,
      marginStart: value ? (0, multiplyStyleLengthValue.default)(thumbWidth, -1) : 0,
      width: thumbWidth
    }];
    var nativeControl = (0, createElement.default)('input', {
      'aria-label': ariaLabel || accessibilityLabel,
      checked: value,
      disabled: disabled,
      onBlur: handleFocusState,
      onChange: handleChange,
      onFocus: handleFocusState,
      ref: forwardedRef,
      style: [styles.nativeControl, styles.cursorInherit],
      type: 'checkbox',
      role: 'switch'
    });
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, other, {
      style: rootStyle
    }), /*#__PURE__*/React.createElement(View.default, {
      style: trackStyle
    }), /*#__PURE__*/React.createElement(View.default, {
      ref: thumbRef,
      style: thumbStyle
    }), nativeControl);
  });
  Switch.displayName = 'Switch';
  var styles = StyleSheet.default.create({
    root: {
      cursor: 'pointer',
      userSelect: 'none'
    },
    cursorDefault: {
      cursor: 'default'
    },
    cursorInherit: {
      cursor: 'inherit'
    },
    track: (0, _objectSpread.default)((0, _objectSpread.default)({
      forcedColorAdjust: 'none'
    }, StyleSheet.default.absoluteFillObject), {}, {
      height: '70%',
      margin: 'auto',
      transitionDuration: '0.1s',
      width: '100%'
    }),
    thumb: {
      forcedColorAdjust: 'none',
      alignSelf: 'flex-start',
      borderRadius: '100%',
      boxShadow: thumbDefaultBoxShadow,
      start: '0%',
      transform: 'translateZ(0)',
      transitionDuration: '0.1s'
    },
    thumbActive: {
      insetInlineStart: '100%'
    },
    nativeControl: (0, _objectSpread.default)((0, _objectSpread.default)({}, StyleSheet.default.absoluteFillObject), {}, {
      height: '100%',
      margin: 0,
      appearance: 'none',
      padding: 0,
      width: '100%'
    })
  });
  var _default = Switch;
},275,[20,28,44,35,116,276,43,138]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var CSS_UNIT_RE = /^[+-]?\d*(?:\.\d+)?(?:[Ee][+-]?\d+)?(%|\w*)/;
  var getUnit = str => str.match(CSS_UNIT_RE)[1];
  var isNumeric = n => {
    return !isNaN(parseFloat(n)) && isFinite(n);
  };
  var multiplyStyleLengthValue = (value, multiple) => {
    if (typeof value === 'string') {
      var number = parseFloat(value) * multiple;
      var unit = getUnit(value);
      return "" + number + unit;
    } else if (isNumeric(value)) {
      return value * multiple;
    }
  };
  var _default = multiplyStyleLengthValue;
},276,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _react = require(_dependencyMap[0]);
  var React = _interopNamespace(_react);
  var _createElement = require(_dependencyMap[1]);
  var createElement = _interopDefault(_createElement);
  var _modulesForwardedProps = require(_dependencyMap[2]);
  var forwardedProps = _interopNamespace(_modulesForwardedProps);
  var _modulesPick = require(_dependencyMap[3]);
  var pick = _interopDefault(_modulesPick);
  var _modulesUseElementLayout = require(_dependencyMap[4]);
  var useElementLayout = _interopDefault(_modulesUseElementLayout);
  var _modulesUseLayoutEffect = require(_dependencyMap[5]);
  var useLayoutEffect = _interopDefault(_modulesUseLayoutEffect);
  var _modulesUseMergeRefs = require(_dependencyMap[6]);
  var useMergeRefs = _interopDefault(_modulesUseMergeRefs);
  var _modulesUsePlatformMethods = require(_dependencyMap[7]);
  var usePlatformMethods = _interopDefault(_modulesUsePlatformMethods);
  var _modulesUseResponderEvents = require(_dependencyMap[8]);
  var useResponderEvents = _interopDefault(_modulesUseResponderEvents);
  var _modulesUseLocale = require(_dependencyMap[9]);
  var _StyleSheet = require(_dependencyMap[10]);
  var StyleSheet = _interopDefault(_StyleSheet);
  var _modulesTextInputState = require(_dependencyMap[11]);
  var TextInputState = _interopDefault(_modulesTextInputState);
  //import { warnOnce } from '../../modules/warnOnce';

  /**
   * Determines whether a 'selection' prop differs from a node's existing
   * selection state.
   */
  var isSelectionStale = (node, selection) => {
    var selectionEnd = node.selectionEnd,
      selectionStart = node.selectionStart;
    var start = selection.start,
      end = selection.end;
    return start !== selectionStart || end !== selectionEnd;
  };

  /**
   * Certain input types do no support 'selectSelectionRange' and will throw an
   * error.
   */
  var setSelection = (node, selection) => {
    if (isSelectionStale(node, selection)) {
      var start = selection.start,
        end = selection.end;
      try {
        node.setSelectionRange(start, end || start);
      } catch (e) {}
    }
  };
  var forwardPropsList = Object.assign({}, forwardedProps.defaultProps, forwardedProps.accessibilityProps, forwardedProps.clickProps, forwardedProps.focusProps, forwardedProps.keyboardProps, forwardedProps.mouseProps, forwardedProps.touchProps, forwardedProps.styleProps, {
    autoCapitalize: true,
    autoComplete: true,
    autoCorrect: true,
    autoFocus: true,
    defaultValue: true,
    disabled: true,
    lang: true,
    maxLength: true,
    onChange: true,
    onScroll: true,
    placeholder: true,
    pointerEvents: true,
    readOnly: true,
    rows: true,
    spellCheck: true,
    value: true,
    type: true
  });
  var pickProps = props => (0, pick.default)(props, forwardPropsList);

  // If an Input Method Editor is processing key input, the 'keyCode' is 229.
  // https://www.w3.org/TR/uievents/#determine-keydown-keyup-keyCode
  function isEventComposing(nativeEvent) {
    return nativeEvent.isComposing || nativeEvent.keyCode === 229;
  }
  var focusTimeout = null;
  var TextInput = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
    var _props$autoCapitalize = props.autoCapitalize,
      autoCapitalize = _props$autoCapitalize === undefined ? 'sentences' : _props$autoCapitalize,
      autoComplete = props.autoComplete,
      autoCompleteType = props.autoCompleteType,
      _props$autoCorrect = props.autoCorrect,
      autoCorrect = _props$autoCorrect === undefined ? true : _props$autoCorrect,
      blurOnSubmit = props.blurOnSubmit,
      caretHidden = props.caretHidden,
      clearTextOnFocus = props.clearTextOnFocus,
      dir = props.dir,
      editable = props.editable,
      enterKeyHint = props.enterKeyHint,
      inputMode = props.inputMode,
      keyboardType = props.keyboardType,
      _props$multiline = props.multiline,
      multiline = _props$multiline === undefined ? false : _props$multiline,
      numberOfLines = props.numberOfLines,
      onBlur = props.onBlur,
      onChange = props.onChange,
      onChangeText = props.onChangeText,
      onContentSizeChange = props.onContentSizeChange,
      onFocus = props.onFocus,
      onKeyPress = props.onKeyPress,
      onLayout = props.onLayout,
      onMoveShouldSetResponder = props.onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture = props.onMoveShouldSetResponderCapture,
      onResponderEnd = props.onResponderEnd,
      onResponderGrant = props.onResponderGrant,
      onResponderMove = props.onResponderMove,
      onResponderReject = props.onResponderReject,
      onResponderRelease = props.onResponderRelease,
      onResponderStart = props.onResponderStart,
      onResponderTerminate = props.onResponderTerminate,
      onResponderTerminationRequest = props.onResponderTerminationRequest,
      onScrollShouldSetResponder = props.onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture = props.onScrollShouldSetResponderCapture,
      onSelectionChange = props.onSelectionChange,
      onSelectionChangeShouldSetResponder = props.onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture = props.onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder = props.onStartShouldSetResponder,
      onStartShouldSetResponderCapture = props.onStartShouldSetResponderCapture,
      onSubmitEditing = props.onSubmitEditing,
      placeholderTextColor = props.placeholderTextColor,
      _props$readOnly = props.readOnly,
      readOnly = _props$readOnly === undefined ? false : _props$readOnly,
      returnKeyType = props.returnKeyType,
      rows = props.rows,
      _props$secureTextEntr = props.secureTextEntry,
      secureTextEntry = _props$secureTextEntr === undefined ? false : _props$secureTextEntr,
      selection = props.selection,
      selectTextOnFocus = props.selectTextOnFocus,
      showSoftInputOnFocus = props.showSoftInputOnFocus,
      spellCheck = props.spellCheck;
    var type;
    var _inputMode;
    if (inputMode != null) {
      _inputMode = inputMode;
      if (inputMode === 'email') {
        type = 'email';
      } else if (inputMode === 'tel') {
        type = 'tel';
      } else if (inputMode === 'search') {
        type = 'search';
      } else if (inputMode === 'url') {
        type = 'url';
      } else {
        type = 'text';
      }
    } else if (keyboardType != null) {
      // warnOnce('keyboardType', 'keyboardType is deprecated. Use inputMode.');
      switch (keyboardType) {
        case 'email-address':
          type = 'email';
          break;
        case 'number-pad':
        case 'numeric':
          _inputMode = 'numeric';
          break;
        case 'decimal-pad':
          _inputMode = 'decimal';
          break;
        case 'phone-pad':
          type = 'tel';
          break;
        case 'search':
        case 'web-search':
          type = 'search';
          break;
        case 'url':
          type = 'url';
          break;
        default:
          type = 'text';
      }
    }
    if (secureTextEntry) {
      type = 'password';
    }
    var dimensions = React.useRef({
      height: null,
      width: null
    });
    var hostRef = React.useRef(null);
    var prevSelection = React.useRef(null);
    var prevSecureTextEntry = React.useRef(false);
    React.useEffect(() => {
      if (hostRef.current && prevSelection.current) {
        setSelection(hostRef.current, prevSelection.current);
      }
      prevSecureTextEntry.current = secureTextEntry;
    }, [secureTextEntry]);
    var handleContentSizeChange = React.useCallback(hostNode => {
      if (multiline && onContentSizeChange && hostNode != null) {
        var newHeight = hostNode.scrollHeight;
        var newWidth = hostNode.scrollWidth;
        if (newHeight !== dimensions.current.height || newWidth !== dimensions.current.width) {
          dimensions.current.height = newHeight;
          dimensions.current.width = newWidth;
          onContentSizeChange({
            nativeEvent: {
              contentSize: {
                height: dimensions.current.height,
                width: dimensions.current.width
              }
            }
          });
        }
      }
    }, [multiline, onContentSizeChange]);
    var imperativeRef = React.useMemo(() => hostNode => {
      // TextInput needs to add more methods to the hostNode in addition to those
      // added by `usePlatformMethods`. This is temporarily until an API like
      // `TextInput.clear(hostRef)` is added to React Native.
      if (hostNode != null) {
        hostNode.clear = function () {
          if (hostNode != null) {
            hostNode.value = '';
          }
        };
        hostNode.isFocused = function () {
          return hostNode != null && TextInputState.default.currentlyFocusedField() === hostNode;
        };
        handleContentSizeChange(hostNode);
      }
    }, [handleContentSizeChange]);
    function handleBlur(e) {
      TextInputState.default._currentlyFocusedNode = null;
      if (onBlur) {
        e.nativeEvent.text = e.target.value;
        onBlur(e);
      }
    }
    function handleChange(e) {
      var hostNode = e.target;
      var text = hostNode.value;
      e.nativeEvent.text = text;
      handleContentSizeChange(hostNode);
      if (onChange) {
        onChange(e);
      }
      if (onChangeText) {
        onChangeText(text);
      }
    }
    function handleFocus(e) {
      var hostNode = e.target;
      if (onFocus) {
        e.nativeEvent.text = hostNode.value;
        onFocus(e);
      }
      if (hostNode != null) {
        TextInputState.default._currentlyFocusedNode = hostNode;
        if (clearTextOnFocus) {
          hostNode.value = '';
        }
        if (selectTextOnFocus) {
          // Safari requires selection to occur in a setTimeout
          if (focusTimeout != null) {
            clearTimeout(focusTimeout);
          }
          focusTimeout = setTimeout(() => {
            // Check if the input is still focused after the timeout
            // (see #2704)
            if (hostNode != null && document.activeElement === hostNode) {
              hostNode.select();
            }
          }, 0);
        }
      }
    }
    function handleKeyDown(e) {
      var hostNode = e.target;
      // Prevent key events bubbling (see #612)
      e.stopPropagation();
      var blurOnSubmitDefault = !multiline;
      var shouldBlurOnSubmit = blurOnSubmit == null ? blurOnSubmitDefault : blurOnSubmit;
      var nativeEvent = e.nativeEvent;
      var isComposing = isEventComposing(nativeEvent);
      if (onKeyPress) {
        onKeyPress(e);
      }
      if (e.key === 'Enter' && !e.shiftKey &&
      // Do not call submit if composition is occuring.
      !isComposing && !e.isDefaultPrevented()) {
        if ((blurOnSubmit || !multiline) && onSubmitEditing) {
          // prevent "Enter" from inserting a newline or submitting a form
          e.preventDefault();
          nativeEvent.text = e.target.value;
          onSubmitEditing(e);
        }
        if (shouldBlurOnSubmit && hostNode != null) {
          setTimeout(() => hostNode.blur(), 0);
        }
      }
    }
    function handleSelectionChange(e) {
      try {
        var _e$target = e.target,
          selectionStart = _e$target.selectionStart,
          selectionEnd = _e$target.selectionEnd;
        var _selection = {
          start: selectionStart,
          end: selectionEnd
        };
        if (onSelectionChange) {
          e.nativeEvent.selection = _selection;
          e.nativeEvent.text = e.target.value;
          onSelectionChange(e);
        }
        if (prevSecureTextEntry.current === secureTextEntry) {
          prevSelection.current = _selection;
        }
      } catch (e) {}
    }
    (0, useLayoutEffect.default)(() => {
      var node = hostRef.current;
      if (node != null && selection != null) {
        setSelection(node, selection);
      }
      if (document.activeElement === node) {
        TextInputState.default._currentlyFocusedNode = node;
      }
    }, [hostRef, selection]);
    var component = multiline ? 'textarea' : 'input';
    (0, useElementLayout.default)(hostRef, onLayout);
    (0, useResponderEvents.default)(hostRef, {
      onMoveShouldSetResponder,
      onMoveShouldSetResponderCapture,
      onResponderEnd,
      onResponderGrant,
      onResponderMove,
      onResponderReject,
      onResponderRelease,
      onResponderStart,
      onResponderTerminate,
      onResponderTerminationRequest,
      onScrollShouldSetResponder,
      onScrollShouldSetResponderCapture,
      onSelectionChangeShouldSetResponder,
      onSelectionChangeShouldSetResponderCapture,
      onStartShouldSetResponder,
      onStartShouldSetResponderCapture
    });
    var _useLocaleContext = (0, _modulesUseLocale.useLocaleContext)(),
      contextDirection = _useLocaleContext.direction;
    var supportedProps = pickProps(props);
    supportedProps.autoCapitalize = autoCapitalize;
    supportedProps.autoComplete = autoComplete || autoCompleteType || 'on';
    supportedProps.autoCorrect = autoCorrect ? 'on' : 'off';
    // 'auto' by default allows browsers to infer writing direction
    supportedProps.dir = dir !== undefined ? dir : 'auto';
    /*
    if (returnKeyType != null) {
      warnOnce('returnKeyType', 'returnKeyType is deprecated. Use enterKeyHint.');
    }
    */
    supportedProps.enterKeyHint = enterKeyHint || returnKeyType;
    supportedProps.inputMode = _inputMode;
    supportedProps.onBlur = handleBlur;
    supportedProps.onChange = handleChange;
    supportedProps.onFocus = handleFocus;
    supportedProps.onKeyDown = handleKeyDown;
    supportedProps.onSelect = handleSelectionChange;
    /*
    if (editable != null) {
      warnOnce('editable', 'editable is deprecated. Use readOnly.');
    }
    */
    supportedProps.readOnly = readOnly === true || editable === false;
    /*
    if (numberOfLines != null) {
      warnOnce(
        'numberOfLines',
        'TextInput numberOfLines is deprecated. Use rows.'
      );
    }
    */
    supportedProps.rows = multiline ? rows != null ? rows : numberOfLines : 1;
    supportedProps.spellCheck = spellCheck != null ? spellCheck : autoCorrect;
    supportedProps.style = [{
      '--placeholderTextColor': placeholderTextColor
    }, styles.textinput$raw, styles.placeholder, props.style, caretHidden && styles.caretHidden];
    supportedProps.type = multiline ? undefined : type;
    supportedProps.virtualkeyboardpolicy = showSoftInputOnFocus === false ? 'manual' : 'auto';
    var platformMethodsRef = (0, usePlatformMethods.default)(supportedProps);
    var setRef = (0, useMergeRefs.default)(hostRef, platformMethodsRef, imperativeRef, forwardedRef);
    supportedProps.ref = setRef;
    var langDirection = props.lang != null ? (0, _modulesUseLocale.getLocaleDirection)(props.lang) : null;
    var componentDirection = props.dir || langDirection;
    var writingDirection = componentDirection || contextDirection;
    var element = (0, createElement.default)(component, supportedProps, {
      writingDirection
    });
    return element;
  });
  TextInput.displayName = 'TextInput';
  // $FlowFixMe
  TextInput.State = TextInputState.default;
  var styles = StyleSheet.default.create({
    textinput$raw: {
      MozAppearance: 'textfield',
      WebkitAppearance: 'none',
      backgroundColor: 'transparent',
      border: '0 solid black',
      borderRadius: 0,
      boxSizing: 'border-box',
      font: '14px System',
      margin: 0,
      padding: 0,
      resize: 'none'
    },
    placeholder: {
      placeholderTextColor: 'var(--placeholderTextColor)'
    },
    caretHidden: {
      caretColor: 'transparent'
    }
  });
  var _default = TextInput;
},277,[35,116,139,140,141,142,143,145,147,122,43,164]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use strict';

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _babelRuntimeHelpersObjectSpread = require(_dependencyMap[1]);
  var _objectSpread = _interopDefault(_babelRuntimeHelpersObjectSpread);
  var _modulesAccessibilityUtil = require(_dependencyMap[2]);
  var AccessibilityUtil = _interopDefault(_modulesAccessibilityUtil);
  var _BoundingDimensions = require(_dependencyMap[3]);
  var BoundingDimensions = _interopDefault(_BoundingDimensions);
  var _reactNativeNormalizeColors = require(_dependencyMap[4]);
  var normalizeColor = _interopDefault(_reactNativeNormalizeColors);
  var _Position = require(_dependencyMap[5]);
  var Position = _interopDefault(_Position);
  var _react = require(_dependencyMap[6]);
  var React = _interopDefault(_react);
  var _UIManager = require(_dependencyMap[7]);
  var UIManager = _interopDefault(_UIManager);
  var _View = require(_dependencyMap[8]);
  var View = _interopDefault(_View);
  var _modulesWarnOnce = require(_dependencyMap[9]);
  var extractSingleTouch = nativeEvent => {
    var touches = nativeEvent.touches;
    var changedTouches = nativeEvent.changedTouches;
    var hasTouches = touches && touches.length > 0;
    var hasChangedTouches = changedTouches && changedTouches.length > 0;
    return !hasTouches && hasChangedTouches ? changedTouches[0] : hasTouches ? touches[0] : nativeEvent;
  };

  /**
   * `Touchable`: Taps done right.
   *
   * You hook your `ResponderEventPlugin` events into `Touchable`. `Touchable`
   * will measure time/geometry and tells you when to give feedback to the user.
   *
   * ====================== Touchable Tutorial ===============================
   * The `Touchable` mixin helps you handle the "press" interaction. It analyzes
   * the geometry of elements, and observes when another responder (scroll view
   * etc) has stolen the touch lock. It notifies your component when it should
   * give feedback to the user. (bouncing/highlighting/unhighlighting).
   *
   * - When a touch was activated (typically you highlight)
   * - When a touch was deactivated (typically you unhighlight)
   * - When a touch was "pressed" - a touch ended while still within the geometry
   *   of the element, and no other element (like scroller) has "stolen" touch
   *   lock ("responder") (Typically you bounce the element).
   *
   * A good tap interaction isn't as simple as you might think. There should be a
   * slight delay before showing a highlight when starting a touch. If a
   * subsequent touch move exceeds the boundary of the element, it should
   * unhighlight, but if that same touch is brought back within the boundary, it
   * should rehighlight again. A touch can move in and out of that boundary
   * several times, each time toggling highlighting, but a "press" is only
   * triggered if that touch ends while within the element's boundary and no
   * scroller (or anything else) has stolen the lock on touches.
   *
   * To create a new type of component that handles interaction using the
   * `Touchable` mixin, do the following:
   *
   * - Initialize the `Touchable` state.
   *
   *   getInitialState: function() {
   *     return merge(this.touchableGetInitialState(), yourComponentState);
   *   }
   *
   * - Add a method to get your touchable component's node.
   *   getTouchableNode: function() {
   *     return this.touchableRef.current
   *   }
   *
   * - Choose the rendered component who's touches should start the interactive
   *   sequence. On that rendered node, forward all `Touchable` responder
   *   handlers. You can choose any rendered node you like. Choose a node whose
   *   hit target you'd like to instigate the interaction sequence:
   *
   *   // In render function:
   *   return (
   *     <View
   *       ref={this.touchableRef}
   *       onStartShouldSetResponder={this.touchableHandleStartShouldSetResponder}
   *       onResponderTerminationRequest={this.touchableHandleResponderTerminationRequest}
   *       onResponderGrant={this.touchableHandleResponderGrant}
   *       onResponderMove={this.touchableHandleResponderMove}
   *       onResponderRelease={this.touchableHandleResponderRelease}
   *       onResponderTerminate={this.touchableHandleResponderTerminate}>
   *       <View>
   *         Even though the hit detection/interactions are triggered by the
   *         wrapping (typically larger) node, we usually end up implementing
   *         custom logic that highlights this inner one.
   *       </View>
   *     </View>
   *   );
   *
   * - You may set up your own handlers for each of these events, so long as you
   *   also invoke the `touchable*` handlers inside of your custom handler.
   *
   * - Implement the handlers on your component class in order to provide
   *   feedback to the user. See documentation for each of these class methods
   *   that you should implement.
   *
   *   touchableHandlePress: function() {
   *      this.performBounceAnimation();  // or whatever you want to do.
   *   },
   *   touchableHandleActivePressIn: function() {
   *     this.beginHighlighting(...);  // Whatever you like to convey activation
   *   },
   *   touchableHandleActivePressOut: function() {
   *     this.endHighlighting(...);  // Whatever you like to convey deactivation
   *   },
   *
   * - There are more advanced methods you can implement (see documentation below):
   *   touchableGetHighlightDelayMS: function() {
   *     return 20;
   *   }
   *   // In practice, *always* use a predeclared constant (conserve memory).
   *   touchableGetPressRectOffset: function() {
   *     return {top: 20, left: 20, right: 20, bottom: 100};
   *   }
   */

  /**
   * Touchable states.
   */

  var States = {
    NOT_RESPONDER: 'NOT_RESPONDER',
    // Not the responder
    RESPONDER_INACTIVE_PRESS_IN: 'RESPONDER_INACTIVE_PRESS_IN',
    // Responder, inactive, in the `PressRect`
    RESPONDER_INACTIVE_PRESS_OUT: 'RESPONDER_INACTIVE_PRESS_OUT',
    // Responder, inactive, out of `PressRect`
    RESPONDER_ACTIVE_PRESS_IN: 'RESPONDER_ACTIVE_PRESS_IN',
    // Responder, active, in the `PressRect`
    RESPONDER_ACTIVE_PRESS_OUT: 'RESPONDER_ACTIVE_PRESS_OUT',
    // Responder, active, out of `PressRect`
    RESPONDER_ACTIVE_LONG_PRESS_IN: 'RESPONDER_ACTIVE_LONG_PRESS_IN',
    // Responder, active, in the `PressRect`, after long press threshold
    RESPONDER_ACTIVE_LONG_PRESS_OUT: 'RESPONDER_ACTIVE_LONG_PRESS_OUT',
    // Responder, active, out of `PressRect`, after long press threshold
    ERROR: 'ERROR'
  };
  /*
   * Quick lookup map for states that are considered to be "active"
   */

  var baseStatesConditions = {
    NOT_RESPONDER: false,
    RESPONDER_INACTIVE_PRESS_IN: false,
    RESPONDER_INACTIVE_PRESS_OUT: false,
    RESPONDER_ACTIVE_PRESS_IN: false,
    RESPONDER_ACTIVE_PRESS_OUT: false,
    RESPONDER_ACTIVE_LONG_PRESS_IN: false,
    RESPONDER_ACTIVE_LONG_PRESS_OUT: false,
    ERROR: false
  };
  var IsActive = (0, _objectSpread.default)((0, _objectSpread.default)({}, baseStatesConditions), {}, {
    RESPONDER_ACTIVE_PRESS_OUT: true,
    RESPONDER_ACTIVE_PRESS_IN: true
  });

  /**
   * Quick lookup for states that are considered to be "pressing" and are
   * therefore eligible to result in a "selection" if the press stops.
   */
  var IsPressingIn = (0, _objectSpread.default)((0, _objectSpread.default)({}, baseStatesConditions), {}, {
    RESPONDER_INACTIVE_PRESS_IN: true,
    RESPONDER_ACTIVE_PRESS_IN: true,
    RESPONDER_ACTIVE_LONG_PRESS_IN: true
  });
  var IsLongPressingIn = (0, _objectSpread.default)((0, _objectSpread.default)({}, baseStatesConditions), {}, {
    RESPONDER_ACTIVE_LONG_PRESS_IN: true
  });

  /**
   * Inputs to the state machine.
   */
  var Signals = {
    DELAY: 'DELAY',
    RESPONDER_GRANT: 'RESPONDER_GRANT',
    RESPONDER_RELEASE: 'RESPONDER_RELEASE',
    RESPONDER_TERMINATED: 'RESPONDER_TERMINATED',
    ENTER_PRESS_RECT: 'ENTER_PRESS_RECT',
    LEAVE_PRESS_RECT: 'LEAVE_PRESS_RECT',
    LONG_PRESS_DETECTED: 'LONG_PRESS_DETECTED'
  };
  /**
   * Mapping from States x Signals => States
   */
  var Transitions = {
    NOT_RESPONDER: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,
      RESPONDER_RELEASE: States.ERROR,
      RESPONDER_TERMINATED: States.ERROR,
      ENTER_PRESS_RECT: States.ERROR,
      LEAVE_PRESS_RECT: States.ERROR,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_INACTIVE_PRESS_IN: {
      DELAY: States.RESPONDER_ACTIVE_PRESS_IN,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_INACTIVE_PRESS_OUT: {
      DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_ACTIVE_PRESS_IN: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN
    },
    RESPONDER_ACTIVE_PRESS_OUT: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    RESPONDER_ACTIVE_LONG_PRESS_IN: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,
      LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN
    },
    RESPONDER_ACTIVE_LONG_PRESS_OUT: {
      DELAY: States.ERROR,
      RESPONDER_GRANT: States.ERROR,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,
      LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,
      LONG_PRESS_DETECTED: States.ERROR
    },
    error: {
      DELAY: States.NOT_RESPONDER,
      RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,
      RESPONDER_RELEASE: States.NOT_RESPONDER,
      RESPONDER_TERMINATED: States.NOT_RESPONDER,
      ENTER_PRESS_RECT: States.NOT_RESPONDER,
      LEAVE_PRESS_RECT: States.NOT_RESPONDER,
      LONG_PRESS_DETECTED: States.NOT_RESPONDER
    }
  };

  // ==== Typical Constants for integrating into UI components ====
  // var HIT_EXPAND_PX = 20;
  // var HIT_VERT_OFFSET_PX = 10;
  var HIGHLIGHT_DELAY_MS = 130;
  var PRESS_EXPAND_PX = 20;
  var LONG_PRESS_THRESHOLD = 500;
  var LONG_PRESS_DELAY_MS = 370;
  var LONG_PRESS_ALLOWED_MOVEMENT = 10;

  // Default amount "active" region protrudes beyond box

  /**
   * By convention, methods prefixed with underscores are meant to be @private,
   * and not @protected. Mixers shouldn't access them - not even to provide them
   * as callback handlers.
   *
   *
   * ========== Geometry =========
   * `Touchable` only assumes that there exists a `HitRect` node. The `PressRect`
   * is an abstract box that is extended beyond the `HitRect`.
   *
   *  +--------------------------+
   *  |                          | - "Start" events in `HitRect` cause `HitRect`
   *  |  +--------------------+  |   to become the responder.
   *  |  |  +--------------+  |  | - `HitRect` is typically expanded around
   *  |  |  |              |  |  |   the `VisualRect`, but shifted downward.
   *  |  |  |  VisualRect  |  |  | - After pressing down, after some delay,
   *  |  |  |              |  |  |   and before letting up, the Visual React
   *  |  |  +--------------+  |  |   will become "active". This makes it eligible
   *  |  |     HitRect        |  |   for being highlighted (so long as the
   *  |  +--------------------+  |   press remains in the `PressRect`).
   *  |        PressRect     o   |
   *  +----------------------|---+
   *           Out Region    |
   *                         +-----+ This gap between the `HitRect` and
   *                                 `PressRect` allows a touch to move far away
   *                                 from the original hit rect, and remain
   *                                 highlighted, and eligible for a "Press".
   *                                 Customize this via
   *                                 `touchableGetPressRectOffset()`.
   *
   *
   *
   * ======= State Machine =======
   *
   * +-------------+ <---+ RESPONDER_RELEASE
   * |NOT_RESPONDER|
   * +-------------+ <---+ RESPONDER_TERMINATED
   *     +
   *     | RESPONDER_GRANT (HitRect)
   *     v
   * +---------------------------+  DELAY   +-------------------------+  T + DELAY     +------------------------------+
   * |RESPONDER_INACTIVE_PRESS_IN|+-------->|RESPONDER_ACTIVE_PRESS_IN| +------------> |RESPONDER_ACTIVE_LONG_PRESS_IN|
   * +---------------------------+          +-------------------------+                +------------------------------+
   *     +            ^                         +           ^                                 +           ^
   *     |LEAVE_      |ENTER_                   |LEAVE_     |ENTER_                           |LEAVE_     |ENTER_
   *     |PRESS_RECT  |PRESS_RECT               |PRESS_RECT |PRESS_RECT                       |PRESS_RECT |PRESS_RECT
   *     |            |                         |           |                                 |           |
   *     v            +                         v           +                                 v           +
   * +----------------------------+  DELAY  +--------------------------+               +-------------------------------+
   * |RESPONDER_INACTIVE_PRESS_OUT|+------->|RESPONDER_ACTIVE_PRESS_OUT|               |RESPONDER_ACTIVE_LONG_PRESS_OUT|
   * +----------------------------+         +--------------------------+               +-------------------------------+
   *
   * T + DELAY => LONG_PRESS_DELAY_MS + DELAY
   *
   * Not drawn are the side effects of each transition. The most important side
   * effect is the `touchableHandlePress` abstract method invocation that occurs
   * when a responder is released while in either of the "Press" states.
   *
   * The other important side effects are the highlight abstract method
   * invocations (internal callbacks) to be implemented by the mixer.
   *
   *
   * @lends Touchable.prototype
   */
  var TouchableMixin = {
    // HACK (part 1): basic support for touchable interactions using a keyboard
    componentDidMount: function componentDidMount() {
      (0, _modulesWarnOnce.warnOnce)('TouchableMixin', 'TouchableMixin is deprecated. Please use Pressable.');
      var touchableNode = this.getTouchableNode && this.getTouchableNode();
      if (touchableNode && touchableNode.addEventListener) {
        this._touchableBlurListener = e => {
          if (this._isTouchableKeyboardActive) {
            if (this.state.touchable.touchState && this.state.touchable.touchState !== States.NOT_RESPONDER) {
              this.touchableHandleResponderTerminate({
                nativeEvent: e
              });
            }
            this._isTouchableKeyboardActive = false;
          }
        };
        touchableNode.addEventListener('blur', this._touchableBlurListener);
      }
    },
    /**
     * Clear all timeouts on unmount
     */
    componentWillUnmount: function componentWillUnmount() {
      var touchableNode = this.getTouchableNode && this.getTouchableNode();
      if (touchableNode && touchableNode.addEventListener) {
        touchableNode.removeEventListener('blur', this._touchableBlurListener);
      }
      this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);
      this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);
      this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);
      // Clear DOM nodes
      this.pressInLocation = null;
      this.state.touchable.responderID = null;
    },
    /**
     * It's prefer that mixins determine state in this way, having the class
     * explicitly mix the state in the one and only `getInitialState` method.
     *
     * @return {object} State object to be placed inside of
     * `this.state.touchable`.
     */
    touchableGetInitialState: function touchableGetInitialState() {
      return {
        touchable: {
          touchState: undefined,
          responderID: null
        }
      };
    },
    // ==== Hooks to Gesture Responder system ====
    /**
     * Must return true if embedded in a native platform scroll view.
     */
    touchableHandleResponderTerminationRequest: function touchableHandleResponderTerminationRequest() {
      return !this.props.rejectResponderTermination;
    },
    /**
     * Must return true to start the process of `Touchable`.
     */
    touchableHandleStartShouldSetResponder: function touchableHandleStartShouldSetResponder() {
      return !this.props.disabled;
    },
    /**
     * Return true to cancel press on long press.
     */
    touchableLongPressCancelsPress: function touchableLongPressCancelsPress() {
      return true;
    },
    /**
     * Place as callback for a DOM element's `onResponderGrant` event.
     * @param {SyntheticEvent} e Synthetic event from event system.
     *
     */
    touchableHandleResponderGrant: function touchableHandleResponderGrant(e) {
      var dispatchID = e.currentTarget;
      // Since e is used in a callback invoked on another event loop
      // (as in setTimeout etc), we need to call e.persist() on the
      // event to make sure it doesn't get reused in the event object pool.
      e.persist();
      this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);
      this.pressOutDelayTimeout = null;
      this.state.touchable.touchState = States.NOT_RESPONDER;
      this.state.touchable.responderID = dispatchID;
      this._receiveSignal(Signals.RESPONDER_GRANT, e);
      var delayMS = this.touchableGetHighlightDelayMS !== undefined ? Math.max(this.touchableGetHighlightDelayMS(), 0) : HIGHLIGHT_DELAY_MS;
      delayMS = isNaN(delayMS) ? HIGHLIGHT_DELAY_MS : delayMS;
      if (delayMS !== 0) {
        this.touchableDelayTimeout = setTimeout(this._handleDelay.bind(this, e), delayMS);
      } else {
        this._handleDelay(e);
      }
      var longDelayMS = this.touchableGetLongPressDelayMS !== undefined ? Math.max(this.touchableGetLongPressDelayMS(), 10) : LONG_PRESS_DELAY_MS;
      longDelayMS = isNaN(longDelayMS) ? LONG_PRESS_DELAY_MS : longDelayMS;
      this.longPressDelayTimeout = setTimeout(this._handleLongDelay.bind(this, e), longDelayMS + delayMS);
    },
    /**
     * Place as callback for a DOM element's `onResponderRelease` event.
     */
    touchableHandleResponderRelease: function touchableHandleResponderRelease(e) {
      this.pressInLocation = null;
      this._receiveSignal(Signals.RESPONDER_RELEASE, e);
    },
    /**
     * Place as callback for a DOM element's `onResponderTerminate` event.
     */
    touchableHandleResponderTerminate: function touchableHandleResponderTerminate(e) {
      this.pressInLocation = null;
      this._receiveSignal(Signals.RESPONDER_TERMINATED, e);
    },
    /**
     * Place as callback for a DOM element's `onResponderMove` event.
     */
    touchableHandleResponderMove: function touchableHandleResponderMove(e) {
      // Measurement may not have returned yet.
      if (!this.state.touchable.positionOnActivate) {
        return;
      }
      var positionOnActivate = this.state.touchable.positionOnActivate;
      var dimensionsOnActivate = this.state.touchable.dimensionsOnActivate;
      var pressRectOffset = this.touchableGetPressRectOffset ? this.touchableGetPressRectOffset() : {
        left: PRESS_EXPAND_PX,
        right: PRESS_EXPAND_PX,
        top: PRESS_EXPAND_PX,
        bottom: PRESS_EXPAND_PX
      };
      var pressExpandLeft = pressRectOffset.left;
      var pressExpandTop = pressRectOffset.top;
      var pressExpandRight = pressRectOffset.right;
      var pressExpandBottom = pressRectOffset.bottom;
      var hitSlop = this.touchableGetHitSlop ? this.touchableGetHitSlop() : null;
      if (hitSlop) {
        pressExpandLeft += hitSlop.left || 0;
        pressExpandTop += hitSlop.top || 0;
        pressExpandRight += hitSlop.right || 0;
        pressExpandBottom += hitSlop.bottom || 0;
      }
      var touch = extractSingleTouch(e.nativeEvent);
      var pageX = touch && touch.pageX;
      var pageY = touch && touch.pageY;
      if (this.pressInLocation) {
        var movedDistance = this._getDistanceBetweenPoints(pageX, pageY, this.pressInLocation.pageX, this.pressInLocation.pageY);
        if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {
          this._cancelLongPressDelayTimeout();
        }
      }
      var isTouchWithinActive = pageX > positionOnActivate.left - pressExpandLeft && pageY > positionOnActivate.top - pressExpandTop && pageX < positionOnActivate.left + dimensionsOnActivate.width + pressExpandRight && pageY < positionOnActivate.top + dimensionsOnActivate.height + pressExpandBottom;
      if (isTouchWithinActive) {
        var prevState = this.state.touchable.touchState;
        this._receiveSignal(Signals.ENTER_PRESS_RECT, e);
        var curState = this.state.touchable.touchState;
        if (curState === States.RESPONDER_INACTIVE_PRESS_IN && prevState !== States.RESPONDER_INACTIVE_PRESS_IN) {
          // fix for t7967420
          this._cancelLongPressDelayTimeout();
        }
      } else {
        this._cancelLongPressDelayTimeout();
        this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);
      }
    },
    /**
     * Invoked when the item receives focus. Mixers might override this to
     * visually distinguish the `VisualRect` so that the user knows that it
     * currently has the focus. Most platforms only support a single element being
     * focused at a time, in which case there may have been a previously focused
     * element that was blurred just prior to this. This can be overridden when
     * using `Touchable.Mixin.withoutDefaultFocusAndBlur`.
     */
    touchableHandleFocus: function touchableHandleFocus(e) {
      this.props.onFocus && this.props.onFocus(e);
    },
    /**
     * Invoked when the item loses focus. Mixers might override this to
     * visually distinguish the `VisualRect` so that the user knows that it
     * no longer has focus. Most platforms only support a single element being
     * focused at a time, in which case the focus may have moved to another.
     * This can be overridden when using
     * `Touchable.Mixin.withoutDefaultFocusAndBlur`.
     */
    touchableHandleBlur: function touchableHandleBlur(e) {
      this.props.onBlur && this.props.onBlur(e);
    },
    // ==== Abstract Application Callbacks ====

    /**
     * Invoked when the item should be highlighted. Mixers should implement this
     * to visually distinguish the `VisualRect` so that the user knows that
     * releasing a touch will result in a "selection" (analog to click).
     *
     * @abstract
     * touchableHandleActivePressIn: function,
     */

    /**
     * Invoked when the item is "active" (in that it is still eligible to become
     * a "select") but the touch has left the `PressRect`. Usually the mixer will
     * want to unhighlight the `VisualRect`. If the user (while pressing) moves
     * back into the `PressRect` `touchableHandleActivePressIn` will be invoked
     * again and the mixer should probably highlight the `VisualRect` again. This
     * event will not fire on an `touchEnd/mouseUp` event, only move events while
     * the user is depressing the mouse/touch.
     *
     * @abstract
     * touchableHandleActivePressOut: function
     */

    /**
     * Invoked when the item is "selected" - meaning the interaction ended by
     * letting up while the item was either in the state
     * `RESPONDER_ACTIVE_PRESS_IN` or `RESPONDER_INACTIVE_PRESS_IN`.
     *
     * @abstract
     * touchableHandlePress: function
     */

    /**
     * Invoked when the item is long pressed - meaning the interaction ended by
     * letting up while the item was in `RESPONDER_ACTIVE_LONG_PRESS_IN`. If
     * `touchableHandleLongPress` is *not* provided, `touchableHandlePress` will
     * be called as it normally is. If `touchableHandleLongPress` is provided, by
     * default any `touchableHandlePress` callback will not be invoked. To
     * override this default behavior, override `touchableLongPressCancelsPress`
     * to return false. As a result, `touchableHandlePress` will be called when
     * lifting up, even if `touchableHandleLongPress` has also been called.
     *
     * @abstract
     * touchableHandleLongPress: function
     */

    /**
     * Returns the number of millis to wait before triggering a highlight.
     *
     * @abstract
     * touchableGetHighlightDelayMS: function
     */

    /**
     * Returns the amount to extend the `HitRect` into the `PressRect`. Positive
     * numbers mean the size expands outwards.
     *
     * @abstract
     * touchableGetPressRectOffset: function
     */

    // ==== Internal Logic ====

    /**
     * Measures the `HitRect` node on activation. The Bounding rectangle is with
     * respect to viewport - not page, so adding the `pageXOffset/pageYOffset`
     * should result in points that are in the same coordinate system as an
     * event's `globalX/globalY` data values.
     *
     * - Consider caching this for the lifetime of the component, or possibly
     *   being able to share this cache between any `ScrollMap` view.
     *
     * @sideeffects
     * @private
     */
    _remeasureMetricsOnActivation: function _remeasureMetricsOnActivation() {
      var tag = this.state.touchable.responderID;
      if (tag == null) {
        return;
      }
      UIManager.default.measure(tag, this._handleQueryLayout);
    },
    _handleQueryLayout: function _handleQueryLayout(l, t, w, h, globalX, globalY) {
      //don't do anything UIManager failed to measure node
      if (!l && !t && !w && !h && !globalX && !globalY) {
        return;
      }
      this.state.touchable.positionOnActivate && Position.default.release(this.state.touchable.positionOnActivate);
      this.state.touchable.dimensionsOnActivate &&
      // $FlowFixMe
      BoundingDimensions.default.release(this.state.touchable.dimensionsOnActivate);
      this.state.touchable.positionOnActivate = Position.default.getPooled(globalX, globalY);
      // $FlowFixMe
      this.state.touchable.dimensionsOnActivate = BoundingDimensions.default.getPooled(w, h);
    },
    _handleDelay: function _handleDelay(e) {
      this.touchableDelayTimeout = null;
      this._receiveSignal(Signals.DELAY, e);
    },
    _handleLongDelay: function _handleLongDelay(e) {
      this.longPressDelayTimeout = null;
      var curState = this.state.touchable.touchState;
      if (curState !== States.RESPONDER_ACTIVE_PRESS_IN && curState !== States.RESPONDER_ACTIVE_LONG_PRESS_IN) {
        console.error('Attempted to transition from state `' + curState + '` to `' + States.RESPONDER_ACTIVE_LONG_PRESS_IN + '`, which is not supported. This is ' + 'most likely due to `Touchable.longPressDelayTimeout` not being cancelled.');
      } else {
        this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);
      }
    },
    /**
     * Receives a state machine signal, performs side effects of the transition
     * and stores the new state. Validates the transition as well.
     *
     * @param {Signals} signal State machine signal.
     * @throws Error if invalid state transition or unrecognized signal.
     * @sideeffects
     */
    _receiveSignal: function _receiveSignal(signal, e) {
      var responderID = this.state.touchable.responderID;
      var curState = this.state.touchable.touchState;
      var nextState = Transitions[curState] && Transitions[curState][signal];
      if (!responderID && signal === Signals.RESPONDER_RELEASE) {
        return;
      }
      if (!nextState) {
        throw new Error('Unrecognized signal `' + signal + '` or state `' + curState + '` for Touchable responder `' + responderID + '`');
      }
      if (nextState === States.ERROR) {
        throw new Error('Touchable cannot transition from `' + curState + '` to `' + signal + '` for responder `' + responderID + '`');
      }
      if (curState !== nextState) {
        this._performSideEffectsForTransition(curState, nextState, signal, e);
        this.state.touchable.touchState = nextState;
      }
    },
    _cancelLongPressDelayTimeout: function _cancelLongPressDelayTimeout() {
      this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);
      this.longPressDelayTimeout = null;
    },
    _isHighlight: function _isHighlight(state) {
      return state === States.RESPONDER_ACTIVE_PRESS_IN || state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;
    },
    _savePressInLocation: function _savePressInLocation(e) {
      var touch = extractSingleTouch(e.nativeEvent);
      var pageX = touch && touch.pageX;
      var pageY = touch && touch.pageY;
      var locationX = touch && touch.locationX;
      var locationY = touch && touch.locationY;
      this.pressInLocation = {
        pageX,
        pageY,
        locationX,
        locationY
      };
    },
    _getDistanceBetweenPoints: function _getDistanceBetweenPoints(aX, aY, bX, bY) {
      var deltaX = aX - bX;
      var deltaY = aY - bY;
      return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    },
    /**
     * Will perform a transition between touchable states, and identify any
     * highlighting or unhighlighting that must be performed for this particular
     * transition.
     *
     * @param {States} curState Current Touchable state.
     * @param {States} nextState Next Touchable state.
     * @param {Signal} signal Signal that triggered the transition.
     * @param {Event} e Native event.
     * @sideeffects
     */
    _performSideEffectsForTransition: function _performSideEffectsForTransition(curState, nextState, signal, e) {
      var curIsHighlight = this._isHighlight(curState);
      var newIsHighlight = this._isHighlight(nextState);
      var isFinalSignal = signal === Signals.RESPONDER_TERMINATED || signal === Signals.RESPONDER_RELEASE;
      if (isFinalSignal) {
        this._cancelLongPressDelayTimeout();
      }
      var isInitialTransition = curState === States.NOT_RESPONDER && nextState === States.RESPONDER_INACTIVE_PRESS_IN;
      var isActiveTransition = !IsActive[curState] && IsActive[nextState];
      if (isInitialTransition || isActiveTransition) {
        this._remeasureMetricsOnActivation();
      }
      if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {
        this.touchableHandleLongPress && this.touchableHandleLongPress(e);
      }
      if (newIsHighlight && !curIsHighlight) {
        this._startHighlight(e);
      } else if (!newIsHighlight && curIsHighlight) {
        this._endHighlight(e);
      }
      if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {
        var hasLongPressHandler = !!this.props.onLongPress;
        var pressIsLongButStillCallOnPress = IsLongPressingIn[curState] && (
        // We *are* long pressing.. // But either has no long handler
        !hasLongPressHandler || !this.touchableLongPressCancelsPress()); // or we're told to ignore it.

        var shouldInvokePress = !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;
        if (shouldInvokePress && this.touchableHandlePress) {
          if (!newIsHighlight && !curIsHighlight) {
            // we never highlighted because of delay, but we should highlight now
            this._startHighlight(e);
            this._endHighlight(e);
          }
          this.touchableHandlePress(e);
        }
      }
      this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);
      this.touchableDelayTimeout = null;
    },
    _playTouchSound: function _playTouchSound() {
      UIManager.default.playTouchSound();
    },
    _startHighlight: function _startHighlight(e) {
      this._savePressInLocation(e);
      this.touchableHandleActivePressIn && this.touchableHandleActivePressIn(e);
    },
    _endHighlight: function _endHighlight(e) {
      if (this.touchableHandleActivePressOut) {
        if (this.touchableGetPressOutDelayMS && this.touchableGetPressOutDelayMS()) {
          this.pressOutDelayTimeout = setTimeout(() => {
            this.touchableHandleActivePressOut(e);
          }, this.touchableGetPressOutDelayMS());
        } else {
          this.touchableHandleActivePressOut(e);
        }
      }
    },
    // HACK (part 2): basic support for touchable interactions using a keyboard (including
    // delays and longPress)
    touchableHandleKeyEvent: function touchableHandleKeyEvent(e) {
      var type = e.type,
        key = e.key;
      if (key === 'Enter' || key === ' ') {
        if (type === 'keydown') {
          if (!this._isTouchableKeyboardActive) {
            if (!this.state.touchable.touchState || this.state.touchable.touchState === States.NOT_RESPONDER) {
              this.touchableHandleResponderGrant(e);
              this._isTouchableKeyboardActive = true;
            }
          }
        } else if (type === 'keyup') {
          if (this._isTouchableKeyboardActive) {
            if (this.state.touchable.touchState && this.state.touchable.touchState !== States.NOT_RESPONDER) {
              this.touchableHandleResponderRelease(e);
              this._isTouchableKeyboardActive = false;
            }
          }
        }
        e.stopPropagation();
        // prevent the default behaviour unless the Touchable functions as a link
        // and Enter is pressed
        if (!(key === 'Enter' && AccessibilityUtil.default.propsToAriaRole(this.props) === 'link')) {
          e.preventDefault();
        }
      }
    },
    withoutDefaultFocusAndBlur: {}
  };

  /**
   * Provide an optional version of the mixin where `touchableHandleFocus` and
   * `touchableHandleBlur` can be overridden. This allows appropriate defaults to
   * be set on TV platforms, without breaking existing implementations of
   * `Touchable`.
   */
  var touchableHandleFocus = TouchableMixin.touchableHandleFocus,
    touchableHandleBlur = TouchableMixin.touchableHandleBlur,
    TouchableMixinWithoutDefaultFocusAndBlur = (0, _objectWithoutPropertiesLoose.default)(TouchableMixin, ["touchableHandleFocus", "touchableHandleBlur"]);
  TouchableMixin.withoutDefaultFocusAndBlur = TouchableMixinWithoutDefaultFocusAndBlur;
  var Touchable = {
    Mixin: TouchableMixin,
    TOUCH_TARGET_DEBUG: false,
    // Highlights all touchable targets. Toggle with Inspector.
    /**
     * Renders a debugging overlay to visualize touch target with hitSlop (might not work on Android).
     */
    renderDebugView: _ref => {
      var color = _ref.color,
        hitSlop = _ref.hitSlop;
      if (!Touchable.TOUCH_TARGET_DEBUG) {
        return null;
      }
      var debugHitSlopStyle = {};
      hitSlop = hitSlop || {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      for (var key in hitSlop) {
        debugHitSlopStyle[key] = -hitSlop[key];
      }
      var normalizedColor = (0, normalizeColor.default)(color);
      if (typeof normalizedColor !== 'number') {
        return null;
      }
      var hexColor = '#' + ('00000000' + normalizedColor.toString(16)).substr(-8);
      return /*#__PURE__*/React.default.createElement(View.default, {
        pointerEvents: "none",
        style: (0, _objectSpread.default)({
          position: 'absolute',
          borderColor: hexColor.slice(0, -2) + '55',
          // More opaque
          borderWidth: 1,
          borderStyle: 'dashed',
          backgroundColor: hexColor.slice(0, -2) + '0F'
        }, debugHitSlopStyle)
      });
    }
  };
  var _default = Touchable;
},278,[44,20,117,279,52,281,35,126,138,88]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativePooledClass = require(_dependencyMap[0]);
  var PooledClass = _interopDefault(_vendorReactNativePooledClass);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var twoArgumentPooler = PooledClass.default.twoArgumentPooler;

  /**
   * PooledClass representing the bounding rectangle of a region.
   */
  function BoundingDimensions(width, height) {
    this.width = width;
    this.height = height;
  }
  BoundingDimensions.prototype.destructor = function () {
    this.width = null;
    this.height = null;
  };
  BoundingDimensions.getPooledFromElement = function (element) {
    return BoundingDimensions.getPooled(element.offsetWidth, element.offsetHeight);
  };
  PooledClass.default.addPoolingTo(BoundingDimensions, twoArgumentPooler);
  var _default = BoundingDimensions;
},279,[280]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  require(_dependencyMap[0]);
  /* eslint-disable */

  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * From React 16.0.0
   */

  var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
    var Klass = this;
    if (Klass.instancePool.length) {
      var instance = Klass.instancePool.pop();
      Klass.call(instance, a1, a2);
      return instance;
    } else {
      return new Klass(a1, a2);
    }
  };
  var standardReleaser = function standardReleaser(instance) {
    var Klass = this;
    instance.destructor();
    if (Klass.instancePool.length < Klass.poolSize) {
      Klass.instancePool.push(instance);
    }
  };
  var DEFAULT_POOL_SIZE = 10;
  var DEFAULT_POOLER = twoArgumentPooler;

  /**
   * Augments `CopyConstructor` to be a poolable class, augmenting only the class
   * itself (statically) not adding any prototypical fields. Any CopyConstructor
   * you give this may have a `poolSize` property, and will look for a
   * prototypical `destructor` on instances.
   *
   * @param {Function} CopyConstructor Constructor that can be used to reset.
   * @param {Function} pooler Customizable pooler.
   */
  var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
    // Casting as any so that flow ignores the actual implementation and trusts
    // it to match the type we declared
    var NewKlass = CopyConstructor;
    NewKlass.instancePool = [];
    NewKlass.getPooled = pooler || DEFAULT_POOLER;
    if (!NewKlass.poolSize) {
      NewKlass.poolSize = DEFAULT_POOL_SIZE;
    }
    NewKlass.release = standardReleaser;
    return NewKlass;
  };
  var PooledClass = {
    addPoolingTo: addPoolingTo,
    twoArgumentPooler: twoArgumentPooler
  };
  var _default = PooledClass;
},280,[25]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativePooledClass = require(_dependencyMap[0]);
  var PooledClass = _interopDefault(_vendorReactNativePooledClass);
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var twoArgumentPooler = PooledClass.default.twoArgumentPooler;
  function Position(left, top) {
    this.left = left;
    this.top = top;
  }
  Position.prototype.destructor = function () {
    this.left = null;
    this.top = null;
  };
  PooledClass.default.addPoolingTo(Position, twoArgumentPooler);
  var _default = Position;
},281,[280]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[2]);
  var React = _interopNamespace(_react);
  var _modulesUseMergeRefs = require(_dependencyMap[3]);
  var useMergeRefs = _interopDefault(_modulesUseMergeRefs);
  var _modulesUsePressEvents = require(_dependencyMap[4]);
  var usePressEvents = _interopDefault(_modulesUsePressEvents);
  var _StyleSheet = require(_dependencyMap[5]);
  var StyleSheet = _interopDefault(_StyleSheet);
  var _View = require(_dependencyMap[6]);
  var View = _interopDefault(_View);
  var _excluded = ["activeOpacity", "children", "delayPressIn", "delayPressOut", "delayLongPress", "disabled", "focusable", "onHideUnderlay", "onLongPress", "onPress", "onPressIn", "onPressOut", "onShowUnderlay", "rejectResponderTermination", "style", "testOnly_pressed", "underlayColor"];
  //import { warnOnce } from '../../modules/warnOnce';

  function createExtraStyles(activeOpacity, underlayColor) {
    return {
      child: {
        opacity: activeOpacity !== null && activeOpacity !== undefined ? activeOpacity : 0.85
      },
      underlay: {
        backgroundColor: underlayColor === undefined ? 'black' : underlayColor
      }
    };
  }
  function hasPressHandler(props) {
    return props.onPress != null || props.onPressIn != null || props.onPressOut != null || props.onLongPress != null;
  }

  /**
   * A wrapper for making views respond properly to touches.
   * On press down, the opacity of the wrapped view is decreased, which allows
   * the underlay color to show through, darkening or tinting the view.
   *
   * The underlay comes from wrapping the child in a new View, which can affect
   * layout, and sometimes cause unwanted visual artifacts if not used correctly,
   * for example if the backgroundColor of the wrapped view isn't explicitly set
   * to an opaque color.
   *
   * TouchableHighlight must have one child (not zero or more than one).
   * If you wish to have several child components, wrap them in a View.
   */
  function TouchableHighlight(props, forwardedRef) {
    /*
    warnOnce(
      'TouchableHighlight',
      'TouchableHighlight is deprecated. Please use Pressable.'
    );
    */

    var activeOpacity = props.activeOpacity,
      children = props.children,
      delayPressIn = props.delayPressIn,
      delayPressOut = props.delayPressOut,
      delayLongPress = props.delayLongPress,
      disabled = props.disabled,
      focusable = props.focusable,
      onHideUnderlay = props.onHideUnderlay,
      onLongPress = props.onLongPress,
      onPress = props.onPress,
      onPressIn = props.onPressIn,
      onPressOut = props.onPressOut,
      onShowUnderlay = props.onShowUnderlay,
      rejectResponderTermination = props.rejectResponderTermination,
      style = props.style,
      testOnly_pressed = props.testOnly_pressed,
      underlayColor = props.underlayColor,
      rest = (0, _objectWithoutPropertiesLoose.default)(props, _excluded);
    var hostRef = (0, _react.useRef)(null);
    var setRef = (0, useMergeRefs.default)(forwardedRef, hostRef);
    var _useState = (0, _react.useState)(testOnly_pressed === true ? createExtraStyles(activeOpacity, underlayColor) : null),
      extraStyles = _useState[0],
      setExtraStyles = _useState[1];
    var showUnderlay = (0, _react.useCallback)(() => {
      if (!hasPressHandler(props)) {
        return;
      }
      setExtraStyles(createExtraStyles(activeOpacity, underlayColor));
      if (onShowUnderlay != null) {
        onShowUnderlay();
      }
    }, [activeOpacity, onShowUnderlay, props, underlayColor]);
    var hideUnderlay = (0, _react.useCallback)(() => {
      if (testOnly_pressed === true) {
        return;
      }
      if (hasPressHandler(props)) {
        setExtraStyles(null);
        if (onHideUnderlay != null) {
          onHideUnderlay();
        }
      }
    }, [onHideUnderlay, props, testOnly_pressed]);
    var pressConfig = (0, _react.useMemo)(() => ({
      cancelable: !rejectResponderTermination,
      disabled,
      delayLongPress,
      delayPressStart: delayPressIn,
      delayPressEnd: delayPressOut,
      onLongPress,
      onPress,
      onPressStart(event) {
        showUnderlay();
        if (onPressIn != null) {
          onPressIn(event);
        }
      },
      onPressEnd(event) {
        hideUnderlay();
        if (onPressOut != null) {
          onPressOut(event);
        }
      }
    }), [delayLongPress, delayPressIn, delayPressOut, disabled, onLongPress, onPress, onPressIn, onPressOut, rejectResponderTermination, showUnderlay, hideUnderlay]);
    var pressEventHandlers = (0, usePressEvents.default)(hostRef, pressConfig);
    var child = React.Children.only(children);
    return /*#__PURE__*/React.createElement(View.default, (0, _extends.default)({}, rest, pressEventHandlers, {
      accessibilityDisabled: disabled,
      focusable: !disabled && focusable !== false,
      pointerEvents: disabled ? 'box-none' : undefined,
      ref: setRef,
      style: [styles.root, style, !disabled && styles.actionable, extraStyles && extraStyles.underlay]
    }), /*#__PURE__*/React.cloneElement(child, {
      style: [child.props.style, extraStyles && extraStyles.child]
    }));
  }
  var styles = StyleSheet.default.create({
    root: {
      userSelect: 'none'
    },
    actionable: {
      cursor: 'pointer',
      touchAction: 'manipulation'
    }
  });
  var MemoedTouchableHighlight = /*#__PURE__*/React.memo(/*#__PURE__*/React.forwardRef(TouchableHighlight));
  MemoedTouchableHighlight.displayName = 'TouchableHighlight';
  var _default = MemoedTouchableHighlight;
},282,[28,44,35,143,255,43,138]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _modulesUnimplementedView = require(_dependencyMap[0]);
  var UnimplementedView = _interopDefault(_modulesUnimplementedView);
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var _default = UnimplementedView.default;
},283,[284]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _babelRuntimeHelpersExtends = require(_dependencyMap[0]);
  var _extends = _interopDefault(_babelRuntimeHelpersExtends);
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[1]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _exportsView = require(_dependencyMap[2]);
  var View = _interopDefault(_exportsView);
  var _react = require(_dependencyMap[3]);
  var React = _interopDefault(_react);
  var _excluded = ["style"];
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  /**
   * Common implementation for a simple stubbed view.
   */
  function UnimplementedView(_ref) {
    var style = _ref.style,
      props = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    return /*#__PURE__*/React.default.createElement(View.default, (0, _extends.default)({}, props, {
      style: [unimplementedViewStyles, style]
    }));
  }
  var unimplementedViewStyles = {};
  var _default = UnimplementedView;
},284,[28,44,138,35]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   * @format
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _react = require(_dependencyMap[0]);
  var React = _interopNamespace(_react);
  var _modulesPick = require(_dependencyMap[1]);
  var pick = _interopDefault(_modulesPick);
  var _modulesUseMergeRefs = require(_dependencyMap[2]);
  var useMergeRefs = _interopDefault(_modulesUseMergeRefs);
  var _modulesUsePressEvents = require(_dependencyMap[3]);
  var usePressEvents = _interopDefault(_modulesUsePressEvents);
  var _modulesWarnOnce = require(_dependencyMap[4]);
  var forwardPropsList = {
    accessibilityDisabled: true,
    accessibilityLabel: true,
    accessibilityLiveRegion: true,
    accessibilityRole: true,
    accessibilityState: true,
    accessibilityValue: true,
    children: true,
    disabled: true,
    focusable: true,
    nativeID: true,
    onBlur: true,
    onFocus: true,
    onLayout: true,
    testID: true
  };
  var pickProps = props => (0, pick.default)(props, forwardPropsList);
  function TouchableWithoutFeedback(props, forwardedRef) {
    (0, _modulesWarnOnce.warnOnce)('TouchableWithoutFeedback', 'TouchableWithoutFeedback is deprecated. Please use Pressable.');
    var delayPressIn = props.delayPressIn,
      delayPressOut = props.delayPressOut,
      delayLongPress = props.delayLongPress,
      disabled = props.disabled,
      focusable = props.focusable,
      onLongPress = props.onLongPress,
      onPress = props.onPress,
      onPressIn = props.onPressIn,
      onPressOut = props.onPressOut,
      rejectResponderTermination = props.rejectResponderTermination;
    var hostRef = (0, _react.useRef)(null);
    var pressConfig = (0, _react.useMemo)(() => ({
      cancelable: !rejectResponderTermination,
      disabled,
      delayLongPress,
      delayPressStart: delayPressIn,
      delayPressEnd: delayPressOut,
      onLongPress,
      onPress,
      onPressStart: onPressIn,
      onPressEnd: onPressOut
    }), [disabled, delayPressIn, delayPressOut, delayLongPress, onLongPress, onPress, onPressIn, onPressOut, rejectResponderTermination]);
    var pressEventHandlers = (0, usePressEvents.default)(hostRef, pressConfig);
    var element = React.Children.only(props.children);
    var children = [element.props.children];
    var supportedProps = pickProps(props);
    supportedProps.accessibilityDisabled = disabled;
    supportedProps.focusable = !disabled && focusable !== false;
    supportedProps.ref = (0, useMergeRefs.default)(forwardedRef, hostRef, element.ref);
    var elementProps = Object.assign(supportedProps, pressEventHandlers);
    return /*#__PURE__*/React.cloneElement(element, elementProps, ...children);
  }
  var MemoedTouchableWithoutFeedback = /*#__PURE__*/React.memo(/*#__PURE__*/React.forwardRef(TouchableWithoutFeedback));
  MemoedTouchableWithoutFeedback.displayName = 'TouchableWithoutFeedback';
  var _default = MemoedTouchableWithoutFeedback;
},285,[35,140,143,255,88]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativeVirtualizedList = require(_dependencyMap[0]);
  var VirtualizedList = _interopDefault(_vendorReactNativeVirtualizedList);
  var _default = VirtualizedList.default;
},286,[156]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _react = require(_dependencyMap[0]);
  var React = _interopDefault(_react);
  var _modulesUnimplementedView = require(_dependencyMap[1]);
  var UnimplementedView = _interopDefault(_modulesUnimplementedView);
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  function YellowBox(props) {
    return /*#__PURE__*/React.default.createElement(UnimplementedView.default, props);
  }
  YellowBox.ignoreWarnings = () => {};
  var _default = YellowBox;
},287,[35,284]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  /**
   * Copyright (c) 2016-present, Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  var LogBox = {
    ignoreLogs() {},
    ignoreAllLogs() {},
    uninstall() {},
    install() {}
  };
  var _default = LogBox;
},288,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _vendorReactNativeEventEmitterRCTDeviceEventEmitter = require(_dependencyMap[0]);
  var RCTDeviceEventEmitter = _interopDefault(_vendorReactNativeEventEmitterRCTDeviceEventEmitter);
  var _default = RCTDeviceEventEmitter.default;
},289,[198]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useColorScheme;
    }
  });
  var _react = require(_dependencyMap[0]);
  var React = _interopNamespace(_react);
  var _Appearance = require(_dependencyMap[1]);
  var Appearance = _interopDefault(_Appearance);
  function useColorScheme() {
    var _React$useState = React.useState(Appearance.default.getColorScheme()),
      colorScheme = _React$useState[0],
      setColorScheme = _React$useState[1];
    React.useEffect(() => {
      function listener(appearance) {
        setColorScheme(appearance.colorScheme);
      }
      var _Appearance$addChange = Appearance.default.addChangeListener(listener),
        remove = _Appearance$addChange.remove;
      return remove;
    });
    return colorScheme;
  }
},290,[35,237]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Nicolas Gallagher.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _modulesUseLocale = require(_dependencyMap[0]);
  var _default = _modulesUseLocale.useLocaleContext;
},291,[122]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return useWindowDimensions;
    }
  });
  var _Dimensions = require(_dependencyMap[0]);
  var Dimensions = _interopDefault(_Dimensions);
  var _react = require(_dependencyMap[1]);
  function useWindowDimensions() {
    var _useState = (0, _react.useState)(() => Dimensions.default.get('window')),
      dims = _useState[0],
      setDims = _useState[1];
    (0, _react.useEffect)(() => {
      function handleChange(_ref) {
        var window = _ref.window;
        if (window != null) {
          setDims(window);
        }
      }
      Dimensions.default.addEventListener('change', handleChange);
      // We might have missed an update between calling `get` in render and
      // `addEventListener` in this handler, so we set it here. If there was
      // no change, React will filter out this update as a no-op.
      setDims(Dimensions.default.get('window'));
      return () => {
        Dimensions.default.removeEventListener('change', handleChange);
      };
    }, []);
    return dims;
  }
},292,[162,35]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "NativeModule", {
    enumerable: true,
    get: function () {
      return NativeModule;
    }
  });
  var _ensureNativeModulesAreInstalled = require(_dependencyMap[0]);
  (0, _ensureNativeModulesAreInstalled.ensureNativeModulesAreInstalled)();
  const NativeModule = globalThis.expo.NativeModule;
},293,[114]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "SharedObject", {
    enumerable: true,
    get: function () {
      return SharedObject;
    }
  });
  var _ensureNativeModulesAreInstalled = require(_dependencyMap[0]);
  (0, _ensureNativeModulesAreInstalled.ensureNativeModulesAreInstalled)();
  const SharedObject = globalThis.expo.SharedObject;
},294,[114]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "SharedRef", {
    enumerable: true,
    get: function () {
      return SharedRef;
    }
  });
  var _ensureNativeModulesAreInstalled = require(_dependencyMap[0]);
  (0, _ensureNativeModulesAreInstalled.ensureNativeModulesAreInstalled)();
  const SharedRef = globalThis.expo.SharedRef;
},295,[114]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  var _reactNativeWebDistExportsPlatform = require(_dependencyMap[0]);
  var ReactNativePlatform = _interopDefault(_reactNativeWebDistExportsPlatform);
  var _environmentBrowser = require(_dependencyMap[1]);
  const nativeSelect = typeof window !== 'undefined' ? ReactNativePlatform.default.select :
  // process.env.EXPO_OS is injected by `babel-preset-expo` and available in both client and `react-server` environments.
  // Opt to use the env var when possible, and fallback to the React Native Platform module when it's not (arbitrary bundlers and transformers).
  function select(specifics) {
    if (specifics.hasOwnProperty("web")) {
      return specifics["web"];
    } else if (specifics.hasOwnProperty('default')) {
      return specifics.default;
    }
    // do nothing...
    return undefined;
  };
  const Platform = {
    /**
     * Denotes the currently running platform.
     * Can be one of ios, android, web.
     */
    OS: "web",
    /**
     * Returns the value with the matching platform.
     * Object keys can be any of ios, android, native, web, default.
     *
     * @ios ios, native, default
     * @android android, native, default
     * @web web, default
     */
    select: nativeSelect,
    /**
     * Denotes if the DOM API is available in the current environment.
     * The DOM is not available in native React runtimes and Node.js.
     */
    isDOMAvailable: _environmentBrowser.isDOMAvailable,
    /**
     * Denotes if the current environment can attach event listeners
     * to the window. This will return false in native React
     * runtimes and Node.js.
     */
    canUseEventListeners: _environmentBrowser.canUseEventListeners,
    /**
     * Denotes if the current environment can inspect properties of the
     * screen on which the current window is being rendered. This will
     * return false in native React runtimes and Node.js.
     */
    canUseViewport: _environmentBrowser.canUseViewport,
    /**
     * If the JavaScript is being executed in a remote JavaScript environment.
     * When `true`, synchronous native invocations cannot be executed.
     */
    isAsyncDebugging: _environmentBrowser.isAsyncDebugging
  };
  var _default = Platform;
},296,[96,297]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "isDOMAvailable", {
    enumerable: true,
    get: function () {
      return isDOMAvailable;
    }
  });
  Object.defineProperty(exports, "canUseEventListeners", {
    enumerable: true,
    get: function () {
      return canUseEventListeners;
    }
  });
  Object.defineProperty(exports, "canUseViewport", {
    enumerable: true,
    get: function () {
      return canUseViewport;
    }
  });
  Object.defineProperty(exports, "isAsyncDebugging", {
    enumerable: true,
    get: function () {
      return isAsyncDebugging;
    }
  });
  // Used for delegating node actions when browser APIs aren't available
  // like in SSR websites.
  const isDOMAvailable = typeof window !== 'undefined' && !!window.document?.createElement;
  const canUseEventListeners = isDOMAvailable && !!(window.addEventListener || window.attachEvent);
  const canUseViewport = isDOMAvailable && !!window.screen;
  const isAsyncDebugging = false;
},297,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.requireNativeViewManager = requireNativeViewManager;
  var _errorsUnavailabilityError = require(_dependencyMap[0]);
  /**
   * A drop-in replacement for `requireNativeComponent`.
   */
  function requireNativeViewManager(moduleName, viewName) {
    throw new _errorsUnavailabilityError.UnavailabilityError('expo-modules-core', 'requireNativeViewManager');
  }
},298,[299]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "UnavailabilityError", {
    enumerable: true,
    get: function () {
      return UnavailabilityError;
    }
  });
  var _CodedError = require(_dependencyMap[0]);
  require(_dependencyMap[1]);
  /**
   * A class for errors to be thrown when a property is accessed which is
   * unavailable, unsupported, or not currently implemented on the running
   * platform.
   */
  class UnavailabilityError extends _CodedError.CodedError {
    constructor(moduleName, propertyName) {
      super('ERR_UNAVAILABLE', `The method or property ${moduleName}.${propertyName} is not available on ${"web"}, are you sure you've linked all the native dependencies properly?`);
    }
  }
},299,[300,296]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "CodedError", {
    enumerable: true,
    get: function () {
      return CodedError;
    }
  });
  /**
   * A general error class that should be used for all errors in Expo modules.
   * Guarantees a `code` field that can be used to differentiate between different
   * types of errors without further subclassing Error.
   */
  class CodedError extends Error {
    constructor(code, message) {
      super(message);
      this.code = code;
    }
  }
},300,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.requireNativeModule = requireNativeModule;
  exports.requireOptionalNativeModule = requireOptionalNativeModule;
  function requireNativeModule(moduleName) {
    const nativeModule = requireOptionalNativeModule(moduleName);
    if (nativeModule != null) {
      return nativeModule;
    }
    if (typeof window === 'undefined') {
      // For SSR, we expect not to have native modules available, but to avoid crashing from SSR resolutions, we return an empty object.
      return {};
    }
    throw new Error(`Cannot find native module '${moduleName}'`);
  }
  function requireOptionalNativeModule(moduleName) {
    if (typeof globalThis.ExpoDomWebView === 'object' && globalThis?.expo?.modules != null) {
      return globalThis.expo?.modules?.[moduleName] ?? null;
    }
    return null;
  }
},301,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.registerWebModule = registerWebModule;
  var _ensureNativeModulesAreInstalled = require(_dependencyMap[0]);
  /**
   * Registers a web module.
   * @param moduleImplementation A class that extends `NativeModule`. The class is registered under `globalThis.expo.modules[className]`.
   * @param moduleName – a name to register the module under `globalThis.expo.modules[className]`.
   * @returns A singleton instance of the class passed into arguments.
   */

  function registerWebModule(moduleImplementation, moduleName) {
    (0, _ensureNativeModulesAreInstalled.ensureNativeModulesAreInstalled)();
    moduleName = moduleName ?? moduleImplementation.name;
    if (!moduleName) {
      throw new Error('Web module implementation is missing a name - it is either not a class or has been minified. Pass the name as a second argument to the `registerWebModule` function.');
    }
    if (!globalThis?.expo?.modules) {
      globalThis.expo.modules = {};
    }
    if (globalThis.expo.modules[moduleName]) {
      return globalThis.expo.modules[moduleName];
    }
    globalThis.expo.modules[moduleName] = new moduleImplementation();
    return globalThis.expo.modules[moduleName];
  }
},302,[114]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";
},303,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "PermissionStatus", {
    enumerable: true,
    get: function () {
      return PermissionStatus;
    }
  });
  let PermissionStatus = /*#__PURE__*/function (PermissionStatus) {
    /**
     * User has granted the permission.
     */
    PermissionStatus["GRANTED"] = "granted";
    /**
     * User hasn't granted or denied the permission yet.
     */
    PermissionStatus["UNDETERMINED"] = "undetermined";
    /**
     * User has denied the permission.
     */
    PermissionStatus["DENIED"] = "denied";
    return PermissionStatus;
  }({});
  /**
   * Permission expiration time. Currently, all permissions are granted permanently.
   */
  /**
   * An object obtained by permissions get and request functions.
   */
},304,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  // Copyright © 2024 650 Industries.

  'use client';
  "use strict";

  const _excluded = ["get", "request"];
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.createPermissionHook = createPermissionHook;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  var _react = require(_dependencyMap[1]);
  // These types are identical, but improves the readability for suggestions in editors

  /**
   * Get or request permission for protected functionality within the app.
   * It uses separate permission requesters to interact with a single permission.
   * By default, the hook will only retrieve the permission status.
   */
  function usePermission(methods, options) {
    const isMounted = (0, _react.useRef)(true);
    const [status, setStatus] = (0, _react.useState)(null);
    const _ref = options || {},
      {
        get = true,
        request = false
      } = _ref,
      permissionOptions = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    const getPermission = (0, _react.useCallback)(async () => {
      let response;
      if (Object.keys(permissionOptions).length > 0) {
        response = await methods.getMethod(permissionOptions);
      } else {
        response = await methods.getMethod();
      }
      if (isMounted.current) setStatus(response);
      return response;
    }, [methods.getMethod]);
    const requestPermission = (0, _react.useCallback)(async () => {
      let response;
      if (Object.keys(permissionOptions).length > 0) {
        response = await methods.requestMethod(permissionOptions);
      } else {
        response = await methods.requestMethod();
      }
      if (isMounted.current) setStatus(response);
      return response;
    }, [methods.requestMethod]);
    (0, _react.useEffect)(function runMethods() {
      if (request) requestPermission();
      if (!request && get) getPermission();
    }, [get, request, requestPermission, getPermission]);

    // Workaround for unmounting components receiving state updates
    (0, _react.useEffect)(function didMount() {
      isMounted.current = true;
      return () => {
        isMounted.current = false;
      };
    }, []);
    return [status, requestPermission, getPermission];
  }

  /**
   * Create a new permission hook with the permission methods built-in.
   * This can be used to quickly create specific permission hooks in every module.
   */
  function createPermissionHook(methods) {
    return options => usePermission(methods, options);
  }
},305,[306,35]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
      if (e.includes(n)) continue;
      t[n] = r[n];
    }
    return t;
  }
  module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;
},306,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.createSnapshotFriendlyRef = createSnapshotFriendlyRef;
  var _react = require(_dependencyMap[0]);
  /**
   * Create a React ref object that is friendly for snapshots.
   * It will be represented as `[React.ref]` in snapshots.
   * @returns A React ref object.
   */
  function createSnapshotFriendlyRef() {
    return /*#__PURE__*/(0, _react.createRef)();
  }
},307,[35]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.useReleasingSharedObject = useReleasingSharedObject;
  var _react = require(_dependencyMap[0]);
  /**
   * Returns a shared object, which is automatically cleaned up when the component is unmounted.
   */
  function useReleasingSharedObject(factory, dependencies) {
    const objectRef = (0, _react.useRef)(null);
    const isFastRefresh = (0, _react.useRef)(false);
    const previousDependencies = (0, _react.useRef)(dependencies);
    if (objectRef.current == null) {
      objectRef.current = factory();
    }
    const object = (0, _react.useMemo)(() => {
      let newObject = objectRef.current;
      const dependenciesAreEqual = previousDependencies.current?.length === dependencies.length && dependencies.every((value, index) => value === previousDependencies.current[index]);

      // If the dependencies have changed, release the previous object and create a new one, otherwise this has been called
      // because of a fast refresh, and we don't want to release the object.
      if (!newObject || !dependenciesAreEqual) {
        objectRef.current?.release();
        newObject = factory();
        objectRef.current = newObject;
        previousDependencies.current = dependencies;
      } else {
        isFastRefresh.current = true;
      }
      return newObject;
    }, dependencies);
    (0, _react.useEffect)(() => {
      isFastRefresh.current = false;
      return () => {
        // This will be called on every fast refresh and on unmount, but we only want to release the object on unmount.
        if (!isFastRefresh.current && objectRef.current) {
          objectRef.current.release();
        }
      };
    }, []);
    return object;
  }
},308,[35]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.reloadAppAsync = reloadAppAsync;
  /**
   * Reloads the app. This method works for both release and debug builds.
   *
   * Unlike [`Updates.reloadAsync()`](/versions/latest/sdk/updates/#updatesreloadasync),
   * this function does not use a new update even if one is available. It only reloads the app using the same JavaScript bundle that is currently running.
   *
   * @param reason The reason for reloading the app. This is used only for some platforms.
   */
  async function reloadAppAsync(reason = 'Reloaded from JS call') {
    await globalThis.expo?.reloadAppAsync(reason);
  }
},309,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "LegacyEventEmitter", {
    enumerable: true,
    get: function () {
      return LegacyEventEmitter;
    }
  });
  var _invariant = require(_dependencyMap[0]);
  var invariant = _interopDefault(_invariant);
  var _reactNativeWebDistExportsNativeEventEmitter = require(_dependencyMap[1]);
  var NativeEventEmitter = _interopDefault(_reactNativeWebDistExportsNativeEventEmitter);
  require(_dependencyMap[2]);
  const nativeEmitterSubscriptionKey = '@@nativeEmitterSubscription@@';
  /**
   * @deprecated Deprecated in favor of `EventEmitter`.
   */
  class LegacyEventEmitter {
    _listenerCount = 0;

    // @ts-expect-error

    // @ts-expect-error

    constructor(nativeModule) {
      // If the native module is a new module, just return it back as it's already an event emitter.
      // This is for backwards compatibility until we stop using this legacy class in other packages.
      if (nativeModule.__expo_module_name__) {
        // @ts-expect-error
        return nativeModule;
      }
      this._nativeModule = nativeModule;
      this._eventEmitter = new NativeEventEmitter.default(nativeModule);
    }
    addListener(eventName, listener) {
      if (!this._listenerCount && true && this._nativeModule.startObserving) {
        this._nativeModule.startObserving();
      }
      this._listenerCount++;
      const nativeEmitterSubscription = this._eventEmitter.addListener(eventName, listener);
      const subscription = {
        [nativeEmitterSubscriptionKey]: nativeEmitterSubscription,
        remove: () => {
          this.removeSubscription(subscription);
        }
      };
      return subscription;
    }
    removeAllListeners(eventName) {
      // @ts-ignore: the EventEmitter interface has been changed in react-native@0.64.0
      const removedListenerCount = this._eventEmitter.listenerCount ?
      // @ts-ignore: this is available since 0.64
      this._eventEmitter.listenerCount(eventName) :
      // @ts-ignore: this is available in older versions
      this._eventEmitter.listeners(eventName).length;
      this._eventEmitter.removeAllListeners(eventName);
      this._listenerCount -= removedListenerCount;
      (0, invariant.default)(this._listenerCount >= 0, `EventEmitter must have a non-negative number of listeners`);
      if (!this._listenerCount && true && this._nativeModule.stopObserving) {
        this._nativeModule.stopObserving();
      }
    }
    removeSubscription(subscription) {
      const state = subscription;
      const nativeEmitterSubscription = state[nativeEmitterSubscriptionKey];
      if (!nativeEmitterSubscription) {
        return;
      }
      if ('remove' in nativeEmitterSubscription) {
        nativeEmitterSubscription.remove?.();
      }
      this._listenerCount--;

      // Ensure that the emitter's internal state remains correct even if `removeSubscription` is
      // called again with the same subscription
      delete state[nativeEmitterSubscriptionKey];

      // Release closed-over references to the emitter
      subscription.remove = () => {};
      if (!this._listenerCount && true && this._nativeModule.stopObserving) {
        this._nativeModule.stopObserving();
      }
    }
    emit(eventName, ...params) {
      this._eventEmitter.emit(eventName, ...params);
    }
  }
},310,[311,246,96]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use strict';

  /**
   * Use invariant() to assert state which your program assumes to be true.
   *
   * Provide sprintf-style format (only %s is supported) and arguments
   * to provide information about what broke and what you were
   * expecting.
   *
   * The invariant message will be stripped in production, but the invariant
   * will remain to ensure logic does not differ in production.
   */
  var invariant = function (condition, format, a, b, c, d, e, f) {
    if (!condition) {
      var error;
      if (format === undefined) {
        error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      } else {
        var args = [a, b, c, d, e, f];
        var argIndex = 0;
        error = new Error(format.replace(/%s/g, function () {
          return args[argIndex++];
        }));
        error.name = 'Invariant Violation';
      }
      error.framesToPop = 1; // we don't care about invariant's own frame
      throw error;
    }
  };
  module.exports = invariant;
},311,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _default;
    }
  });
  // We default to an empty object shim wherever we don't have an environment-specific implementation

  /**
   * @deprecated `NativeModulesProxy` is deprecated and might be removed in the future releases.
   * Use `requireNativeModule` or `requireOptionalNativeModule` instead.
   */
  var _default = {};
},312,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.useEvent = useEvent;
  exports.useEventListener = useEventListener;
  var _react = require(_dependencyMap[0]);
  /**
   * Type helper that infers the event name from the emitter's events map.
   */

  /**
   * Type helper that infers the event listener from the emitter's events map.
   */

  /**
   * Type helper that infers the first parameter of the event listener.
   */

  /**
   * React hook that listens to events emitted by the given object. The returned value is an event parameter
   * that gets updated whenever a new event is dispatched.
   * @param eventEmitter An object that emits events. For example, a native module or shared object or an instance of [`EventEmitter`](#eventemitter).
   * @param eventName Name of the event to listen to.
   * @param initialValue An event parameter to use until the event is called for the first time.
   * @returns A parameter of the event listener.
   * @example
   * ```tsx
   * import { useEvent } from 'expo';
   * import { VideoPlayer } from 'expo-video';
   *
   * export function PlayerStatus({ videoPlayer }: { videoPlayer: VideoPlayer }) {
   *   const { status } = useEvent(videoPlayer, 'statusChange', { status: videoPlayer.status });
   *
   *   return <Text>{`Player status: ${status}`}</Text>;
   * }
   * ```
   */
  function useEvent(eventEmitter, eventName, initialValue = null) {
    const [event, setEvent] = (0, _react.useState)(initialValue);
    const listener = event => setEvent(event);
    useEventListener(eventEmitter, eventName, listener);
    return event;
  }

  /**
   * React hook that listens to events emitted by the given object and calls the listener function whenever a new event is dispatched.
   * The event listener is automatically added during the first render and removed when the component unmounts.
   * @param eventEmitter An object that emits events. For example, a native module or shared object or an instance of [`EventEmitter`](#eventemitter).
   * @param eventName Name of the event to listen to.
   * @param listener A function to call when the event is dispatched.
   * @example
   * ```tsx
   * import { useEventListener } from 'expo';
   * import { useVideoPlayer, VideoView } from 'expo-video';
   *
   * export function VideoPlayerView() {
   *   const player = useVideoPlayer(videoSource);
   *
   *   useEventListener(player, 'playingChange', ({ isPlaying }) => {
   *     console.log('Player is playing:', isPlaying);
   *   });
   *
   *   return <VideoView player={player} />;
   * }
   * ```
   */
  function useEventListener(eventEmitter, eventName, listener) {
    // Always use the most recent version of the listener inside the effect,
    // without memoization so the listeners don't have to be swapped with every render.
    const listenerRef = (0, _react.useRef)(listener);
    listenerRef.current = listener;
    (0, _react.useEffect)(() => {
      const callback = (...args) => listenerRef.current(...args);
      const subscription = eventEmitter.addListener(eventName, callback);
      return () => subscription.remove();
    }, [eventEmitter, eventName, listenerRef]);
  }
},313,[35]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return App;
    }
  });
  require(_dependencyMap[0]);
  var _srcErrorOverlay = require(_dependencyMap[1]);
  var _srcDataLogBoxLog = require(_dependencyMap[2]);
  var _reactJsxRuntime = require(_dependencyMap[3]);
  const _testMessage = `message	String	"Unable to resolve module ./error-overlay/LogBox from /Users/krystofwoldrich/repos/expo/expo/packages/@expo/metro-runtime/src/index.ts: \n\nNone of these files exist:\n  * ../../packages/@expo/metro-runtime/src/error-overlay/LogBox(.ios.ts|.native.ts|.ts|.ios.tsx|.native.tsx|.tsx|.ios.mjs|.native.mjs|.mjs|.ios.js|.native.js|.js|.ios.jsx|.native.jsx|.jsx|.ios.json|.native.json|.json|.ios.cjs|.native.cjs|.cjs|.ios.scss|.native.scss|.scss|.ios.sass|.native.sass|.sass|.ios.css|.native.css|.css)\n  * ../../packages/@expo/metro-runtime/src/error-overlay/LogBox\n\x1b[0m \x1b[90m 18 |\x1b[39m\n \x1b[90m 19 |\x1b[39m   \x1b[90m// @ts-expect-error: TODO: Remove this when we remove the log box.\x1b[39m\n\x1b[31m\x1b[1m>\x1b[22m\x1b[39m\x1b[90m 20 |\x1b[39m   globalThis\x1b[33m.\x1b[39m__expo_dev_resetErrors \x1b[33m=\x1b[39m require(\x1b[32m'./error-overlay/LogBox'\x1b[39m)\x1b[33m.\x1b[39m\x1b[36mdefault\x1b[39m\x1b[33m.\x1b[39mclearAllLogs\x1b[33m;\x1b[39m\n \x1b[90m    |\x1b[39m                                                \x1b[31m\x1b[1m^\x1b[22m\x1b[39m\n \x1b[90m 21 |\x1b[39m }\n \x1b[90m 22 |\x1b[39m\x1b[0m"	`;
  const logs = [
  // new LogBoxLog(parseLogBoxException({
  //   originalMessage: (globalThis as any).__expoLogBoxNativeData?.rawMessage,
  //   // originalMessage: testMessage,
  //   stack: [],
  // })),
  new _srcDataLogBoxLog.LogBoxLog({
    level: 'syntax',
    stack: [],
    isComponentError: false,
    componentStack: [],
    codeFrame: {
      stack: {
        fileName: 'apps/router-e2e/__e2e__/05-errors/app/index.tsx',
        content: "\u001b[0m \u001b[90m 66 |\u001b[39m \u001b[36mfunction\u001b[39m \u001b[33mRWarningMissingKeys\u001b[39m() {\n \u001b[90m 67 |\u001b[39m   \u001b[36mreturn\u001b[39m (\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 68 |\u001b[39m     \u001b[33m<\u001b[39m\u001b[33m>\u001b[39m\n \u001b[90m    |\u001b[39m     \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 69 |\u001b[39m       {\u001b[33mArray\u001b[39m\u001b[33m.\u001b[39m\u001b[36mfrom\u001b[39m({ length\u001b[33m:\u001b[39m \u001b[35m3\u001b[39m }\u001b[33m,\u001b[39m (_\u001b[33m,\u001b[39m i) \u001b[33m=>\u001b[39m (\n \u001b[90m 70 |\u001b[39m         \u001b[33m<\u001b[39m\u001b[33mView\u001b[39m style\u001b[33m=\u001b[39m{{ padding\u001b[33m:\u001b[39m \u001b[35m8\u001b[39m\u001b[33m,\u001b[39m backgroundColor\u001b[33m:\u001b[39m \u001b[32m'white'\u001b[39m }}\u001b[33m>\u001b[39m\u001b[33m<\u001b[39m\u001b[33m/\u001b[39m\u001b[33mView\u001b[39m\u001b[33m>\u001b[39m\n \u001b[90m 71 |\u001b[39m       ))\u001b[33m.\u001b[39mreverse()}\u001b[0m",
        location: {
          row: 68,
          column: 4
        }
        //           content: `
        //    5 | // TODO: How to import for testing?
        //    6 | // import HMRClient from 'expo/build/async-require/hmr';
        // >  7 | import './foobar';
        //      |         ^
        //    8 |
        //    9 | // eval('clasfs Foo {}');
        //   10 |
        // `,
      }
    },
    message: {
      content: 'Unable to resolve "./foobar" from "apps/router-e2e/__e2e__/05-errors/app/index.tsx"',
      substitutions: []
    },
    category: `apps/router-e2e/__e2e__/05-errors/app/index.tsx-7-9`
  })];
  console.log('logs', JSON.stringify(logs, null, 2));
  function App() {
    const selectedLogIndex = logs.length > 0 ? 0 : -1;
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_srcErrorOverlay.LogBoxContent, {
      log: logs[selectedLogIndex],
      selectedLogIndex: selectedLogIndex,
      logs: logs
    });
  }
},314,[35,315,322,323]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use dom';

  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  exports.LogBoxInspectorContainer = LogBoxInspectorContainer;
  exports.LogBoxInspector = LogBoxInspector;
  exports.LogBoxContent = LogBoxContent;
  exports.presentGlobalErrorOverlay = presentGlobalErrorOverlay;
  exports.dismissGlobalErrorOverlay = dismissGlobalErrorOverlay;
  var _react = require(_dependencyMap[0]);
  var React = _interopDefault(_react);
  var _DataLogBoxData = require(_dependencyMap[1]);
  var LogBoxData = _interopNamespace(_DataLogBoxData);
  var _DataLogBoxLog = require(_dependencyMap[2]);
  var _overlayErrorCodeFrame = require(_dependencyMap[3]);
  var _overlayErrorOverlayHeader = require(_dependencyMap[4]);
  var _overlayStackTraceList = require(_dependencyMap[5]);
  var _reactDomClient = require(_dependencyMap[6]);
  var ReactDOM = _interopDefault(_reactDomClient);
  var _devServerEndpoints = require(_dependencyMap[7]);
  require(_dependencyMap[8]);
  var _ErrorOverlayModuleCss = require(_dependencyMap[9]);
  var styles = _interopDefault(_ErrorOverlayModuleCss);
  var _LogBoxMessage = require(_dependencyMap[10]);
  var _reactJsxRuntime = require(_dependencyMap[11]);
  // @ts-ignore TODO: add ts css plugin
  // @ts-ignore TODO: add ts css plugin
  const HEADER_TITLE_MAP = {
    error: 'Console Error',
    fatal: 'Uncaught Error',
    resolution: 'Resolution Error',
    syntax: 'Build Error',
    static: 'Server Error'
  };
  function LogBoxInspectorContainer() {
    const {
      selectedLogIndex,
      logs
    } = (0, _DataLogBoxLog.useLogs)();
    const log = logs[selectedLogIndex];
    if (log == null) {
      return null;
    }
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(LogBoxInspector, {
      log: log,
      selectedLogIndex: selectedLogIndex,
      logs: logs
    });
  }
  function useDevServerMeta() {
    const [meta, setMeta] = (0, _react.useState)(null);
    (0, _react.useEffect)(() => {
      (0, _devServerEndpoints.fetchProjectMetadataAsync)().then(setMeta).catch(error => {
        console.log(`Failed to fetch project metadata. Some debugging features may not work as expected: ${error}`);
      });
    }, []);
    return meta;
  }
  function LogBoxInspector({
    log,
    selectedLogIndex,
    logs
  }) {
    const isDismissable = !['static', 'syntax', 'resolution'].includes(log.level);
    const [closing, setClosing] = (0, _react.useState)(false);
    const animateClosed = callback => {
      setClosing(true);
      setTimeout(() => {
        callback();
      }, 200);
    };
    const onMinimize = (0, _react.useCallback)(() => {
      animateClosed(() => {
        LogBoxData.setSelectedLog(-1);
      });
    }, []);
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactJsxRuntime.Fragment, {
      children: /*#__PURE__*/(0, _reactJsxRuntime.jsxs)("div", {
        className: styles.default.overlay,
        children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)("div", {
          "data-expo-log-backdrop": "true",
          className: `${styles.default.bg} ${closing ? styles.default.bgExit : ''}`,
          onClick: () => {
            if (isDismissable) {
              onMinimize();
            }
          }
        }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("div", {
          className: `${styles.default.container} ${closing ? styles.default.containerExit : ''}`,
          children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(LogBoxContent, {
            log: log,
            selectedLogIndex: selectedLogIndex,
            logs: logs
          })
        })]
      })
    });
  }
  function LogBoxContent({
    log,
    selectedLogIndex,
    logs
  }) {
    const meta = useDevServerMeta();
    const isDismissable = !['static', 'syntax', 'resolution'].includes(log.level);
    const [_, setClosing] = (0, _react.useState)(false);
    const projectRoot = meta?.projectRoot;
    const animateClosed = callback => {
      setClosing(true);
      setTimeout(() => {
        callback();
      }, 200);
    };
    const onDismiss = () => {
      // Here we handle the cases when the log is dismissed and it
      // was either the last log, or when the current index
      // is now outside the bounds of the log array.
      const logsArray = Array.from(logs);
      if (selectedLogIndex != null) {
        if (logsArray.length - 1 <= 0) {
          animateClosed(() => {
            LogBoxData.setSelectedLog(-1);
          });
        } else if (selectedLogIndex >= logsArray.length - 1) {
          LogBoxData.setSelectedLog(selectedLogIndex - 1);
        }
        if (logs.length === 1) {
          animateClosed(() => {
            LogBoxData.dismiss(logsArray[selectedLogIndex]);
          });
        } else {
          LogBoxData.dismiss(logsArray[selectedLogIndex]);
        }
      }
    };
    const onMinimize = (0, _react.useCallback)(() => {
      animateClosed(() => {
        LogBoxData.setSelectedLog(-1);
      });
    }, []);
    const onChangeSelectedIndex = (0, _react.useCallback)(index => {
      LogBoxData.setSelectedLog(index);
    }, []);
    (0, _react.useEffect)(() => {
      if (log) {
        LogBoxData.symbolicateLogNow('stack', log);
        LogBoxData.symbolicateLogNow('component', log);
      }
    }, [log]);
    (0, _react.useEffect)(() => {
      // Optimistically symbolicate the last and next logs.
      if (logs.length > 1) {
        const selected = selectedLogIndex;
        const lastIndex = logs.length - 1;
        const prevIndex = selected - 1 < 0 ? lastIndex : selected - 1;
        const nextIndex = selected + 1 > lastIndex ? 0 : selected + 1;
        for (const type of ['component', 'stack']) {
          LogBoxData.symbolicateLogLazy(type, logs[prevIndex]);
          LogBoxData.symbolicateLogLazy(type, logs[nextIndex]);
        }
      }
    }, [logs, selectedLogIndex]);
    const _handleRetry = (0, _react.useCallback)(type => {
      LogBoxData.retrySymbolicateLogNow(type, log);
    }, [log]);
    const onCopy = () => {
      // Copy log to clipboard
      const errContents = [log.message.content.trim()];
      const componentStack = log.getAvailableStack('component');
      if (componentStack?.length) {
        errContents.push('', 'Component Stack', (0, _devServerEndpoints.getFormattedStackTrace)(projectRoot ?? '', componentStack));
      }
      const stackTrace = log.getAvailableStack('stack');
      if (stackTrace?.length) {
        errContents.push('', 'Call Stack', (0, _devServerEndpoints.getFormattedStackTrace)(projectRoot ?? '', stackTrace));
      }

      // @ts-ignore
      if (typeof __polyfill_onCopyText === 'function') {
        // @ts-ignore
        __polyfill_onCopyText(errContents.join('\n'));
      } else {
        // Fallback to the default copy function
        navigator.clipboard.writeText(errContents.join('\n'));
      }
    };
    const [collapsed, setCollapsed] = (0, _react.useState)(true);
    const headerTitle = HEADER_TITLE_MAP[log.level] ?? log.type;
    const headerBlurRef = React.default.useRef(null);
    const scrollRef = React.default.useRef(null);

    // Transition the opacity of the header blur when the scroll position changes.
    (0, _react.useEffect)(() => {
      const scrollElement = scrollRef.current;
      const headerBlurElement = headerBlurRef.current;
      if (scrollElement && headerBlurElement) {
        const handleScroll = () => {
          const scrollTop = scrollElement.scrollTop;
          const opacity = Math.min(scrollTop / 16, 1);
          headerBlurElement.style.opacity = `${opacity}`;
        };
        scrollElement.addEventListener('scroll', handleScroll);
        return () => {
          scrollElement.removeEventListener('scroll', handleScroll);
        };
      }
      return () => {};
    }, [scrollRef, headerBlurRef]);
    let codeFrames = log?.codeFrame ? Object.entries(log.codeFrame).filter(([, value]) => value?.content) : [];
    codeFrames = uniqueBy(uniqueBy(codeFrames, ([, value]) => {
      return [value.fileName, value.location?.column, value.location?.row].join(':');
    }), ([, value]) => {
      return value?.content;
    });
    return /*#__PURE__*/(0, _reactJsxRuntime.jsxs)("div", {
      className: styles.default.content,
      children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)("div", {
        className: styles.default.headerBlur,
        ref: headerBlurRef
      }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("div", {
        style: {
          position: 'sticky',
          top: 0,
          left: 0,
          right: 0,
          zIndex: 1,
          backgroundColor: 'var(--expo-log-color-background)'
        },
        children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_overlayErrorOverlayHeader.ErrorOverlayHeader, {
          sdkVersion: meta?.sdkVersion,
          selectedIndex: selectedLogIndex,
          total: logs.length,
          isDismissable: isDismissable,
          onDismiss: onDismiss,
          onMinimize: onMinimize,
          onSelectIndex: onChangeSelectedIndex,
          level: log.level,
          onCopy: onCopy
        })
      }), /*#__PURE__*/(0, _reactJsxRuntime.jsxs)("div", {
        className: styles.default.scroll,
        ref: scrollRef,
        children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)(ErrorMessageHeader, {
          collapsed: collapsed,
          onPress: () => setCollapsed(!collapsed),
          message: log.message,
          level: log.level,
          title: headerTitle
        }), meta && /*#__PURE__*/(0, _reactJsxRuntime.jsxs)("div", {
          style: {
            padding: '0 1rem',
            gap: 10,
            display: 'flex',
            flexDirection: 'column'
          },
          children: [codeFrames.map(([key, codeFrame]) => /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_overlayErrorCodeFrame.ErrorCodeFrame, {
            projectRoot: projectRoot,
            codeFrame: codeFrame
          }, key)), log.isMissingModuleError && /*#__PURE__*/(0, _reactJsxRuntime.jsx)(InstallMissingModule, {
            moduleName: log.isMissingModuleError,
            projectRoot: projectRoot ?? ''
          }), !!log?.componentStack?.length && /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_overlayStackTraceList.StackTraceList, {
            type: "component",
            projectRoot: projectRoot ?? '',
            stack: log.getAvailableStack('component'),
            symbolicationStatus: log.getStackStatus('component')
            // eslint-disable-next-line react/jsx-no-bind
            ,
            onRetry: _handleRetry.bind(_handleRetry, 'component')
          }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_overlayStackTraceList.StackTraceList, {
            type: "stack",
            projectRoot: projectRoot ?? '',
            stack: log.getAvailableStack('stack'),
            symbolicationStatus: log.getStackStatus('stack')
            // eslint-disable-next-line react/jsx-no-bind
            ,
            onRetry: _handleRetry.bind(_handleRetry, 'stack')
          })]
        }), !isDismissable && /*#__PURE__*/(0, _reactJsxRuntime.jsx)(ErrorOverlayFooter, {
          message: "Build-time errors can only be dismissed by fixing the issue."
        })]
      })]
    });
  }
  function InstallMissingModule({
    moduleName,
    projectRoot
  }) {
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_overlayErrorCodeFrame.Terminal, {
      moduleName: moduleName,
      content: `$ npx expo install ${moduleName}`
    });
  }
  function uniqueBy(array, key) {
    const seen = new Set();
    return array.filter(item => {
      const k = key(item);
      if (seen.has(k)) {
        return false;
      }
      seen.add(k);
      return true;
    });
  }
  function ErrorOverlayFooter({
    message
  }) {
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)("div", {
      className: styles.default.footer,
      children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)("footer", {
        style: {
          padding: '1rem',
          flex: 1,
          backgroundColor: 'var(--expo-log-secondary-system-background)',
          borderTop: `1px solid var(--expo-log-color-border)`
        },
        children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)("span", {
          style: {
            color: 'var(--expo-log-secondary-label)',
            fontSize: '0.875rem',
            fontFamily: 'var(--expo-log-font-family)'
          },
          children: message
        })
      })
    });
  }
  const SHOW_MORE_MESSAGE_LENGTH = 300;
  function ErrorMessageHeader(props) {
    return /*#__PURE__*/(0, _reactJsxRuntime.jsxs)("div", {
      style: {
        padding: '0 1rem',
        display: 'flex',
        gap: 8,
        flexDirection: 'column'
      },
      children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)("div", {
        style: {
          display: 'flex'
        },
        children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)("span", {
          "data-testid": "logbox_title",
          style: {
            fontFamily: 'var(--expo-log-font-family)',
            padding: 8,
            marginLeft: -4,
            backgroundColor: 'rgba(205, 97, 94, 0.2)',
            borderRadius: 8,
            fontWeight: '600',
            fontSize: 14,
            color: `var(--expo-log-color-danger)`
          },
          children: props.title
        })
      }), /*#__PURE__*/(0, _reactJsxRuntime.jsxs)("span", {
        style: {
          color: 'var(--expo-log-color-label)',
          fontFamily: 'var(--expo-log-font-family)',
          fontSize: 16,
          whiteSpace: 'pre-wrap',
          fontWeight: '500'
        },
        children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)(_LogBoxMessage.LogBoxMessage, {
          maxLength: props.collapsed ? SHOW_MORE_MESSAGE_LENGTH : Infinity,
          message: props.message
        }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)(ShowMoreButton, Object.assign({}, props))]
      })]
    });
  }
  function ShowMoreButton({
    message,
    collapsed,
    onPress
  }) {
    if (message.content.length < SHOW_MORE_MESSAGE_LENGTH || !collapsed) {
      return null;
    }
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)("button", {
      style: {
        color: 'var(--expo-log-color-label)',
        fontFamily: 'var(--expo-log-font-family)',
        backgroundColor: 'transparent',
        cursor: 'pointer',
        border: 'none',
        opacity: 0.7,
        fontSize: 14
      },
      onClick: onPress,
      children: "... See more"
    });
  }
  let currentRoot = null;
  function presentGlobalErrorOverlay() {
    if (currentRoot) {
      return;
    }
    const ErrorOverlay = LogBoxData.withSubscription(LogBoxInspectorContainer);

    // Create a new div with ID `error-overlay` element and render LogBoxInspector into it.
    const div = document.createElement('div');
    div.id = 'error-overlay';
    document.body.appendChild(div);
    currentRoot = ReactDOM.default.createRoot(div);
    currentRoot.render(/*#__PURE__*/React.default.createElement(ErrorOverlay));
  }
  function dismissGlobalErrorOverlay() {
    // Remove div with ID `error-overlay`
    if (currentRoot) {
      currentRoot.unmount();
      currentRoot = null;
    }
    const div = document.getElementById('error-overlay');
    div?.remove();
  }
},315,[35,316,322,325,329,331,31,317,336,337,338,323]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = {};
    if (e) Object.keys(e).forEach(function (k) {
      var d = Object.getOwnPropertyDescriptor(e, k);
      Object.defineProperty(n, k, d.get ? d : {
        enumerable: true,
        get: function () {
          return e[k];
        }
      });
    });
    n.default = e;
    return n;
  }
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.reportUnexpectedLogBoxError = reportUnexpectedLogBoxError;
  exports.isLogBoxErrorMessage = isLogBoxErrorMessage;
  exports.isMessageIgnored = isMessageIgnored;
  exports._appendNewLog = _appendNewLog;
  exports.addLog = addLog;
  exports.addException = addException;
  exports.symbolicateLogNow = symbolicateLogNow;
  exports.retrySymbolicateLogNow = retrySymbolicateLogNow;
  exports.symbolicateLogLazy = symbolicateLogLazy;
  exports.clear = clear;
  exports.setSelectedLog = setSelectedLog;
  exports.clearErrors = clearErrors;
  exports.dismiss = dismiss;
  exports.getIgnorePatterns = getIgnorePatterns;
  exports.addIgnorePatterns = addIgnorePatterns;
  exports.setDisabled = setDisabled;
  exports.isDisabled = isDisabled;
  exports.observe = observe;
  exports.withSubscription = withSubscription;
  var _react = require(_dependencyMap[0]);
  var React = _interopNamespace(_react);
  var _reactNativeWebDistExportsNativeEventEmitter = require(_dependencyMap[1]);
  var NativeEventEmitter = _interopDefault(_reactNativeWebDistExportsNativeEventEmitter);
  var _devServerEndpoints = require(_dependencyMap[2]);
  var _parseUnexpectedThrownValue = require(_dependencyMap[3]);
  var _LogBoxLog = require(_dependencyMap[4]);
  var _parseLogBoxLog = require(_dependencyMap[5]);
  var _reactJsxRuntime = require(_dependencyMap[6]);
  const observers = new Set();
  const ignorePatterns = new Set();
  let logs = new Set();
  let updateTimeout = null;
  let _isDisabled = false;
  let _selectedIndex = -1;
  const LOGBOX_ERROR_MESSAGE = 'An error was thrown while presenting an error!';
  function getNextState() {
    return {
      logs,
      isDisabled: _isDisabled,
      selectedLogIndex: _selectedIndex
    };
  }
  function reportUnexpectedLogBoxError(error) {
    if ((0, _parseLogBoxLog.isError)(error)) {
      error.message = `${LOGBOX_ERROR_MESSAGE}\n\n${error.message}`;
    }
    addException(error);
  }
  function isLogBoxErrorMessage(message) {
    return typeof message === 'string' && message.includes(LOGBOX_ERROR_MESSAGE);
  }
  function isMessageIgnored(message) {
    for (const pattern of ignorePatterns) {
      if (pattern instanceof RegExp && pattern.test(message) || typeof pattern === 'string' && message.includes(pattern)) {
        return true;
      }
    }
    return false;
  }
  function handleUpdate() {
    if (updateTimeout == null) {
      updateTimeout = setTimeout(() => {
        updateTimeout = null;
        const nextState = getNextState();
        observers.forEach(({
          observer
        }) => observer(nextState));
      }, 0);
    }
  }

  /** Exposed for debugging */
  function _appendNewLog(newLog) {
    // Don't want store these logs because they trigger a
    // state update when we add them to the store.
    if (isMessageIgnored(newLog.message.content)) {
      return;
    }

    // If the next log has the same category as the previous one
    // then roll it up into the last log in the list by incrementing
    // the count (similar to how Chrome does it).
    const lastLog = Array.from(logs).pop();
    if (lastLog && lastLog.category === newLog.category) {
      if (lastLog.level === newLog.level) {
        lastLog.incrementCount();
        handleUpdate();
        return;
      } else {
        // Determine which one is more important. This is because console.error for React errors shows before the more important root componentDidCatch which should force the UI to show.
        if (newLog.level === 'fatal') {
          // If the new log is fatal, then we want to show it
          // and hide the last one.
          newLog.count = lastLog.count;
          logs.delete(lastLog);
        }
      }
    }
    if (newLog.level === 'fatal') {
      // If possible, to avoid jank, we don't want to open the error before
      // it's symbolicated. To do that, we optimistically wait for
      // symbolication for up to a second before adding the log.
      const OPTIMISTIC_WAIT_TIME = 1000;
      let addPendingLog = () => {
        logs.add(newLog);
        if (_selectedIndex < 0) {
          setSelectedLog(logs.size - 1);
        } else {
          handleUpdate();
        }
        addPendingLog = null;
      };
      const optimisticTimeout = setTimeout(() => {
        if (addPendingLog) {
          addPendingLog();
        }
      }, OPTIMISTIC_WAIT_TIME);

      // TODO: HANDLE THIS
      newLog.symbolicate('component');
      newLog.symbolicate('stack', status => {
        if (addPendingLog && status !== 'PENDING') {
          addPendingLog();
          clearTimeout(optimisticTimeout);
        } else if (status !== 'PENDING') {
          // The log has already been added but we need to trigger a render.
          handleUpdate();
        }
      });
    } else if (newLog.level === 'syntax' || newLog.level === 'resolution') {
      logs.add(newLog);
      setSelectedLog(logs.size - 1);
    } else {
      logs.add(newLog);
      handleUpdate();
    }
  }
  function addLog(log) {
    const errorForStackTrace = new Error();

    // Parsing logs are expensive so we schedule this
    // otherwise spammy logs would pause rendering.
    setTimeout(() => {
      try {
        const stack = (0, _devServerEndpoints.parseErrorStack)(errorForStackTrace?.stack);
        _appendNewLog(new _LogBoxLog.LogBoxLog({
          level: log.level,
          message: log.message,
          isComponentError: !!log.componentStack?.length,
          stack,
          category: log.category,
          componentStack: log.componentStack,
          codeFrame: {}
        }));
      } catch (unexpectedError) {
        reportUnexpectedLogBoxError(unexpectedError);
      }
    }, 0);
  }
  function addException(error) {
    let logBoxData;

    // NOTE(Bacon): Support newer system for formatting errors as logbox data with more data and less parsing.
    if ('toLogBoxLogData' in error && typeof error.toLogBoxLogData === 'function') {
      const logBoxLogData = error.toLogBoxLogData();
      if (logBoxLogData) {
        logBoxData = logBoxLogData;
      }
    }

    // Fallback to the old system for formatting errors as logbox data.
    // This is used for unexpected behavior and should be reduced as much as possible.
    logBoxData ??= (0, _parseLogBoxLog.parseLogBoxException)((0, _parseUnexpectedThrownValue.parseUnexpectedThrownValue)(error));

    // Parsing logs are expensive so we schedule this
    // otherwise spammy logs would pause rendering.
    setTimeout(() => {
      try {
        _appendNewLog(new _LogBoxLog.LogBoxLog(logBoxData));
      } catch (unexpectedError) {
        reportUnexpectedLogBoxError(unexpectedError);
      }
    }, 0);
  }
  function symbolicateLogNow(type, log) {
    log.symbolicate(type, () => {
      handleUpdate();
    });
  }
  function retrySymbolicateLogNow(type, log) {
    log.retrySymbolicate(type, () => {
      handleUpdate();
    });
  }
  function symbolicateLogLazy(type, log) {
    log.symbolicate(type);
  }
  function clear() {
    if (logs.size > 0) {
      logs = new Set();
      setSelectedLog(-1);
    }
  }
  function setSelectedLog(proposedNewIndex) {
    const oldIndex = _selectedIndex;
    let newIndex = proposedNewIndex;
    const logArray = Array.from(logs);
    let index = logArray.length - 1;
    while (index >= 0) {
      // The latest syntax error is selected and displayed before all other logs.
      if (logArray[index].level === 'syntax' || logArray[index].level === 'resolution') {
        newIndex = index;
        break;
      }
      index -= 1;
    }
    _selectedIndex = newIndex;
    handleUpdate();
    setTimeout(() => {
      if (oldIndex < 0 && newIndex >= 0) {
        require(_dependencyMap[7]).presentGlobalErrorOverlay();
      } else if (oldIndex >= 0 && newIndex < 0) {
        require(_dependencyMap[7]).dismissGlobalErrorOverlay();
      }
    }, 0);
  }
  function clearErrors() {
    const newLogs = Array.from(logs).filter(log => log.level !== 'error' && log.level !== 'fatal');
    if (newLogs.length !== logs.size) {
      logs = new Set(newLogs);
      setSelectedLog(-1);
    }
  }
  function dismiss(log) {
    if (logs.has(log)) {
      logs.delete(log);
      handleUpdate();
    } else {
      // Find log with matching message
      const message = log.message.content;
      const logToDismiss = Array.from(logs).find(l => l.message.content === message);
      if (logToDismiss) {
        logs.delete(logToDismiss);
        handleUpdate();
      } else {
        console.warn('LogBoxLog not found in logs:', log, logs);
      }
    }
  }
  function getIgnorePatterns() {
    return Array.from(ignorePatterns);
  }
  function addIgnorePatterns(patterns) {
    const existingSize = ignorePatterns.size;
    // The same pattern may be added multiple times, but adding a new pattern
    // can be expensive so let's find only the ones that are new.
    patterns.forEach(pattern => {
      if (pattern instanceof RegExp) {
        for (const existingPattern of ignorePatterns) {
          if (existingPattern instanceof RegExp && existingPattern.toString() === pattern.toString()) {
            return;
          }
        }
        ignorePatterns.add(pattern);
      }
      ignorePatterns.add(pattern);
    });
    if (ignorePatterns.size === existingSize) {
      return;
    }
    // We need to recheck all of the existing logs.
    // This allows adding an ignore pattern anywhere in the codebase.
    // Without this, if you ignore a pattern after the a log is created,
    // then we would keep showing the log.
    logs = new Set(Array.from(logs).filter(log => !isMessageIgnored(log.message.content)));
    handleUpdate();
  }
  function setDisabled(value) {
    if (value === _isDisabled) {
      return;
    }
    _isDisabled = value;
    handleUpdate();
  }
  function isDisabled() {
    return _isDisabled;
  }
  function observe(observer) {
    const subscription = {
      observer
    };
    observers.add(subscription);
    observer(getNextState());
    return {
      unsubscribe() {
        observers.delete(subscription);
      }
    };
  }
  const emitter = new NativeEventEmitter.default({
    addListener() {},
    removeListeners() {}
  });
  function withSubscription(WrappedComponent) {
    class RootDevErrorBoundary extends React.Component {
      static getDerivedStateFromError() {
        return {
          hasError: true
        };
      }
      constructor(props) {
        super(props);
      }
      componentDidCatch(err, errorInfo) {
        // TODO: Won't this catch all React errors and make them appear as unexpected rendering errors?
        err.componentStack ??= errorInfo.componentStack;

        // TODO: Make the error appear more like the React console.error, appending the "The above error occurred" line.

        const {
          category,
          message,
          componentStack
        } = (0, _parseLogBoxLog.parseLogBoxLog)([err]);
        if (!isMessageIgnored(message.content)) {
          addLog({
            // Always show the static rendering issues as full screen since they
            // are too confusing otherwise.
            level: 'fatal',
            category,
            message,
            componentStack
          });
        }
      }
      state = {
        logs: new Set(),
        isDisabled: false,
        hasError: false,
        selectedLogIndex: -1
      };
      retry = () => {
        return new Promise(resolve => {
          this.setState({
            hasError: false
          }, () => {
            resolve();
          });
        });
      };
      render() {
        return /*#__PURE__*/(0, _reactJsxRuntime.jsxs)(_LogBoxLog.LogContext.Provider, {
          value: {
            selectedLogIndex: this.state.selectedLogIndex,
            isDisabled: this.state.isDisabled,
            logs: Array.from(this.state.logs)
          },
          children: [this.props.children, /*#__PURE__*/(0, _reactJsxRuntime.jsx)(WrappedComponent, {})]
        });
      }
      componentDidMount() {
        this._subscription = observe(data => {
          // Ignore the initial empty log
          // if (data.selectedLogIndex === -1) return;
          React.startTransition(() => {
            this.setState(data);
          });
        });
      }
      componentWillUnmount() {
        if (this._subscription != null) {
          this._subscription.unsubscribe();
        }
      }
    }
    return RootDevErrorBoundary;
  }
},316,[35,246,317,319,322,321,323,315]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.installPackageInProject = installPackageInProject;
  exports.openFileInEditor = openFileInEditor;
  exports.fetchProjectMetadataAsync = fetchProjectMetadataAsync;
  exports.formatProjectFilePath = formatProjectFilePath;
  exports.getFormattedStackTrace = getFormattedStackTrace;
  exports.isStackFileAnonymous = isStackFileAnonymous;
  exports.getStackFormattedLocation = getStackFormattedLocation;
  exports.parseErrorStack = parseErrorStack;
  exports.invalidateCachedStack = invalidateCachedStack;
  exports.symbolicateStackAndCacheAsync = symbolicateStackAndCacheAsync;
  var _stacktraceParser = require(_dependencyMap[0]);
  const cache = new Map();
  function getBaseUrl() {
    if (typeof window === 'undefined') {
      return process.env.EXPO_DEV_SERVER_ORIGIN;
    }
    return window.location.protocol + '//' + window.location.host;
  }
  function installPackageInProject(pkg) {
    const url = new URL('/_expo/install-pkg', getBaseUrl()).href;

    // @ts-ignore
    if (globalThis.__polyfill_dom_fetch) {
      // @ts-ignore
      globalThis.__polyfill_dom_fetch(url, {
        method: 'POST',
        body: JSON.stringify({
          pkg
        })
      });
      return;
    }
    fetch(url, {
      method: 'POST',
      body: JSON.stringify({
        pkg
      })
    });
  }
  function openFileInEditor(file, lineNumber) {
    const url = new URL('/open-stack-frame', getBaseUrl()).href;

    // @ts-ignore
    if (globalThis.__polyfill_dom_fetch) {
      // @ts-ignore
      globalThis.__polyfill_dom_fetch(url, {
        method: 'POST',
        body: JSON.stringify({
          file,
          lineNumber
        })
      });
      return;
    }
    fetch(url, {
      method: 'POST',
      body: JSON.stringify({
        file,
        lineNumber
      })
    });
  }
  async function fetchProjectMetadataAsync() {
    const url = new URL('/_expo/error-overlay-meta', getBaseUrl()).href;

    // @ts-ignore
    if (globalThis.__polyfill_dom_fetchJsonAsync) {
      // @ts-ignore
      return await globalThis.__polyfill_dom_fetchJsonAsync(url, {
        method: 'GET'
      });
    }
    const response = await fetch(url, {
      method: 'GET'
    });
    return await response.json();
  }
  async function symbolicateStackTrace(stack) {
    const url = new URL('/symbolicate', getBaseUrl()).href;

    // @ts-ignore
    if (globalThis.__polyfill_dom_fetchJsonAsync) {
      // @ts-ignore
      return await globalThis.__polyfill_dom_fetchJsonAsync(url, {
        method: 'POST',
        body: JSON.stringify({
          stack
        })
      });
    }
    const response = await fetch(url, {
      method: 'POST',
      body: JSON.stringify({
        stack
      })
    });
    return await response.json();
  }
  function formatProjectFilePath(projectRoot, file) {
    if (file == null) {
      return '<unknown>';
    }
    return pathRelativeToPath(file.replace(/\\/g, '/'), projectRoot.replace(/\\/g, '/')).replace(/\?.*$/, '');
  }
  function getFormattedStackTrace(projectRoot, stack) {
    return stack.map(frame => {
      let stack = `  at `;
      const location = getStackFormattedLocation(projectRoot, frame);
      stack += `${frame.methodName ?? '<unknown>'} (${location})`;
      return stack;
    }).join('\n');
  }
  function pathRelativeToPath(path, relativeTo, sep = '/') {
    const relativeToParts = relativeTo.split(sep);
    const pathParts = path.split(sep);
    let i = 0;
    while (i < relativeToParts.length && i < pathParts.length) {
      if (relativeToParts[i] !== pathParts[i]) {
        break;
      }
      i++;
    }
    return pathParts.slice(i).join(sep);
  }
  function isStackFileAnonymous(frame) {
    return !frame.file || frame.file === '<unknown>' || frame.file === '<anonymous>';
  }
  function getStackFormattedLocation(projectRoot, frame) {
    const column = frame.column != null && parseInt(String(frame.column), 10);
    let location = formatProjectFilePath(projectRoot, frame.file);
    if (frame.lineNumber != null && frame.lineNumber >= 0) {
      location += ':' + frame.lineNumber;
      if (column && !isNaN(column) && column >= 0) {
        location += ':' + (column + 1);
      }
    }
    return location;
  }
  function parseErrorStack(stack) {
    if (stack == null) {
      return [];
    }
    if (Array.isArray(stack)) {
      return stack;
    }
    return (0, _stacktraceParser.parse)(stack).map(frame => {
      // frame.file will mostly look like `http://localhost:8081/index.bundle?platform=web&dev=true&hot=false`
      return Object.assign({}, frame, {
        column: frame.column != null ? frame.column - 1 : null
      });
    });
  }

  /**
   * Sanitize because sometimes, `symbolicateStackTrace` gives us invalid values.
   */
  function normalizeMetroSymbolicatedStackResults({
    stack: maybeStack,
    codeFrame
  }) {
    if (!Array.isArray(maybeStack)) {
      throw new Error('Expected stack to be an array.');
    }
    const stack = maybeStack.map(maybeFrame => {
      let collapse = false;
      if ('collapse' in maybeFrame) {
        if (typeof maybeFrame.collapse !== 'boolean') {
          throw new Error('Expected stack frame `collapse` to be a boolean.');
        }
        collapse = maybeFrame.collapse;
      }
      return {
        arguments: [],
        column: maybeFrame.column,
        file: maybeFrame.file,
        lineNumber: maybeFrame.lineNumber,
        methodName: maybeFrame.methodName,
        collapse
      };
    });
    return {
      stack,
      codeFrame
    };
  }
  function invalidateCachedStack(stack) {
    cache.delete(stack);
  }
  function symbolicateStackAndCacheAsync(stack) {
    let promise = cache.get(stack);
    if (promise == null) {
      promise = symbolicateStackTrace(ensureStackFilesHaveParams(stack)).then(normalizeMetroSymbolicatedStackResults);
      cache.set(stack, promise);
    }
    return promise;
  }

  // Sometime the web stacks don't have correct query params, this can lead to Metro errors when it attempts to resolve without a platform.
  // This will attempt to reconcile the issue by adding the current query params to the stack frames if they exist, or fallback to some common defaults.
  function ensureStackFilesHaveParams(stack) {
    const currentSrc = typeof document !== 'undefined' && document.currentScript ? 'src' in document.currentScript && document.currentScript.src || null : null;
    const currentParams = currentSrc ? new URLSearchParams(currentSrc) : new URLSearchParams({
      // @ts-ignore
      platform: globalThis.__polyfill_platform ?? "web",
      dev: String(false)
    });
    return stack.map(frame => {
      if (!frame.file?.startsWith('http') ||
      // Account for Metro malformed URLs
      frame.file.includes('&platform=')) return frame;
      const url = new URL(frame.file);
      if (url.searchParams.has('platform')) {
        return frame;
      }
      currentParams.forEach((value, key) => {
        if (url.searchParams.has(key)) return;
        url.searchParams.set(key, value);
      });
      return Object.assign({}, frame, {
        file: url.toString()
      });
    });
  }
},317,[318]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function () {
      return parse;
    }
  });
  var UNKNOWN_FUNCTION = '<unknown>';
  /**
   * This parses the different stack traces and puts them into one format
   * This borrows heavily from TraceKit (https://github.com/csnover/TraceKit)
   */

  function parse(stackString) {
    var lines = stackString.split('\n');
    return lines.reduce(function (stack, line) {
      var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);
      if (parseResult) {
        stack.push(parseResult);
      }
      return stack;
    }, []);
  }
  var chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  var chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  function parseChrome(line) {
    var parts = chromeRe.exec(line);
    if (!parts) {
      return null;
    }
    var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line

    var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line

    var submatch = chromeEvalRe.exec(parts[2]);
    if (isEval && submatch != null) {
      // throw out eval line/column and use top-most line/column number
      parts[2] = submatch[1]; // url

      parts[3] = submatch[2]; // line

      parts[4] = submatch[3]; // column
    }
    return {
      file: !isNative ? parts[2] : null,
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: isNative ? [parts[2]] : [],
      lineNumber: parts[3] ? +parts[3] : null,
      column: parts[4] ? +parts[4] : null
    };
  }
  var winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  function parseWinjs(line) {
    var parts = winjsRe.exec(line);
    if (!parts) {
      return null;
    }
    return {
      file: parts[2],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: [],
      lineNumber: +parts[3],
      column: parts[4] ? +parts[4] : null
    };
  }
  var geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
  var geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
  function parseGecko(line) {
    var parts = geckoRe.exec(line);
    if (!parts) {
      return null;
    }
    var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
    var submatch = geckoEvalRe.exec(parts[3]);
    if (isEval && submatch != null) {
      // throw out eval line/column and use top-most line number
      parts[3] = submatch[1];
      parts[4] = submatch[2];
      parts[5] = null; // no column when eval
    }
    return {
      file: parts[3],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: parts[2] ? parts[2].split(',') : [],
      lineNumber: parts[4] ? +parts[4] : null,
      column: parts[5] ? +parts[5] : null
    };
  }
  var javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
  function parseJSC(line) {
    var parts = javaScriptCoreRe.exec(line);
    if (!parts) {
      return null;
    }
    return {
      file: parts[3],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: [],
      lineNumber: +parts[4],
      column: parts[5] ? +parts[5] : null
    };
  }
  var nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  function parseNode(line) {
    var parts = nodeRe.exec(line);
    if (!parts) {
      return null;
    }
    return {
      file: parts[2],
      methodName: parts[1] || UNKNOWN_FUNCTION,
      arguments: [],
      lineNumber: +parts[3],
      column: parts[4] ? +parts[4] : null
    };
  }
},318,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.parseUnexpectedThrownValue = parseUnexpectedThrownValue;
  var _devServerEndpoints = require(_dependencyMap[0]);
  var _metroBuildErrors = require(_dependencyMap[1]);
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  /**
   * Handles the developer-visible aspect of errors and exceptions
   */
  let exceptionID = 0;

  /**
   * Logs exceptions to the (native) console and displays them
   */
  function parseUnexpectedThrownValue(error) {
    let e = error;
    if (error instanceof Error) {
      e = error;
    } else {
      // Workaround for reporting errors caused by `throw 'some string'`
      // Unfortunately there is no way to figure out the stacktrace in this
      // case, so if you ended up here trying to trace an error, look for
      // `throw '<error message>'` somewhere in your codebase.
      e = new Error(error);
    }
    const stack = (0, _devServerEndpoints.parseErrorStack)(e?.stack);
    const currentExceptionID = ++exceptionID;
    // Re-apply the ansi error formatting to the message for CLI/Bundler errors such as missing imports.
    // This ensures the console.error has ansi stripped.
    const originalMessage = e instanceof _metroBuildErrors.MetroBuildError ? e.ansiError : e.message || '';
    let message = originalMessage;
    if (e.componentStack != null) {
      message += `\n\nThis error is located at:${e.componentStack}`;
    }
    const namePrefix = e.name == null || e.name === '' ? '' : `${e.name}: `;
    if (!message.startsWith(namePrefix)) {
      message = namePrefix + message;
    }
    const data = {
      message,
      originalMessage: message === originalMessage ? null : originalMessage,
      name: e.name == null || e.name === '' ? null : e.name,
      componentStack: typeof e.componentStack === 'string' ? e.componentStack : null,
      stack,
      id: currentExceptionID,
      isFatal: true,
      extraData: {
        jsEngine: e.jsEngine,
        rawStack: e.stack
      }
    };
    return Object.assign({}, data, {
      isComponentError: !!e.isComponentError
    });
  }
},319,[317,320]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  Object.defineProperty(exports, "MetroBuildError", {
    enumerable: true,
    get: function () {
      return MetroBuildError;
    }
  });
  Object.defineProperty(exports, "MetroTransformError", {
    enumerable: true,
    get: function () {
      return MetroTransformError;
    }
  });
  Object.defineProperty(exports, "MetroPackageResolutionError", {
    enumerable: true,
    get: function () {
      return MetroPackageResolutionError;
    }
  });
  exports.stripAnsi = stripAnsi;
  var _DataParseLogBoxLog = require(_dependencyMap[0]);
  var _devServerEndpoints = require(_dependencyMap[1]);
  const METRO_ERROR_FORMAT = /^(?:InternalError Metro has encountered an error:) (.*): (.*) \((\d+):(\d+)\)\n\n([\s\S]+)/u;
  class MetroBuildError extends Error {
    constructor(message, errorType, errors) {
      super(message);
      this.errorType = errorType;
      this.errors = errors;
      this.ansiError = message;
      // Strip the ansi so it shows as a normalized error in the console log.
      this.message = stripAnsi(message);
    }
    toLogBoxLogData() {
      // TODO: Split into different error
      const metroInternalError = this.ansiError.match(METRO_ERROR_FORMAT);
      if (metroInternalError) {
        const [content, fileName, row, column, codeFrame] = metroInternalError.slice(1);
        return {
          level: 'fatal',
          type: 'Metro Error',
          stack: [],
          isComponentError: false,
          componentStack: [],
          codeFrame: {
            stack: {
              fileName,
              location: {
                row: parseInt(row, 10),
                column: parseInt(column, 10)
              },
              content: codeFrame
            }
          },
          message: {
            content,
            substitutions: []
          },
          category: `${fileName}-${row}-${column}`
        };
      }
      const babelCodeFrameError = this.ansiError.match(BABEL_CODE_FRAME_ERROR_FORMAT);
      if (babelCodeFrameError) {
        // Codeframe errors are thrown from any use of buildCodeFrameError.
        const [fileName, content, codeFrame] = babelCodeFrameError.slice(1);
        return {
          level: 'syntax',
          stack: [],
          isComponentError: false,
          componentStack: [],
          codeFrame: {
            stack: {
              fileName,
              location: null,
              // We are not given the location.
              content: codeFrame
            }
          },
          message: {
            content,
            substitutions: []
          },
          category: `${fileName}-${1}-${1}`
        };
      }
      return Object.assign({
        level: 'fatal',
        stack: (0, _devServerEndpoints.parseErrorStack)(this.stack),
        codeFrame: {},
        isComponentError: false,
        componentStack: []
      }, (0, _DataParseLogBoxLog.parseInterpolation)([this.ansiError]));
    }
  }
  const BABEL_TRANSFORM_ERROR_FORMAT = /^(?:TransformError )?(?:SyntaxError: |ReferenceError: )(.*): (.*) \((\d+):(\d+)\)\n\n([\s\S]+)/;
  const BABEL_CODE_FRAME_ERROR_FORMAT = /^(?:TransformError )?(?:.*):? (?:.*?)([/|\\].*): ([\s\S]+?)\n([ >]{2}[\d\s]+ \|[\s\S]+|\u{001b}[\s\S]+)/u;
  class MetroTransformError extends MetroBuildError {
    constructor(message, errorType, errors, lineNumber, column, filename) {
      super(message);

      // TODO: Remove need for regex by passing code frame in error data from Metro.
      this.errorType = errorType;
      this.errors = errors;
      this.lineNumber = lineNumber;
      this.column = column;
      this.filename = filename;
      const babelTransformError = message.match(BABEL_TRANSFORM_ERROR_FORMAT);
      if (babelTransformError) {
        // Transform errors are thrown from inside the Babel transformer.
        const [content, codeFrame] = babelTransformError.slice(1);
        this.codeFrame = codeFrame;
        this.message = stripAnsi(content);
      }
    }
    toLogBoxLogData() {
      // MetroTransformError is a custom error type that we throw when the transformer fails.
      // It has a stack trace and a message.
      return {
        level: 'syntax',
        stack: [],
        isComponentError: false,
        componentStack: [],
        codeFrame: {
          stack: this.codeFrame ? {
            fileName: this.filename,
            location: {
              row: this.lineNumber,
              column: this.column
            },
            content: this.codeFrame
          } : undefined
        },
        message: {
          content: this.message,
          substitutions: []
        },
        category: `${this.filename}-${this.lineNumber}-${this.column}`
      };
    }
  }
  class MetroPackageResolutionError extends MetroBuildError {
    constructor(message, errorType, errors, /** "/Users/evanbacon/Documents/GitHub/expo/apps/router-e2e/__e2e__/05-errors/app/index.tsx" */
    originModulePath, /** "foobar" */

    targetModuleName, cause) {
      super(message);
      this.errorType = errorType;
      this.errors = errors;
      this.originModulePath = originModulePath;
      this.targetModuleName = targetModuleName;
      this.cause = cause;
    }
    toLogBoxLogData() {
      const babelCodeFrameError = this.ansiError.match(BABEL_CODE_FRAME_ERROR_FORMAT);
      return {
        level: 'resolution',
        // TODO: Add import stacks
        stack: [],
        isComponentError: false,
        componentStack: [],
        codeFrame: {
          stack: babelCodeFrameError?.[3] ? {
            fileName: this.originModulePath,
            location: null,
            // We are not given the location.
            content: babelCodeFrameError?.[3]
          } : undefined
        },
        message: {
          content: `Unable to resolve module ${this.targetModuleName}`,
          substitutions: []
        },
        // @ts-ignore
        isMissingModuleError: this.cause?.dirPaths ? this.targetModuleName : undefined,
        category: `${this.originModulePath}-${1}-${1}`
      };
    }
  }
  function stripAnsi(str) {
    if (!str) {
      return str;
    }
    const pattern = ['[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)', '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|');
    return str.replace(new RegExp(pattern, 'g'), '');
  }
},320,[321,317]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.parseInterpolation = parseInterpolation;
  exports.parseLogBoxException = parseLogBoxException;
  exports.isError = isError;
  exports.parseLogBoxLog = parseLogBoxLog;
  var _react = require(_dependencyMap[0]);
  var React = _interopDefault(_react);
  var _devServerEndpoints = require(_dependencyMap[1]);
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  const BABEL_TRANSFORM_ERROR_FORMAT = /^(?:TransformError )?(?:SyntaxError: |ReferenceError: )(.*): (.*) \((\d+):(\d+)\)\n\n([\s\S]+)/;
  const BABEL_CODE_FRAME_ERROR_FORMAT = /^(?:TransformError )?(?:.*):? (?:.*?)([/|\\].*): ([\s\S]+?)\n([ >]{2}[\d\s]+ \|[\s\S]+|\u{001b}[\s\S]+)/u;
  const METRO_ERROR_FORMAT = /^(?:InternalError Metro has encountered an error:) (.*): (.*) \((\d+):(\d+)\)\n\n([\s\S]+)/u;
  const SUBSTITUTION = '\ufeff%s';

  // TODO: Get rid of this. The substitution logic is wild.
  function parseInterpolation(args) {
    const categoryParts = [];
    const contentParts = [];
    const substitutionOffsets = [];
    const remaining = [...args];
    if (typeof remaining[0] === 'string') {
      const formatString = String(remaining.shift());
      const formatStringParts = formatString.split('%s');
      const substitutionCount = formatStringParts.length - 1;
      const substitutions = remaining.splice(0, substitutionCount);
      let categoryString = '';
      let contentString = '';
      let substitutionIndex = 0;
      for (const formatStringPart of formatStringParts) {
        categoryString += formatStringPart;
        contentString += formatStringPart;
        if (substitutionIndex < substitutionCount) {
          if (substitutionIndex < substitutions.length) {
            // Don't stringify a string type.
            // It adds quotation mark wrappers around the string,
            // which causes the LogBox to look odd.
            const substitution = typeof substitutions[substitutionIndex] === 'string' ? substitutions[substitutionIndex] : stringifySafe(substitutions[substitutionIndex]);
            substitutionOffsets.push({
              length: substitution.length,
              offset: contentString.length
            });
            categoryString += SUBSTITUTION;
            contentString += substitution;
          } else {
            substitutionOffsets.push({
              length: 2,
              offset: contentString.length
            });
            categoryString += '%s';
            contentString += '%s';
          }
          substitutionIndex++;
        }
      }
      categoryParts.push(categoryString);
      contentParts.push(contentString);
    }
    const remainingArgs = remaining.map(arg => {
      // Don't stringify a string type.
      // It adds quotation mark wrappers around the string,
      // which causes the LogBox to look odd.
      return typeof arg === 'string' ? arg : stringifySafe(arg);
    });
    categoryParts.push(...remainingArgs);
    contentParts.push(...remainingArgs);
    return {
      category: categoryParts.join(' '),
      message: {
        content: contentParts.join(' '),
        substitutions: substitutionOffsets
      }
    };
  }
  function parseLogBoxException(error) {
    const message = error.originalMessage != null ? error.originalMessage : 'Unknown';
    const metroInternalError = message.match(METRO_ERROR_FORMAT);
    if (metroInternalError) {
      debugger;
      const [content, fileName, row, column, codeFrame] = metroInternalError.slice(1);
      return {
        level: 'fatal',
        type: 'Metro Error',
        stack: [],
        isComponentError: false,
        componentStack: [],
        codeFrame: {
          stack: {
            fileName,
            location: {
              row: parseInt(row, 10),
              column: parseInt(column, 10)
            },
            content: codeFrame
          }
        },
        message: {
          content,
          substitutions: []
        },
        category: `${fileName}-${row}-${column}`
      };
    }
    const babelTransformError = message.match(BABEL_TRANSFORM_ERROR_FORMAT);
    if (babelTransformError) {
      debugger;
      // Transform errors are thrown from inside the Babel transformer.
      const [fileName, content, row, column, codeFrame] = babelTransformError.slice(1);
      return {
        level: 'syntax',
        stack: [],
        isComponentError: false,
        componentStack: [],
        codeFrame: {
          stack: {
            fileName,
            location: {
              row: parseInt(row, 10),
              column: parseInt(column, 10)
            },
            content: codeFrame
          }
        },
        message: {
          content,
          substitutions: []
        },
        category: `${fileName}-${row}-${column}`
      };
    }
    const babelCodeFrameError = message.match(BABEL_CODE_FRAME_ERROR_FORMAT);
    if (babelCodeFrameError) {
      debugger;
      // Codeframe errors are thrown from any use of buildCodeFrameError.
      const [fileName, content, codeFrame] = babelCodeFrameError.slice(1);
      return {
        level: 'syntax',
        stack: [],
        isComponentError: false,
        componentStack: [],
        codeFrame: {
          stack: {
            fileName,
            location: null,
            // We are not given the location.
            content: codeFrame
          }
        },
        message: {
          content,
          substitutions: []
        },
        category: `${fileName}-${1}-${1}`
      };
    }
    if (message.match(/^TransformError /)) {
      debugger;
      return {
        level: 'syntax',
        stack: error.stack,
        isComponentError: error.isComponentError,
        componentStack: [],
        codeFrame: {},
        message: {
          content: message,
          substitutions: []
        },
        category: message
      };
    }
    const componentStack = error.componentStack;
    if (error.isFatal || error.isComponentError) {
      return Object.assign({
        level: 'fatal',
        stack: error.stack,
        codeFrame: {},
        isComponentError: error.isComponentError,
        componentStack: componentStack != null ? (0, _devServerEndpoints.parseErrorStack)(componentStack) : []
      }, parseInterpolation([message]));
    }
    if (componentStack != null) {
      debugger;
      // It is possible that console errors have a componentStack.
      return Object.assign({
        level: 'error',
        stack: error.stack,
        codeFrame: {},
        isComponentError: error.isComponentError,
        componentStack: (0, _devServerEndpoints.parseErrorStack)(componentStack)
      }, parseInterpolation([message]));
    }

    // Most `console.error` calls won't have a componentStack. We parse them like
    // regular logs which have the component stack burried in the message.
    return Object.assign({
      level: 'error',
      stack: error.stack,
      codeFrame: {},
      isComponentError: error.isComponentError
    }, parseLogBoxLog([message]));
  }
  function interpolateLikeConsole(...args) {
    let output = '';
    if (typeof args[0] === 'string') {
      const format = args[0];
      const rest = args.slice(1);
      let argIndex = 0;

      // TODO: %c for colors
      output = format.replace(/%[sdifoO%]/g, match => {
        if (match === '%%') return '%'; // escape %%
        const arg = rest[argIndex++];
        switch (match) {
          case '%s':
            return String(arg);
          case '%d':
          case '%i':
            return parseInt(arg, 10).toString();
          case '%f':
            return parseFloat(arg).toString();
          case '%o':
          case '%O':
            return stringifySafe(arg);
          default:
            return match;
        }
      });

      // Append any remaining arguments
      for (; argIndex < rest.length; argIndex++) {
        const arg = rest[argIndex];
        output += ' ' + (typeof arg === 'object' ? arg instanceof Error ? arg.stack || arg.toString() : JSON.stringify(arg, null, 2) : String(arg));
      }
    } else {
      // No format string, just join args with spaces
      output = args.map(arg => stringifySafe(arg)).join(' ');
    }
    return output;
  }
  function isError(err) {
    return typeof err === 'object' && err !== null && 'name' in err && 'message' in err;
  }
  const REACT_STACK_BOTTOM_MARKER = 'react-stack-bottom-marker';
  const REACT_STACK_BOTTOM_MARKER_REGEX = new RegExp(`(at ${REACT_STACK_BOTTOM_MARKER} )|(${REACT_STACK_BOTTOM_MARKER}\\@)`);
  /**
   * Extracts and processes React error details from the provided input error.
   * This function ensures that the error stack is cleaned up and includes only relevant frames.
   * It also appends the owner stack if available and tags the error for identification.
   *
   * @param inputError - The error object or any other type to process.
   * @returns A new Error object with updated stack and properties, or the original input if not an error.
   */
  function processReactErrorDetails(inputError) {
    const isInputErrorInstance = isError(inputError);

    // Extract the original stack and message from the error.
    const originalStack = isInputErrorInstance ? inputError.stack || '' : '';
    const originalMessage = isInputErrorInstance ? inputError.message : '';

    // Split the stack into lines for processing.
    const stackLinesArray = originalStack.split('\n');

    // Find the index of the React stack bottom marker in the stack trace.
    const splitIndex = stackLinesArray.findIndex(line => REACT_STACK_BOTTOM_MARKER_REGEX.test(line));

    // Determine if the stack contains the React stack bottom marker.
    const hasReactStackMarker = splitIndex >= 0;

    // Update the stack to exclude frames after the React stack bottom marker.
    const updatedStack = hasReactStackMarker ? stackLinesArray.slice(0, splitIndex).join('\n') : originalStack;

    // Create a new Error object with the updated stack and message.
    const updatedError = new Error(originalMessage);

    // Copy all enumerable properties from the input error to the new error.
    Object.assign(updatedError, inputError);

    // Set the updated stack on the new error.
    updatedError.stack = updatedStack;

    // Append the owner stack if available.
    appendOwnerStack(updatedError);
    return updatedError;
  }

  /**
   * Appends the React owner stack to the provided error's stack trace.
   * This ensures that the error stack includes additional context about the React component hierarchy.
   *
   * @param error - The error object to update.
   */
  function appendOwnerStack(error) {
    // Check if React's captureOwnerStack function is available. React +19.1
    if (!React.default.captureOwnerStack) {
      return;
    }

    // Get the current stack and the owner stack.
    let stack = error.stack || '';
    const ownerStack = React.default.captureOwnerStack();

    // Avoid appending duplicate owner stack frames.
    if (ownerStack && !stack.endsWith(ownerStack)) {
      stack += ownerStack;

      // Override the stack with the updated value.
      error.stack = stack;
    }
  }
  function parseLogBoxLog(args) {
    // React will pass a full error object to the console.error function.
    // https://github.com/facebook/react/blob/c44e4a250557e53b120e40db8b01fb5fd93f1e35/packages/react-reconciler/src/ReactFiberErrorLogger.js#L105
    // But we can't be sure at which order, so we'll check all arguments.
    let error;
    for (const arg of args) {
      if (isError(arg)) {
        error = arg;
        break;
      }
    }

    // Create a string representation of the error arguments.
    const message = interpolateLikeConsole(...args);
    // If no error was passed, create a new Error object with the message.
    if (!isError(error)) {
      error = new Error(message);
    }

    // Use the official stack from componentDidCatch
    if ('componentStack' in error) {
      // @ts-expect-error
      error.stack = error.componentStack;
    } else {
      // If the error is a React error, process it to clean up the stack.
      error = processReactErrorDetails(error);
    }
    return {
      componentStack: (0, _devServerEndpoints.parseErrorStack)(error.stack ?? ''),
      category: error.message,
      message: {
        content: message,
        substitutions: []
      }
    };
  }

  /**
   * Tries to stringify with JSON.stringify and toString, but catches exceptions
   * (e.g. from circular objects) and always returns a string and never throws.
   */
  function createStringifySafeWithLimits(limits) {
    const {
      maxDepth = Number.POSITIVE_INFINITY,
      maxStringLimit = Number.POSITIVE_INFINITY,
      maxArrayLimit = Number.POSITIVE_INFINITY,
      maxObjectKeysLimit = Number.POSITIVE_INFINITY
    } = limits;
    const stack = [];
    function replacer(_key, value) {
      while (stack.length && this !== stack[0]) {
        stack.shift();
      }
      if (typeof value === 'string') {
        const truncatedString = '...(truncated)...';
        if (value.length > maxStringLimit + truncatedString.length) {
          return value.substring(0, maxStringLimit) + truncatedString;
        }
        return value;
      }
      if (typeof value !== 'object' || value === null) {
        return value;
      }
      let retval = value;
      if (Array.isArray(value)) {
        if (stack.length >= maxDepth) {
          retval = `[ ... array with ${value.length} values ... ]`;
        } else if (value.length > maxArrayLimit) {
          retval = value.slice(0, maxArrayLimit).concat([`... extra ${value.length - maxArrayLimit} values truncated ...`]);
        }
      } else {
        // Add refinement after Array.isArray call.
        if (typeof value !== 'object') {
          throw new Error('This was already found earlier');
        }
        const keys = Object.keys(value);
        if (stack.length >= maxDepth) {
          retval = `{ ... object with ${keys.length} keys ... }`;
        } else if (keys.length > maxObjectKeysLimit) {
          // Return a sample of the keys.
          retval = {};
          for (const k of keys.slice(0, maxObjectKeysLimit)) {
            retval[k] = value[k];
          }
          const truncatedKey = '...(truncated keys)...';
          retval[truncatedKey] = keys.length - maxObjectKeysLimit;
        }
      }
      stack.unshift(retval);
      return retval;
    }
    return function stringifySafe(arg) {
      if (arg === undefined) {
        return 'undefined';
      } else if (arg === null) {
        return 'null';
      } else if (typeof arg === 'function') {
        try {
          return arg.toString();
        } catch {
          return '[function unknown]';
        }
      } else if (arg instanceof Error) {
        return arg.message;
        // return arg.name + ': ' + arg.message;
      } else {
        // Perform a try catch, just in case the object has a circular
        // reference or stringify throws for some other reason.
        try {
          const ret = JSON.stringify(arg, replacer);
          if (ret === undefined) {
            return '["' + typeof arg + '" failed to stringify]';
          }
          return ret;
        } catch {
          if (typeof arg.toString === 'function') {
            try {
              // $FlowFixMe[incompatible-use] : toString shouldn't take any arguments in general.
              return arg.toString();
            } catch {}
          }
        }
      }
      return '["' + typeof arg + '" failed to stringify]';
    };
  }
  const stringifySafe = createStringifySafeWithLimits({
    maxDepth: 10,
    maxStringLimit: 100,
    maxArrayLimit: 50,
    maxObjectKeysLimit: 50
  });
},321,[35,317]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "LogBoxLog", {
    enumerable: true,
    get: function () {
      return LogBoxLog;
    }
  });
  Object.defineProperty(exports, "LogContext", {
    enumerable: true,
    get: function () {
      return LogContext;
    }
  });
  exports.useLogs = useLogs;
  var _react = require(_dependencyMap[0]);
  var React = _interopDefault(_react);
  var _devServerEndpoints = require(_dependencyMap[1]);
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  const PRINT_FIXTURES = true;
  class LogBoxLog {
    codeFrame = {};
    symbolicated = {
      stack: {
        error: null,
        stack: null,
        status: 'NONE'
      },
      component: {
        error: null,
        stack: null,
        status: 'NONE'
      }
    };
    callbacks = new Map();
    constructor(data) {
      this.level = data.level;
      this.type = data.type ?? 'error';
      this.message = data.message;
      this.stack = data.stack;
      this.category = data.category;
      this.componentStack = data.componentStack;
      this.codeFrame = data.codeFrame;
      this.isComponentError = data.isComponentError;
      this.count = 1;
      this.symbolicated = data.symbolicated ?? this.symbolicated;
      this.isMissingModuleError = data.isMissingModuleError;
      // Create unsymbolidated fixture:
      // console.log('LogBoxLog', JSON.stringify(data, null, 2));
    }
    incrementCount() {
      this.count += 1;
    }
    getStackStatus(type) {
      return this.symbolicated[type]?.status;
    }
    getAvailableStack(type) {
      if (this.symbolicated[type]?.status === 'COMPLETE') {
        return this.symbolicated[type].stack;
      }
      return this.getStack(type);
    }
    flushCallbacks(type) {
      const callbacks = this.callbacks.get(type);
      const status = this.symbolicated[type]?.status;
      if (callbacks) {
        for (const callback of callbacks) {
          callback(status);
        }
        callbacks.clear();
      }
    }
    pushCallback(type, callback) {
      let callbacks = this.callbacks.get(type);
      if (!callbacks) {
        callbacks = new Set();
        this.callbacks.set(type, callbacks);
      }
      callbacks.add(callback);
    }
    retrySymbolicate(type, callback) {
      this._symbolicate(type, true, callback);
    }
    symbolicate(type, callback) {
      this._symbolicate(type, false, callback);
    }
    _symbolicate(type, retry, callback) {
      if (callback) {
        this.pushCallback(type, callback);
      }
      const status = this.symbolicated[type]?.status;
      if (status === 'COMPLETE') {
        {
          // Create symbolicated fixture:
          console.log('LogBoxLog.symbolicated:', JSON.stringify({
            stack: this.stack,
            componentStack: this.componentStack,
            level: this.level,
            type: this.type,
            message: this.message,
            category: this.category,
            codeFrame: this.codeFrame,
            isComponentError: this.isComponentError,
            symbolicated: this.symbolicated
          }, null, 2));
        }
        return this.flushCallbacks(type);
      }
      if (retry) {
        (0, _devServerEndpoints.invalidateCachedStack)(this.getStack(type));
        this.handleSymbolicate(type);
      } else {
        if (status === 'NONE') {
          this.handleSymbolicate(type);
        }
      }
    }
    getStack(type) {
      if (type === 'component') {
        return this.componentStack;
      }
      return this.stack;
    }
    handleSymbolicate(type) {
      if (this.symbolicated[type]?.status === 'PENDING') {
        return;
      }
      this.updateStatus(type, null, null, null);
      (0, _devServerEndpoints.symbolicateStackAndCacheAsync)(this.getStack(type)).then(data => {
        console.log('LogBoxLog.symbolicate:', JSON.stringify(data, null, 2));
        this.updateStatus(type, null, data?.stack, data?.codeFrame);
      }, error => {
        this.updateStatus(type, error, null, null);
      });
    }
    updateStatus(type, error, stack, codeFrame) {
      const lastStatus = this.symbolicated[type]?.status;
      if (error != null) {
        this.symbolicated[type] = {
          error,
          stack: null,
          status: 'FAILED'
        };
      } else if (stack != null) {
        if (codeFrame) {
          this.codeFrame[type] = codeFrame;
        }
        this.symbolicated[type] = {
          error: null,
          stack,
          status: 'COMPLETE'
        };
      } else {
        this.symbolicated[type] = {
          error: null,
          stack: null,
          status: 'PENDING'
        };
      }
      const status = this.symbolicated[type]?.status;
      if (lastStatus !== status) {
        if (['COMPLETE', 'FAILED'].includes(status)) {
          this.flushCallbacks(type);
        }
      }
    }
  }
  const LogContext = /*#__PURE__*/React.default.createContext(null);
  function useLogs() {
    const logs = React.default.useContext(LogContext);
    if (!logs) {
      // TODO: Move this outside of the hook.
      if (typeof window !== 'undefined') {
        // Logbox data that is pre-fetched on the dev server and rendered here.
        const expoCliStaticErrorElement = document.getElementById('_expo-static-error');
        if (expoCliStaticErrorElement?.textContent) {
          const raw = JSON.parse(expoCliStaticErrorElement.textContent);
          return Object.assign({}, raw, {
            logs: raw.logs.map(raw => new LogBoxLog(raw))
          });
        }
      }
      throw new Error('useLogs must be used within a LogContext.Provider');
    }
    return logs;
  }
},322,[35,317]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  'use strict';

  {
    module.exports = require(_dependencyMap[0]);
  }
},323,[324]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * @license React
   * react-jsx-runtime.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  "use strict";

  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
    REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
  function jsxProd(type, config, maybeKey) {
    var key = null;
    undefined !== maybeKey && (key = "" + maybeKey);
    undefined !== config.key && (key = "" + config.key);
    if ("key" in config) {
      maybeKey = {};
      for (var propName in config) "key" !== propName && (maybeKey[propName] = config[propName]);
    } else maybeKey = config;
    config = maybeKey.ref;
    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type: type,
      key: key,
      ref: undefined !== config ? config : null,
      props: maybeKey
    };
  }
  exports.Fragment = REACT_FRAGMENT_TYPE;
  exports.jsx = jsxProd;
  exports.jsxs = jsxProd;
},324,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.ErrorCodeFrame = ErrorCodeFrame;
  exports.Terminal = Terminal;
  exports.CodeFrame = CodeFrame;
  exports.FileIcon = FileIcon;
  exports.TerminalIcon = TerminalIcon;
  var _react = require(_dependencyMap[0]);
  var React = _interopDefault(_react);
  var _reactNativeWebDistExportsScrollView = require(_dependencyMap[1]);
  var ScrollView = _interopDefault(_reactNativeWebDistExportsScrollView);
  var _AnsiHighlight = require(_dependencyMap[2]);
  var _devServerEndpoints = require(_dependencyMap[3]);
  var _ErrorCodeFrameModuleCss = require(_dependencyMap[4]);
  var styles = _interopDefault(_ErrorCodeFrameModuleCss);
  var _reactJsxRuntime = require(_dependencyMap[5]);
  /**
   * Copyright (c) 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  //@ts-expect-error unexpected css import by ts

  function ErrorCodeFrame({
    projectRoot,
    codeFrame
  }) {
    if (codeFrame == null) {
      return null;
    }
    function getFileName() {
      return (0, _devServerEndpoints.formatProjectFilePath)(projectRoot ?? '', codeFrame?.fileName);
    }
    function getLocation() {
      const location = codeFrame?.location;
      if (location != null) {
        return ` (${location.row}:${location.column + 1 /* Code frame columns are zero indexed */})`;
      }
      return null;
    }
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(CodeFrame, {
      title: /*#__PURE__*/(0, _reactJsxRuntime.jsxs)(_reactJsxRuntime.Fragment, {
        children: [getFileName(), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("span", {
          style: {
            opacity: 0.8
          },
          children: getLocation()
        })]
      }),
      headerIcon: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(FileIcon, {}),
      headerAction: /*#__PURE__*/(0, _reactJsxRuntime.jsxs)("button", {
        className: styles.default.copyButton,
        type: "button",
        title: "Open in editor",
        onClick: () => {
          (0, _devServerEndpoints.openFileInEditor)(codeFrame.fileName, codeFrame.location?.row ?? 0);
        },
        "aria-label": "Copy content",
        children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)("p", {
          className: styles.default.copyButtonText,
          "data-text": "true",
          children: "Open"
        }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)(OpenIcon, {
          className: styles.default.copyButtonIcon,
          width: 26,
          height: 26
        })]
      }),
      content: codeFrame.content
    });
  }
  function Terminal({
    content,
    moduleName
  }) {
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(CodeFrame, {
      title: "Terminal",
      headerAction: /*#__PURE__*/(0, _reactJsxRuntime.jsxs)("button", {
        className: styles.default.copyButton,
        type: "button",
        title: "Run command in project",
        onClick: () => {
          // TODO: Stream back progress
          (0, _devServerEndpoints.installPackageInProject)(moduleName);
        },
        "aria-label": "Copy content",
        children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)("p", {
          className: styles.default.copyButtonText,
          "data-text": "true",
          children: "Run"
        }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)(PlayIcon, {
          className: styles.default.copyButtonIcon,
          width: 26,
          height: 26
        })]
      }),
      headerIcon: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(TerminalIcon, {}),
      content: content
    });
  }
  function CodeFrame({
    content,
    headerIcon,
    headerAction,
    title
  }) {
    const leftBlurRef = React.default.useRef(null);
    const scrollTextRef = React.default.useRef(null);

    // Transition the opacity of the header blur when the scroll position changes.
    (0, _react.useEffect)(() => {
      const scrollElement = scrollTextRef.current;
      const leftBlurElement = leftBlurRef.current;
      if (scrollElement == null || leftBlurElement == null) {
        return;
      }
      const handleScroll = () => {
        leftBlurElement.style.opacity = String(scrollElement.scrollLeft / 20);
      };
      scrollElement.addEventListener('scroll', handleScroll);
      return () => {
        scrollElement.removeEventListener('scroll', handleScroll);
      };
    }, [scrollTextRef, leftBlurRef]);

    // Scroll to end of the text when it changes
    (0, _react.useEffect)(() => {
      const scrollElement = scrollTextRef.current;
      if (scrollElement == null) {
        return;
      }
      scrollElement.scrollTo({
        left: scrollElement.scrollWidth,
        behavior: 'smooth'
      });
    }, [scrollTextRef, content]);

    // Try to match the Expo docs
    return /*#__PURE__*/(0, _reactJsxRuntime.jsxs)("div", {
      style: {
        backgroundColor: 'var(--expo-log-secondary-system-grouped-background)',
        border: '1px solid var(--expo-log-color-border)',
        marginTop: 5,
        borderRadius: 6
      },
      children: [/*#__PURE__*/(0, _reactJsxRuntime.jsxs)("header", {
        className: styles.default.header,
        children: [/*#__PURE__*/(0, _reactJsxRuntime.jsxs)("span", {
          style: {
            display: 'flex',
            width: '100%',
            position: 'relative',
            overflowX: 'hidden'
          },
          children: [/*#__PURE__*/(0, _reactJsxRuntime.jsxs)("span", {
            ref: scrollTextRef,
            className: styles.default.headerScrollText,
            children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)("span", {
              className: styles.default.headerIconWrapper,
              style: {},
              children: headerIcon
            }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("span", {
              className: styles.default.headerText,
              children: title
            })]
          }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("span", {
            ref: leftBlurRef,
            className: styles.default.blurGradientLR
          }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("span", {
            className: styles.default.blurGradientRL
          })]
        }), headerAction]
      }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("div", {
        style: {
          padding: 10,
          display: 'flex',
          flexDirection: 'column'
        },
        children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(ScrollView.default, {
          horizontal: true,
          contentContainerStyle: {
            flexDirection: 'column'
          },
          children: content && /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_AnsiHighlight.Ansi, {
            style: {
              flexDirection: 'column',
              color: 'var(--expo-log-color-label)',
              fontSize: 12,
              includeFontPadding: false,
              lineHeight: 20,
              fontFamily: 'var(--expo-log-font-mono)'
            },
            text: content
          })
        })
      })]
    });
  }
  function PlayIcon(props) {
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)("svg", Object.assign({
      fill: "none",
      viewBox: "0 0 24 24",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      stroke: "currentColor"
    }, props, {
      role: "img",
      children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)("polygon", {
        points: "6 3 20 12 6 21 6 3"
      })
    }));
  }
  function OpenIcon(props) {
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)("svg", Object.assign({
      fill: "none",
      viewBox: "0 0 24 24",
      stroke: "currentColor"
    }, props, {
      role: "img",
      children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        strokeWidth: "2",
        d: "M7 17L17 7M17 7H7M17 7V17"
      })
    }));
  }
  function FileIcon() {
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)("svg", {
      fill: "none",
      viewBox: "0 0 24 24",
      stroke: "currentColor",
      style: {
        width: '1rem',
        height: '1rem',
        color: 'var(--expo-log-secondary-label)'
      },
      className: styles.default.fileIcon,
      role: "img",
      children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        strokeWidth: "2",
        d: "M14 2.26953V6.40007C14 6.96012 14 7.24015 14.109 7.45406C14.2049 7.64222 14.3578 7.7952 14.546 7.89108C14.7599 8.00007 15.0399 8.00007 15.6 8.00007H19.7305M14 17.5L16.5 15L14 12.5M10 12.5L7.5 15L10 17.5M20 9.98822V17.2C20 18.8802 20 19.7202 19.673 20.362C19.3854 20.9265 18.9265 21.3854 18.362 21.673C17.7202 22 16.8802 22 15.2 22H8.8C7.11984 22 6.27976 22 5.63803 21.673C5.07354 21.3854 4.6146 20.9265 4.32698 20.362C4 19.7202 4 18.8802 4 17.2V6.8C4 5.11984 4 4.27976 4.32698 3.63803C4.6146 3.07354 5.07354 2.6146 5.63803 2.32698C6.27976 2 7.11984 2 8.8 2H12.0118C12.7455 2 13.1124 2 13.4577 2.08289C13.7638 2.15638 14.0564 2.27759 14.3249 2.44208C14.6276 2.6276 14.887 2.88703 15.4059 3.40589L18.5941 6.59411C19.113 7.11297 19.3724 7.3724 19.5579 7.67515C19.7224 7.94356 19.8436 8.2362 19.9171 8.5423C20 8.88757 20 9.25445 20 9.98822Z"
      })
    });
  }
  function TerminalIcon() {
    return /*#__PURE__*/(0, _reactJsxRuntime.jsxs)("svg", {
      fill: "none",
      viewBox: "0 0 24 24",
      stroke: "currentColor",
      style: {
        width: '1rem',
        height: '1rem',
        color: 'var(--expo-log-secondary-label)'
      },
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      className: styles.default.fileIcon,
      role: "img",
      children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)("polyline", {
        points: "4 17 10 11 4 5"
      }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("line", {
        x1: "12",
        x2: "20",
        y1: "19",
        y2: "19"
      })]
    });
  }
},325,[35,161,326,317,328,323]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  Object.defineProperty(exports, "Ansi", {
    enumerable: true,
    get: function () {
      return Ansi;
    }
  });
  exports.AnsiUnsafe = AnsiUnsafe;
  var _anser = require(_dependencyMap[0]);
  var Anser = _interopDefault(_anser);
  var _react = require(_dependencyMap[1]);
  var React = _interopDefault(_react);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[2]);
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsText = require(_dependencyMap[3]);
  var Text = _interopDefault(_reactNativeWebDistExportsText);
  var _reactNativeWebDistExportsView = require(_dependencyMap[4]);
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _reactJsxRuntime = require(_dependencyMap[5]);
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  // Afterglow theme from https://iterm2colorschemes.com/
  const COLORS = {
    'ansi-black': 'rgb(27, 27, 27)',
    'ansi-red': 'var(--expo-log-syntax-red)',
    'ansi-green': '#ffca16',
    'ansi-yellow': 'var(--expo-log-syntax-orange)',
    'ansi-cyan': '#de51a8',
    'ansi-magenta': '#6abaff',
    'ansi-blue': 'rgb(125, 169, 199)',
    // Instead of white, use the default color provided to the component
    // 'ansi-white': 'rgb(216, 216, 216)',
    'ansi-bright-black': 'rgb(98, 98, 98)',
    'ansi-bright-red': 'rgb(187, 86, 83)',
    'ansi-bright-green': 'rgb(144, 157, 98)',
    'ansi-bright-yellow': 'rgb(234, 193, 121)',
    'ansi-bright-blue': 'rgb(125, 169, 199)',
    'ansi-bright-magenta': 'rgb(176, 101, 151)',
    'ansi-bright-cyan': 'rgb(140, 220, 216)',
    'ansi-bright-white': 'rgb(247, 247, 247)'
  };
  class Ansi extends React.default.Component {
    constructor(props) {
      super(props);
      this.state = {
        hasError: false
      };
    }
    static getDerivedStateFromError(error) {
      return {
        hasError: true
      };
    }
    componentDidCatch(error, errorInfo) {
      console.error('AnsiSafe caught an error:', error, errorInfo);
    }
    render() {
      if (this.state.hasError) {
        return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Text.default, {
          style: this.props.style,
          children: "Error rendering ANSI text."
        });
      }
      return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(AnsiUnsafe, {
        text: this.props.text || '',
        style: this.props.style
      });
    }
  }
  function AnsiUnsafe({
    text,
    style
  }) {
    // TMP
    if (!text) {
      return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Text.default, {
        style: style,
        children: "Text not provided to Ansi component."
      });
    }
    let commonWhitespaceLength = Infinity;
    const parsedLines = text.split(/\n/).map(line => Anser.default.ansiToJson(line, {
      json: true,
      remove_empty: true,
      use_classes: true
    }));
    parsedLines.map(lines => {
      // The third item on each line includes the whitespace of the source code.
      // We are looking for the least amount of common whitespace to trim all lines.
      // Example: Array [" ", " 96 |", "     text", ...]
      const match = lines[2] && lines[2]?.content?.match(/^ +/);
      const whitespaceLength = match && match[0]?.length || 0;
      if (whitespaceLength < commonWhitespaceLength) {
        commonWhitespaceLength = whitespaceLength;
      }
    });
    const getText = (content, key) => {
      if (key === 1) {
        // Remove the vertical bar after line numbers
        return content.replace(/\| $/, ' ');
      } else if (key === 2 && commonWhitespaceLength < Infinity) {
        // Remove common whitespace at the beginning of the line
        return content.substr(commonWhitespaceLength);
      } else {
        return content;
      }
    };
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactJsxRuntime.Fragment, {
      children: parsedLines.map((items, i) => /*#__PURE__*/(0, _reactJsxRuntime.jsx)(View.default, {
        style: styles.line,
        children: items.map((bundle, key) => {
          const textStyle = bundle.fg && COLORS[bundle.fg] ? {
            backgroundColor: bundle.bg && COLORS[bundle.bg],
            color: bundle.fg && COLORS[bundle.fg]
          } : {
            backgroundColor: bundle.bg && COLORS[bundle.bg]
          };
          return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Text.default, {
            style: [style, textStyle],
            children: getText(bundle.content, key)
          }, key);
        })
      }, i))
    });
  }
  const styles = StyleSheet.default.create({
    line: {
      flexDirection: 'row'
    }
  });
},326,[327,35,43,216,138,323]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  // This file was originally written by @drudru (https://github.com/drudru/ansi_up), MIT, 2011
  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var ANSI_COLORS = [[{
    color: "0, 0, 0",
    "class": "ansi-black"
  }, {
    color: "187, 0, 0",
    "class": "ansi-red"
  }, {
    color: "0, 187, 0",
    "class": "ansi-green"
  }, {
    color: "187, 187, 0",
    "class": "ansi-yellow"
  }, {
    color: "0, 0, 187",
    "class": "ansi-blue"
  }, {
    color: "187, 0, 187",
    "class": "ansi-magenta"
  }, {
    color: "0, 187, 187",
    "class": "ansi-cyan"
  }, {
    color: "255,255,255",
    "class": "ansi-white"
  }], [{
    color: "85, 85, 85",
    "class": "ansi-bright-black"
  }, {
    color: "255, 85, 85",
    "class": "ansi-bright-red"
  }, {
    color: "0, 255, 0",
    "class": "ansi-bright-green"
  }, {
    color: "255, 255, 85",
    "class": "ansi-bright-yellow"
  }, {
    color: "85, 85, 255",
    "class": "ansi-bright-blue"
  }, {
    color: "255, 85, 255",
    "class": "ansi-bright-magenta"
  }, {
    color: "85, 255, 255",
    "class": "ansi-bright-cyan"
  }, {
    color: "255, 255, 255",
    "class": "ansi-bright-white"
  }]];
  var Anser = function () {
    _createClass(Anser, null, [{
      key: "escapeForHtml",
      /**
       * Anser.escapeForHtml
       * Escape the input HTML.
       *
       * This does the minimum escaping of text to make it compliant with HTML.
       * In particular, the '&','<', and '>' characters are escaped. This should
       * be run prior to `ansiToHtml`.
       *
       * @name Anser.escapeForHtml
       * @function
       * @param {String} txt The input text (containing the ANSI snippets).
       * @returns {String} The escaped html.
       */
      value: function escapeForHtml(txt) {
        return new Anser().escapeForHtml(txt);
      }

      /**
       * Anser.linkify
       * Adds the links in the HTML.
       *
       * This replaces any links in the text with anchor tags that display the
       * link. The links should have at least one whitespace character
       * surrounding it. Also, you should apply this after you have run
       * `ansiToHtml` on the text.
       *
       * @name Anser.linkify
       * @function
       * @param {String} txt The input text.
       * @returns {String} The HTML containing the <a> tags (unescaped).
       */
    }, {
      key: "linkify",
      value: function linkify(txt) {
        return new Anser().linkify(txt);
      }

      /**
       * Anser.ansiToHtml
       * This replaces ANSI terminal escape codes with SPAN tags that wrap the
       * content.
       *
       * This function only interprets ANSI SGR (Select Graphic Rendition) codes
       * that can be represented in HTML.
       * For example, cursor movement codes are ignored and hidden from output.
       * The default style uses colors that are very close to the prescribed
       * standard. The standard assumes that the text will have a black
       * background. These colors are set as inline styles on the SPAN tags.
       *
       * Another option is to set `use_classes: true` in the options argument.
       * This will instead set classes on the spans so the colors can be set via
       * CSS. The class names used are of the format `ansi-*-fg/bg` and
       * `ansi-bright-*-fg/bg` where `*` is the color name,
       * i.e black/red/green/yellow/blue/magenta/cyan/white.
       *
       * @name Anser.ansiToHtml
       * @function
       * @param {String} txt The input text.
       * @param {Object} options The options passed to the ansiToHTML method.
       * @returns {String} The HTML output.
       */
    }, {
      key: "ansiToHtml",
      value: function ansiToHtml(txt, options) {
        return new Anser().ansiToHtml(txt, options);
      }

      /**
       * Anser.ansiToJson
       * Converts ANSI input into JSON output.
       *
       * @name Anser.ansiToJson
       * @function
       * @param {String} txt The input text.
       * @param {Object} options The options passed to the ansiToHTML method.
       * @returns {String} The HTML output.
       */
    }, {
      key: "ansiToJson",
      value: function ansiToJson(txt, options) {
        return new Anser().ansiToJson(txt, options);
      }

      /**
       * Anser.ansiToText
       * Converts ANSI input into text output.
       *
       * @name Anser.ansiToText
       * @function
       * @param {String} txt The input text.
       * @returns {String} The text output.
       */
    }, {
      key: "ansiToText",
      value: function ansiToText(txt) {
        return new Anser().ansiToText(txt);
      }

      /**
       * Anser
       * The `Anser` class.
       *
       * @name Anser
       * @function
       * @returns {Anser}
       */
    }]);
    function Anser() {
      _classCallCheck(this, Anser);
      this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null;
      this.bright = 0;
    }

    /**
     * setupPalette
     * Sets up the palette.
     *
     * @name setupPalette
     * @function
     */

    _createClass(Anser, [{
      key: "setupPalette",
      value: function setupPalette() {
        this.PALETTE_COLORS = [];

        // Index 0..15 : System color
        for (var i = 0; i < 2; ++i) {
          for (var j = 0; j < 8; ++j) {
            this.PALETTE_COLORS.push(ANSI_COLORS[i][j].color);
          }
        }

        // Index 16..231 : RGB 6x6x6
        // https://gist.github.com/jasonm23/2868981#file-xterm-256color-yaml
        var levels = [0, 95, 135, 175, 215, 255];
        var format = function format(r, g, b) {
          return levels[r] + ", " + levels[g] + ", " + levels[b];
        };
        var r = undefined,
          g = undefined,
          b = undefined;
        for (var _r = 0; _r < 6; ++_r) {
          for (var _g = 0; _g < 6; ++_g) {
            for (var _b = 0; _b < 6; ++_b) {
              this.PALETTE_COLORS.push(format(_r, _g, _b));
            }
          }
        }

        // Index 232..255 : Grayscale
        var level = 8;
        for (var _i = 0; _i < 24; ++_i, level += 10) {
          this.PALETTE_COLORS.push(format(level, level, level));
        }
      }

      /**
       * escapeForHtml
       * Escapes the input text.
       *
       * @name escapeForHtml
       * @function
       * @param {String} txt The input text.
       * @returns {String} The escpaed HTML output.
       */
    }, {
      key: "escapeForHtml",
      value: function escapeForHtml(txt) {
        return txt.replace(/[&<>]/gm, function (str) {
          return str == "&" ? "&amp;" : str == "<" ? "&lt;" : str == ">" ? "&gt;" : "";
        });
      }

      /**
       * linkify
       * Adds HTML link elements.
       *
       * @name linkify
       * @function
       * @param {String} txt The input text.
       * @returns {String} The HTML output containing link elements.
       */
    }, {
      key: "linkify",
      value: function linkify(txt) {
        return txt.replace(/(https?:\/\/[^\s]+)/gm, function (str) {
          return "<a href=\"" + str + "\">" + str + "</a>";
        });
      }

      /**
       * ansiToHtml
       * Converts ANSI input into HTML output.
       *
       * @name ansiToHtml
       * @function
       * @param {String} txt The input text.
       * @param {Object} options The options passed ot the `process` method.
       * @returns {String} The HTML output.
       */
    }, {
      key: "ansiToHtml",
      value: function ansiToHtml(txt, options) {
        return this.process(txt, options, true);
      }

      /**
       * ansiToJson
       * Converts ANSI input into HTML output.
       *
       * @name ansiToJson
       * @function
       * @param {String} txt The input text.
       * @param {Object} options The options passed ot the `process` method.
       * @returns {String} The JSON output.
       */
    }, {
      key: "ansiToJson",
      value: function ansiToJson(txt, options) {
        options = options || {};
        options.json = true;
        options.clearLine = false;
        return this.process(txt, options, true);
      }

      /**
       * ansiToText
       * Converts ANSI input into HTML output.
       *
       * @name ansiToText
       * @function
       * @param {String} txt The input text.
       * @returns {String} The text output.
       */
    }, {
      key: "ansiToText",
      value: function ansiToText(txt) {
        return this.process(txt, {}, false);
      }

      /**
       * process
       * Processes the input.
       *
       * @name process
       * @function
       * @param {String} txt The input text.
       * @param {Object} options An object passed to `processChunk` method, extended with:
       *
       *  - `json` (Boolean): If `true`, the result will be an object.
       *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
       *
       * @param {Boolean} markup
       */
    }, {
      key: "process",
      value: function process(txt, options, markup) {
        var _this = this;
        var self = this;
        var raw_text_chunks = txt.split(/\033\[/);
        var first_chunk = raw_text_chunks.shift(); // the first chunk is not the result of the split

        if (options === undefined || options === null) {
          options = {};
        }
        options.clearLine = /\r/.test(txt); // check for Carriage Return
        var color_chunks = raw_text_chunks.map(function (chunk) {
          return _this.processChunk(chunk, options, markup);
        });
        if (options && options.json) {
          var first = self.processChunkJson("");
          first.content = first_chunk;
          first.clearLine = options.clearLine;
          color_chunks.unshift(first);
          if (options.remove_empty) {
            color_chunks = color_chunks.filter(function (c) {
              return !c.isEmpty();
            });
          }
          return color_chunks;
        } else {
          color_chunks.unshift(first_chunk);
        }
        return color_chunks.join("");
      }

      /**
       * processChunkJson
       * Processes the current chunk into json output.
       *
       * @name processChunkJson
       * @function
       * @param {String} text The input text.
       * @param {Object} options An object containing the following fields:
       *
       *  - `json` (Boolean): If `true`, the result will be an object.
       *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
       *
       * @param {Boolean} markup If false, the colors will not be parsed.
       * @return {Object} The result object:
       *
       *  - `content` (String): The text.
       *  - `fg` (String|null): The foreground color.
       *  - `bg` (String|null): The background color.
       *  - `fg_truecolor` (String|null): The foreground true color (if 16m color is enabled).
       *  - `bg_truecolor` (String|null): The background true color (if 16m color is enabled).
       *  - `clearLine` (Boolean): `true` if a carriageReturn \r was fount at end of line.
       *  - `was_processed` (Bolean): `true` if the colors were processed, `false` otherwise.
       *  - `isEmpty` (Function): A function returning `true` if the content is empty, or `false` otherwise.
       *
       */
    }, {
      key: "processChunkJson",
      value: function processChunkJson(text, options, markup) {
        // Are we using classes or styles?
        options = typeof options == "undefined" ? {} : options;
        var use_classes = options.use_classes = typeof options.use_classes != "undefined" && options.use_classes;
        var key = options.key = use_classes ? "class" : "color";
        var result = {
          content: text,
          fg: null,
          bg: null,
          fg_truecolor: null,
          bg_truecolor: null,
          clearLine: options.clearLine,
          decoration: null,
          was_processed: false,
          isEmpty: function isEmpty() {
            return !result.content;
          }
        };

        // Each "chunk" is the text after the CSI (ESC + "[") and before the next CSI/EOF.
        //
        // This regex matches four groups within a chunk.
        //
        // The first and third groups match code type.
        // We supported only SGR command. It has empty first group and "m" in third.
        //
        // The second group matches all of the number+semicolon command sequences
        // before the "m" (or other trailing) character.
        // These are the graphics or SGR commands.
        //
        // The last group is the text (including newlines) that is colored by
        // the other group"s commands.
        var matches = text.match(/^([!\x3c-\x3f]*)([\d;]*)([\x20-\x2c]*[\x40-\x7e])([\s\S]*)/m);
        if (!matches) return result;
        var orig_txt = result.content = matches[4];
        var nums = matches[2].split(";");

        // We currently support only "SGR" (Select Graphic Rendition)
        // Simply ignore if not a SGR command.
        if (matches[1] !== "" || matches[3] !== "m") {
          return result;
        }
        if (!markup) {
          return result;
        }
        var self = this;
        self.decoration = null;
        while (nums.length > 0) {
          var num_str = nums.shift();
          var num = parseInt(num_str);
          if (isNaN(num) || num === 0) {
            self.fg = self.bg = self.decoration = null;
          } else if (num === 1) {
            self.decoration = "bold";
          } else if (num === 2) {
            self.decoration = "dim";
            // Enable code 2 to get string
          } else if (num == 3) {
            self.decoration = "italic";
          } else if (num == 4) {
            self.decoration = "underline";
          } else if (num == 5) {
            self.decoration = "blink";
          } else if (num === 7) {
            self.decoration = "reverse";
          } else if (num === 8) {
            self.decoration = "hidden";
            // Enable code 9 to get strikethrough
          } else if (num === 9) {
            self.decoration = "strikethrough";
          } else if (num == 39) {
            self.fg = null;
          } else if (num == 49) {
            self.bg = null;
            // Foreground color
          } else if (num >= 30 && num < 38) {
            self.fg = ANSI_COLORS[0][num % 10][key];
            // Foreground bright color
          } else if (num >= 90 && num < 98) {
            self.fg = ANSI_COLORS[1][num % 10][key];
            // Background color
          } else if (num >= 40 && num < 48) {
            self.bg = ANSI_COLORS[0][num % 10][key];
            // Background bright color
          } else if (num >= 100 && num < 108) {
            self.bg = ANSI_COLORS[1][num % 10][key];
          } else if (num === 38 || num === 48) {
            // extend color (38=fg, 48=bg)
            var is_foreground = num === 38;
            if (nums.length >= 1) {
              var mode = nums.shift();
              if (mode === "5" && nums.length >= 1) {
                // palette color
                var palette_index = parseInt(nums.shift());
                if (palette_index >= 0 && palette_index <= 255) {
                  if (!use_classes) {
                    if (!this.PALETTE_COLORS) {
                      self.setupPalette();
                    }
                    if (is_foreground) {
                      self.fg = this.PALETTE_COLORS[palette_index];
                    } else {
                      self.bg = this.PALETTE_COLORS[palette_index];
                    }
                  } else {
                    var klass = palette_index >= 16 ? "ansi-palette-" + palette_index : ANSI_COLORS[palette_index > 7 ? 1 : 0][palette_index % 8]["class"];
                    if (is_foreground) {
                      self.fg = klass;
                    } else {
                      self.bg = klass;
                    }
                  }
                }
              } else if (mode === "2" && nums.length >= 3) {
                // true color
                var r = parseInt(nums.shift());
                var g = parseInt(nums.shift());
                var b = parseInt(nums.shift());
                if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {
                  var color = r + ", " + g + ", " + b;
                  if (!use_classes) {
                    if (is_foreground) {
                      self.fg = color;
                    } else {
                      self.bg = color;
                    }
                  } else {
                    if (is_foreground) {
                      self.fg = "ansi-truecolor";
                      self.fg_truecolor = color;
                    } else {
                      self.bg = "ansi-truecolor";
                      self.bg_truecolor = color;
                    }
                  }
                }
              }
            }
          }
        }
        if (self.fg === null && self.bg === null && self.decoration === null) {
          return result;
        } else {
          var styles = [];
          var classes = [];
          var data = {};
          result.fg = self.fg;
          result.bg = self.bg;
          result.fg_truecolor = self.fg_truecolor;
          result.bg_truecolor = self.bg_truecolor;
          result.decoration = self.decoration;
          result.was_processed = true;
          return result;
        }
      }

      /**
       * processChunk
       * Processes the current chunk of text.
       *
       * @name processChunk
       * @function
       * @param {String} text The input text.
       * @param {Object} options An object containing the following fields:
       *
       *  - `json` (Boolean): If `true`, the result will be an object.
       *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
       *
       * @param {Boolean} markup If false, the colors will not be parsed.
       * @return {Object|String} The result (object if `json` is wanted back or string otherwise).
       */
    }, {
      key: "processChunk",
      value: function processChunk(text, options, markup) {
        var _this2 = this;
        var self = this;
        options = options || {};
        var jsonChunk = this.processChunkJson(text, options, markup);
        if (options.json) {
          return jsonChunk;
        }
        if (jsonChunk.isEmpty()) {
          return "";
        }
        if (!jsonChunk.was_processed) {
          return jsonChunk.content;
        }
        var use_classes = options.use_classes;
        var styles = [];
        var classes = [];
        var data = {};
        var render_data = function render_data(data) {
          var fragments = [];
          var key = undefined;
          for (key in data) {
            if (data.hasOwnProperty(key)) {
              fragments.push("data-" + key + "=\"" + _this2.escapeForHtml(data[key]) + "\"");
            }
          }
          return fragments.length > 0 ? " " + fragments.join(" ") : "";
        };
        if (jsonChunk.fg) {
          if (use_classes) {
            classes.push(jsonChunk.fg + "-fg");
            if (jsonChunk.fg_truecolor !== null) {
              data["ansi-truecolor-fg"] = jsonChunk.fg_truecolor;
              jsonChunk.fg_truecolor = null;
            }
          } else {
            styles.push("color:rgb(" + jsonChunk.fg + ")");
          }
        }
        if (jsonChunk.bg) {
          if (use_classes) {
            classes.push(jsonChunk.bg + "-bg");
            if (jsonChunk.bg_truecolor !== null) {
              data["ansi-truecolor-bg"] = jsonChunk.bg_truecolor;
              jsonChunk.bg_truecolor = null;
            }
          } else {
            styles.push("background-color:rgb(" + jsonChunk.bg + ")");
          }
        }
        if (jsonChunk.decoration) {
          if (use_classes) {
            classes.push("ansi-" + jsonChunk.decoration);
          } else if (jsonChunk.decoration === "bold") {
            styles.push("font-weight:bold");
          } else if (jsonChunk.decoration === "dim") {
            styles.push("opacity:0.5");
          } else if (jsonChunk.decoration === "italic") {
            styles.push("font-style:italic");
            // underline and blink are treated bellow
          } else if (jsonChunk.decoration === "reverse") {
            styles.push("filter:invert(100%)");
          } else if (jsonChunk.decoration === "hidden") {
            styles.push("visibility:hidden");
          } else if (jsonChunk.decoration === "strikethrough") {
            styles.push("text-decoration:line-through");
          } else {
            styles.push("text-decoration:" + jsonChunk.decoration);
          }
        }
        if (use_classes) {
          return "<span class=\"" + classes.join(" ") + "\"" + render_data(data) + ">" + jsonChunk.content + "</span>";
        } else {
          return "<span style=\"" + styles.join(";") + "\"" + render_data(data) + ">" + jsonChunk.content + "</span>";
        }
      }
    }]);
    return Anser;
  }();
  ;
  module.exports = Anser;
},327,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = Object.assign({
    "copyButton": "_8XKVMW_copyButton",
    "headerScrollText": "_8XKVMW_headerScrollText",
    "fileIcon": "_8XKVMW_fileIcon",
    "copyButtonText": "_8XKVMW_copyButtonText",
    "headerText": "_8XKVMW_headerText",
    "copyButtonIcon": "_8XKVMW_copyButtonIcon",
    "blurGradientRL": "_8XKVMW_blurGradientRL",
    "blurGradientLR": "_8XKVMW_blurGradientLR",
    "header": "_8XKVMW_header",
    "headerIconWrapper": "_8XKVMW_headerIconWrapper"
  }, {
    unstable_styles: {
      "copyButton": {
        "$$css": true,
        "_": "_8XKVMW_copyButton"
      },
      "headerScrollText": {
        "$$css": true,
        "_": "_8XKVMW_headerScrollText"
      },
      "fileIcon": {
        "$$css": true,
        "_": "_8XKVMW_fileIcon"
      },
      "copyButtonText": {
        "$$css": true,
        "_": "_8XKVMW_copyButtonText"
      },
      "headerText": {
        "$$css": true,
        "_": "_8XKVMW_headerText"
      },
      "copyButtonIcon": {
        "$$css": true,
        "_": "_8XKVMW_copyButtonIcon"
      },
      "blurGradientRL": {
        "$$css": true,
        "_": "_8XKVMW_blurGradientRL"
      },
      "blurGradientLR": {
        "$$css": true,
        "_": "_8XKVMW_blurGradientLR"
      },
      "header": {
        "$$css": true,
        "_": "_8XKVMW_header"
      },
      "headerIconWrapper": {
        "$$css": true,
        "_": "_8XKVMW_headerIconWrapper"
      }
    }
  }, {});
},328,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  const _excluded = ["selectedIndex", "total", "sdkVersion"]; //@ts-ignore
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.ErrorOverlayHeader = ErrorOverlayHeader;
  var _babelRuntimeHelpersObjectWithoutPropertiesLoose = require(_dependencyMap[0]);
  var _objectWithoutPropertiesLoose = _interopDefault(_babelRuntimeHelpersObjectWithoutPropertiesLoose);
  require(_dependencyMap[1]);
  var _ErrorOverlayHeaderModuleCss = require(_dependencyMap[2]);
  var styles = _interopDefault(_ErrorOverlayHeaderModuleCss);
  var _reactJsxRuntime = require(_dependencyMap[3]);
  function ErrorOverlayHeader(_ref) {
    let {
        selectedIndex,
        total,
        sdkVersion
      } = _ref,
      props = (0, _objectWithoutPropertiesLoose.default)(_ref, _excluded);
    const titleText = `${selectedIndex + 1}/${total}`;
    const isUNVERSIONED = sdkVersion?.toLowerCase() === 'unversioned';
    return /*#__PURE__*/(0, _reactJsxRuntime.jsxs)("div", {
      className: styles.default.container,
      children: [/*#__PURE__*/(0, _reactJsxRuntime.jsxs)("div", {
        className: styles.default.leftGroup,
        children: [/*#__PURE__*/(0, _reactJsxRuntime.jsxs)("div", {
          className: styles.default.headerControls,
          children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)(HeaderButton, {
            title: "Dismiss error",
            onPress: props.isDismissable ? props.onDismiss : undefined,
            children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)("svg", {
              width: "24",
              height: "24",
              viewBox: "0 0 24 24",
              fill: "var(--expo-log-secondary-label)",
              xmlns: "http://www.w3.org/2000/svg",
              children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)("path", {
                d: "M6.18945 17.8222C6.10346 17.747 6.04703 17.6556 6.02015 17.5481C5.99328 17.4405 5.99328 17.333 6.02015 17.2255C6.0524 17.118 6.10883 17.0266 6.18945 16.9513L11.1312 11.9998L6.18945 7.04836C6.10883 6.97309 6.05509 6.8817 6.02822 6.77417C6.00134 6.66665 6.00134 6.56181 6.02822 6.45966C6.05509 6.35214 6.10883 6.25806 6.18945 6.17741C6.26469 6.09677 6.35605 6.0457 6.46354 6.02419C6.57103 5.99731 6.67583 5.99731 6.77794 6.02419C6.88006 6.05107 6.97411 6.10215 7.0601 6.17741L12.0018 11.1289L16.9517 6.17741C17.0699 6.05914 17.215 6 17.387 6C17.559 6 17.7041 6.05914 17.8223 6.17741C17.9459 6.29569 18.005 6.44354 17.9997 6.62095C17.9997 6.79299 17.9405 6.93546 17.8223 7.04836L12.8725 11.9998L17.8223 16.9513C17.9405 17.0642 17.9997 17.2067 17.9997 17.3787C17.9997 17.5508 17.9405 17.6986 17.8223 17.8222C17.7041 17.9459 17.559 18.005 17.387 17.9997C17.215 17.9997 17.0699 17.9405 16.9517 17.8222L12.0018 12.8708L7.0601 17.8222C6.97411 17.9029 6.88006 17.954 6.77794 17.9755C6.67583 18.0024 6.57103 18.0024 6.46354 17.9755C6.35605 17.954 6.26469 17.9029 6.18945 17.8222Z"
              })
            })
          }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)(HeaderButton, {
            title: "Minimize errors",
            onPress: props.isDismissable ? props.onMinimize : undefined,
            children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)("svg", {
              width: "24",
              height: "24",
              viewBox: "0 0 24 24",
              fill: "var(--expo-log-secondary-label)",
              xmlns: "http://www.w3.org/2000/svg",
              children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)("path", {
                d: "M5 11.5C5 11.2239 5.22386 11 5.5 11H18.5C18.7761 11 19 11.2239 19 11.5V11.5C19 11.7761 18.7761 12 18.5 12H5.5C5.22386 12 5 11.7761 5 11.5V11.5Z"
              })
            })
          })]
        }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("div", {
          className: styles.default.divider
        }), /*#__PURE__*/(0, _reactJsxRuntime.jsxs)("div", {
          className: styles.default.navGroup,
          children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)(HeaderButton, {
            title: "Previous error",
            disabled: total <= 1,
            onPress: () => props.onSelectIndex(selectedIndex - 1 < 0 ? total - 1 : selectedIndex - 1),
            children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(ChevronIcon, {
              left: true
            })
          }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("span", {
            style: {
              fontSize: 16,
              fontFamily: 'var(--expo-log-font-mono)',
              color: 'var(--expo-log-secondary-label)'
            },
            children: titleText
          }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)(HeaderButton, {
            title: "Next error",
            disabled: total <= 1,
            onPress: () => props.onSelectIndex((selectedIndex + 1) % total),
            children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(ChevronIcon, {})
          })]
        })]
      }), /*#__PURE__*/(0, _reactJsxRuntime.jsxs)("div", {
        className: styles.default.headerControls,
        children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)(HeaderButton, {
          title: "Copy error",
          onPress: () => props.onCopy(),
          children: /*#__PURE__*/(0, _reactJsxRuntime.jsxs)("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            width: "16",
            height: "16",
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "#98989F",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)("rect", {
              width: "8",
              height: "4",
              x: "8",
              y: "2",
              rx: "1",
              ry: "1"
            }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("path", {
              d: "M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2"
            }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("path", {
              d: "M16 4h2a2 2 0 0 1 2 2v4"
            }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("path", {
              d: "M21 14H11"
            }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("path", {
              d: "m15 10-4 4 4 4"
            })]
          })
        }), /*#__PURE__*/(0, _reactJsxRuntime.jsxs)("div", {
          className: styles.default.sdkBadge,
          style: {
            borderColor: isUNVERSIONED ? 'var(--expo-log-secondary-label)' : undefined
          },
          children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)("svg", {
            className: styles.default.sdkIcon,
            fill: "white",
            viewBox: "0 0 24 24",
            xmlns: "http://www.w3.org/2000/svg",
            children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)("path", {
              d: "M0 20.084c.043.53.23 1.063.718 1.778.58.849 1.576 1.315 2.303.567.49-.505 5.794-9.776 8.35-13.29a.761.761 0 011.248 0c2.556 3.514 7.86 12.785 8.35 13.29.727.748 1.723.282 2.303-.567.57-.835.728-1.42.728-2.046 0-.426-8.26-15.798-9.092-17.078-.8-1.23-1.044-1.498-2.397-1.542h-1.032c-1.353.044-1.597.311-2.398 1.542C8.267 3.991.33 18.758 0 19.77Z"
            })
          }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("span", {
            className: styles.default.sdkText,
            children: isUNVERSIONED ? `Debug` : `Expo ${sdkVersion}`
          })]
        })]
      })]
    });
  }
  function ChevronIcon({
    left
  }) {
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)("svg", {
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "var(--expo-log-secondary-label)",
      xmlns: "http://www.w3.org/2000/svg",
      children: left ? /*#__PURE__*/(0, _reactJsxRuntime.jsx)("path", {
        d: "M7 11.5C7 11.6053 7.01978 11.7014 7.05934 11.7881C7.0989 11.8748 7.16154 11.9554 7.24725 12.0297L14.6846 18.7955C14.8297 18.9318 15.011 19 15.2286 19C15.3736 19 15.5055 18.969 15.6242 18.9071C15.7363 18.8513 15.8286 18.7677 15.9011 18.6561C15.967 18.5446 16 18.4207 16 18.2844C16 18.0861 15.9275 17.9157 15.7824 17.7732L8.87912 11.5L15.7824 5.23606C15.9275 5.08736 16 4.91698 16 4.72491C16 4.5824 15.967 4.45849 15.9011 4.35316C15.8286 4.24164 15.7363 4.15489 15.6242 4.09294C15.5055 4.03098 15.3736 4 15.2286 4C15.011 4 14.8297 4.07125 14.6846 4.21375L7.24725 10.9796C7.16154 11.0539 7.0989 11.1344 7.05934 11.2212C7.01978 11.3079 7 11.4009 7 11.5Z"
      }) : /*#__PURE__*/(0, _reactJsxRuntime.jsx)("path", {
        d: "M17 11.5C17 11.6053 16.9802 11.7014 16.9407 11.7881C16.9011 11.8748 16.8385 11.9554 16.7527 12.0297L9.31538 18.7955C9.17033 18.9318 8.98901 19 8.77143 19C8.62637 19 8.49451 18.969 8.37582 18.9071C8.26374 18.8513 8.17143 18.7677 8.0989 18.6561C8.03297 18.5446 8 18.4207 8 18.2844C8 18.0861 8.07253 17.9157 8.21758 17.7732L15.1209 11.5L8.21758 5.23606C8.07253 5.08736 8 4.91698 8 4.72491C8 4.5824 8.03297 4.45849 8.0989 4.35316C8.17143 4.24164 8.26374 4.15489 8.37582 4.09294C8.49451 4.03098 8.62637 4 8.77143 4C8.98901 4 9.17033 4.07125 9.31538 4.21375L16.7527 10.9796C16.8385 11.0539 16.9011 11.1344 16.9407 11.2212C16.9802 11.3079 17 11.4009 17 11.5Z"
      })
    });
  }
  function HeaderButton(props) {
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)("button", {
      title: props.title,
      className: styles.default.pageButton,
      "aria-disabled": !props.onPress || props.disabled ? true : undefined,
      onClick: props.disabled ? undefined : props.onPress,
      children: props.children
    });
  }
},329,[306,35,330,323]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = Object.assign({
    "sdkText": "NbeUQq_sdkText",
    "sdkBadge": "NbeUQq_sdkBadge",
    "pageButton": "NbeUQq_pageButton",
    "divider": "NbeUQq_divider",
    "leftGroup": "NbeUQq_leftGroup",
    "container": "NbeUQq_container",
    "navGroup": "NbeUQq_navGroup",
    "sdkIcon": "NbeUQq_sdkIcon",
    "headerControls": "NbeUQq_headerControls"
  }, {
    unstable_styles: {
      "sdkText": {
        "$$css": true,
        "_": "NbeUQq_sdkText"
      },
      "sdkBadge": {
        "$$css": true,
        "_": "NbeUQq_sdkBadge"
      },
      "pageButton": {
        "$$css": true,
        "_": "NbeUQq_pageButton"
      },
      "divider": {
        "$$css": true,
        "_": "NbeUQq_divider"
      },
      "leftGroup": {
        "$$css": true,
        "_": "NbeUQq_leftGroup"
      },
      "container": {
        "$$css": true,
        "_": "NbeUQq_container"
      },
      "navGroup": {
        "$$css": true,
        "_": "NbeUQq_navGroup"
      },
      "sdkIcon": {
        "$$css": true,
        "_": "NbeUQq_sdkIcon"
      },
      "headerControls": {
        "$$css": true,
        "_": "NbeUQq_headerControls"
      }
    }
  }, {});
},330,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.StackTraceList = StackTraceList;
  var _react = require(_dependencyMap[0]);
  var React = _interopDefault(_react);
  var _reactNativeWebDistExportsPressable = require(_dependencyMap[1]);
  var Pressable = _interopDefault(_reactNativeWebDistExportsPressable);
  var _devServerEndpoints = require(_dependencyMap[2]);
  var _LogBoxInspectorSourceMapStatus = require(_dependencyMap[3]);
  var _StackTraceListModuleCss = require(_dependencyMap[4]);
  var styles = _interopDefault(_StackTraceListModuleCss);
  var _reactJsxRuntime = require(_dependencyMap[5]);
  /**
   * Copyright (c) 650 Industries.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  // @ts-ignore

  function Transition({
    children,
    status,
    onExitComplete,
    isInitial,
    index,
    initialDelay = 50
  }) {
    const ref = React.default.useRef(null);
    React.default.useLayoutEffect(() => {
      const element = ref.current;
      if (!element) return;
      if (isInitial && status === 'stable') {
        element.style.height = '0px';
        element.style.opacity = '0';
        setTimeout(() => {
          element.style.height = `${element.scrollHeight}px`;
          element.style.opacity = '1';
        }, index * initialDelay);
      } else if (status === 'entering') {
        element.style.height = '0px';
        element.style.opacity = '0';
        requestAnimationFrame(() => {
          element.style.height = `${element.scrollHeight}px`;
          element.style.opacity = '1';
        });
      } else if (status === 'exiting') {
        element.style.height = `${element.scrollHeight}px`;
        element.style.opacity = '1';
        requestAnimationFrame(() => {
          element.style.height = '0px';
          element.style.opacity = '0';
        });
      } else if (status === 'stable') {
        element.style.height = `${element.scrollHeight}px`;
        element.style.opacity = '1';
      }
    }, [status, isInitial, index]);
    React.default.useEffect(() => {
      if (status === 'exiting') {
        const handleTransitionEnd = e => {
          if (e.propertyName === 'height') {
            onExitComplete();
          }
        };
        ref.current?.addEventListener('transitionend', handleTransitionEnd);
        return () => {
          ref.current?.removeEventListener('transitionend', handleTransitionEnd);
        };
      }
      return undefined;
    }, [status, onExitComplete]);
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)("div", {
      ref: ref,
      style: {
        overflow: 'hidden',
        transition: 'height 0.3s ease, opacity 0.3s ease'
      },
      children: children
    });
  }
  function List({
    items,
    showCollapsed,
    isInitial,
    initialDelay
  }) {
    const [displayItems, setDisplayItems] = React.default.useState(items.filter(item => !item.isCollapsed).map(item => ({
      item,
      status: 'stable'
    })));
    React.default.useEffect(() => {
      const visibleItems = showCollapsed ? items : items.filter(item => !item.isCollapsed);

      // @ts-ignore TODO: fix types
      setDisplayItems(prev => {
        const prevIds = new Set(prev.map(d => d.item.id));
        const newItems = visibleItems.filter(item => !prevIds.has(item.id)).map(item => ({
          item,
          status: 'entering'
        }));
        const updatedPrev = prev.map(d => {
          if (!visibleItems.some(item => item.id === d.item.id)) {
            return Object.assign({}, d, {
              status: 'exiting'
            });
          }
          return d;
        });
        return [...updatedPrev, ...newItems];
      });
    }, [showCollapsed, items]);
    const onExitComplete = id => {
      setDisplayItems(prev => prev.filter(d => d.item.id !== id));
    };
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)("div", {
      children: displayItems.map((d, index) => /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Transition, {
        status: d.status,
        onExitComplete: () => onExitComplete(d.item.id),
        isInitial: isInitial,
        initialDelay: initialDelay,
        index: index,
        children: d.item.content
      }, d.item.id))
    });
  }
  function useContainerWidth() {
    const [width, setWidth] = (0, _react.useState)(0);
    const ref = React.default.useRef(null);
    React.default.useLayoutEffect(() => {
      if (ref.current) {
        setWidth(ref.current.clientWidth);
        const handleResize = () => {
          if (ref.current) {
            setWidth(ref.current.clientWidth);
          }
        };
        window.addEventListener('resize', handleResize);
        return () => {
          window.removeEventListener('resize', handleResize);
        };
      }
      return undefined;
    }, [ref]);
    return {
      width,
      ref
    };
  }
  function StackTraceList({
    onRetry,
    type,
    stack,
    symbolicationStatus,
    projectRoot
  }) {
    const [collapsed, setCollapsed] = (0, _react.useState)(true);
    // const [collapsed, setCollapsed] = useState(() => {
    //   // Only collapse frames initially if some frames are not collapsed.
    //   return stack?.some(({ collapse }) => !collapse);
    // });

    const stackCount = stack?.length;
    const [isInitial, setIsInitial] = React.default.useState(true);
    const initialDelay = 50;
    const initialTimer = React.default.useRef(null);
    React.default.useEffect(() => {
      if (isInitial) {
        const visibleCount = stack?.filter(frame => !frame.collapse).length ?? 0;
        initialTimer.current = setTimeout(() => setIsInitial(false), visibleCount * initialDelay + 500);
      }
      return () => {
        if (initialTimer.current) {
          clearTimeout(initialTimer.current);
          initialTimer.current = null;
        }
      };
    }, [isInitial]);
    const {
      width: containerWidth,
      ref
    } = useContainerWidth();
    if (!stackCount) {
      return null;
    }
    const collapseTitle = getCollapseMessage(stack, !!collapsed);
    return /*#__PURE__*/(0, _reactJsxRuntime.jsxs)("div", {
      style: {
        marginTop: 5,
        display: 'flex',
        flexDirection: 'column',
        gap: 6
      },
      children: [/*#__PURE__*/(0, _reactJsxRuntime.jsxs)("div", {
        ref: ref,
        style: {
          display: 'flex',
          alignItems: 'center',
          marginBottom: 4,
          justifyContent: 'space-between'
        },
        children: [/*#__PURE__*/(0, _reactJsxRuntime.jsxs)("div", {
          style: {
            display: 'flex',
            gap: 8,
            alignItems: 'center'
          },
          children: [type === 'component' ? /*#__PURE__*/(0, _reactJsxRuntime.jsx)(ReactIcon, {
            stroke: "unset",
            style: {
              width: '1rem',
              height: '1rem',
              color: 'var(--expo-log-color-label)'
            }
          }) : /*#__PURE__*/(0, _reactJsxRuntime.jsx)(JavaScriptIcon, {
            style: {
              width: '1rem',
              height: '1rem',
              color: 'var(--expo-log-color-label)'
            }
          }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("h3", {
            style: {
              fontFamily: 'var(--expo-log-font-family)',
              color: 'var(--expo-log-color-label)',
              fontSize: 18,
              fontWeight: '600',
              margin: 0
            },
            children: type === 'component' ? 'Component Stack' : 'Call Stack'
          }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("span", {
            "data-text": true,
            style: {
              backgroundColor: 'rgba(234.6, 234.6, 244.8, 0.1)',
              fontFamily: 'var(--expo-log-font-family)',
              color: 'var(--expo-log-color-label)',
              borderRadius: 50,
              fontSize: 12,
              aspectRatio: '1/1',
              display: 'flex',
              width: 22,
              height: 22,
              justifyContent: 'center',
              alignItems: 'center'
            },
            children: stackCount
          }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_LogBoxInspectorSourceMapStatus.LogBoxInspectorSourceMapStatus, {
            onPress: symbolicationStatus === 'FAILED' ? onRetry : null,
            status: symbolicationStatus
          })]
        }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Pressable.default, {
          onPress: () => setCollapsed(!collapsed),
          children: ({
            //@ts-expect-error fix rn-web typings
            hovered
          }) => /*#__PURE__*/(0, _reactJsxRuntime.jsxs)("div", {
            title: collapseTitle.full,
            style: {
              padding: 6,
              borderRadius: 8,
              transition: 'background-color 0.3s',
              outlineColor: 'transparent',
              backgroundColor: hovered ? 'rgba(234.6, 234.6, 244.8, 0.1)' : undefined,
              color: 'rgba(234.6, 234.6, 244.8, 0.6)',
              display: 'flex',
              justifyContent: 'center',
              alignItems: 'center',
              gap: 2,
              userSelect: 'none',
              cursor: 'pointer'
            },
            children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)("span", {
              className: styles.default.collapseTitle,
              style: {
                fontFamily: 'var(--expo-log-font-family)',
                fontSize: 14,
                userSelect: 'none',
                color: 'rgba(234.6, 234.6, 244.8, 0.6)'
              },
              children: containerWidth > 440 ? collapseTitle.full : collapseTitle.short
            }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("svg", {
              xmlns: "http://www.w3.org/2000/svg",
              width: "18",
              height: "18",
              viewBox: "0 0 24 24",
              fill: "none",
              stroke: "currentColor",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round",
              className: "md-hidden",
              children: collapsed ? /*#__PURE__*/(0, _reactJsxRuntime.jsxs)(_reactJsxRuntime.Fragment, {
                children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)("path", {
                  d: "m7 15 5 5 5-5"
                }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("path", {
                  d: "m7 9 5-5 5 5"
                })]
              }) : /*#__PURE__*/(0, _reactJsxRuntime.jsxs)(_reactJsxRuntime.Fragment, {
                children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)("path", {
                  d: "m7 20 5-5 5 5"
                }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("path", {
                  d: "m7 4 5 5 5-5"
                })]
              })
            })]
          })
        })]
      }), symbolicationStatus !== 'COMPLETE' && /*#__PURE__*/(0, _reactJsxRuntime.jsx)("div", {
        style: {
          backgroundColor: `var(--expo-log-secondary-system-background)`,
          border: `1px solid var(--expo-log-color-border)`,
          padding: `10px 15px`,
          borderRadius: 5
        },
        children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)("span", {
          style: {
            fontFamily: 'var(--expo-log-font-family)',
            color: 'var(--expo-log-color-label)',
            opacity: 0.7,
            fontSize: 13,
            fontWeight: '400'
          },
          children: "This call stack is not symbolicated. Some features are unavailable such as viewing the function name or tapping to open files."
        })
      }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("div", {
        style: {
          display: 'flex',
          flexDirection: 'column',
          gap: 2
        },
        children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(List, {
          initialDelay: initialDelay
          // @ts-ignore TODO: fix types
          ,
          items: stack.map((frame, index) => {
            const {
              file,
              lineNumber
            } = frame;
            const isLaunchable = !(0, _devServerEndpoints.isStackFileAnonymous)(frame) && symbolicationStatus === 'COMPLETE' && file != null && lineNumber != null;
            return {
              id: String(index),
              content: /*#__PURE__*/(0, _reactJsxRuntime.jsx)(StackTraceItem, {
                isLaunchable: isLaunchable,
                projectRoot: projectRoot,
                frame: frame,
                onPress: isLaunchable ? () => (0, _devServerEndpoints.openFileInEditor)(file, lineNumber) : undefined
              }, index),
              isCollapsed: !!frame.collapse
            };
          }),
          showCollapsed: !collapsed,
          isInitial: isInitial
        })
      })]
    });
  }
  function StackTraceItem({
    frame,
    onPress,
    projectRoot,
    isLaunchable
  }) {
    const fileName = (0, _devServerEndpoints.getStackFormattedLocation)(projectRoot, frame);
    return /*#__PURE__*/(0, _reactJsxRuntime.jsxs)("div", {
      "aria-disabled": !isLaunchable ? true : undefined,
      onClick: onPress,
      className: styles.default.stackFrame,
      style: {
        opacity: frame.collapse === true ? 0.4 : 1
      },
      children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)("code", {
        className: styles.default.stackFrameTitle,
        children: frame.methodName
      }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)("code", {
        className: styles.default.stackFrameFile,
        children: fileName
      })]
    });
  }
  const ReactIcon = props => /*#__PURE__*/(0, _reactJsxRuntime.jsx)("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor"
  }, props, {
    children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)("path", {
      d: "M14.23 12.004a2.236 2.236 0 0 1-2.235 2.236 2.236 2.236 0 0 1-2.236-2.236 2.236 2.236 0 0 1 2.235-2.236 2.236 2.236 0 0 1 2.236 2.236zm2.648-10.69c-1.346 0-3.107.96-4.888 2.622-1.78-1.653-3.542-2.602-4.887-2.602-.41 0-.783.093-1.106.278-1.375.793-1.683 3.264-.973 6.365C1.98 8.917 0 10.42 0 12.004c0 1.59 1.99 3.097 5.043 4.03-.704 3.113-.39 5.588.988 6.38.32.187.69.275 1.102.275 1.345 0 3.107-.96 4.888-2.624 1.78 1.654 3.542 2.603 4.887 2.603.41 0 .783-.09 1.106-.275 1.374-.792 1.683-3.263.973-6.365C22.02 15.096 24 13.59 24 12.004c0-1.59-1.99-3.097-5.043-4.032.704-3.11.39-5.587-.988-6.38a2.167 2.167 0 0 0-1.092-.278zm-.005 1.09v.006c.225 0 .406.044.558.127.666.382.955 1.835.73 3.704-.054.46-.142.945-.25 1.44a23.476 23.476 0 0 0-3.107-.534A23.892 23.892 0 0 0 12.769 4.7c1.592-1.48 3.087-2.292 4.105-2.295zm-9.77.02c1.012 0 2.514.808 4.11 2.28-.686.72-1.37 1.537-2.02 2.442a22.73 22.73 0 0 0-3.113.538 15.02 15.02 0 0 1-.254-1.42c-.23-1.868.054-3.32.714-3.707.19-.09.4-.127.563-.132zm4.882 3.05c.455.468.91.992 1.36 1.564-.44-.02-.89-.034-1.345-.034-.46 0-.915.01-1.36.034.44-.572.895-1.096 1.345-1.565zM12 8.1c.74 0 1.477.034 2.202.093.406.582.802 1.203 1.183 1.86.372.64.71 1.29 1.018 1.946-.308.655-.646 1.31-1.013 1.95-.38.66-.773 1.288-1.18 1.87a25.64 25.64 0 0 1-4.412.005 26.64 26.64 0 0 1-1.183-1.86c-.372-.64-.71-1.29-1.018-1.946a25.17 25.17 0 0 1 1.013-1.954c.38-.66.773-1.286 1.18-1.868A25.245 25.245 0 0 1 12 8.098zm-3.635.254c-.24.377-.48.763-.704 1.16-.225.39-.435.782-.635 1.174-.265-.656-.49-1.31-.676-1.947.64-.15 1.315-.283 2.015-.386zm7.26 0c.695.103 1.365.23 2.006.387-.18.632-.405 1.282-.66 1.933a25.952 25.952 0 0 0-1.345-2.32zm3.063.675c.484.15.944.317 1.375.498 1.732.74 2.852 1.708 2.852 2.476-.005.768-1.125 1.74-2.857 2.475-.42.18-.88.342-1.355.493a23.966 23.966 0 0 0-1.1-2.98c.45-1.017.81-2.01 1.085-2.964zm-13.395.004c.278.96.645 1.957 1.1 2.98a23.142 23.142 0 0 0-1.086 2.964c-.484-.15-.944-.318-1.37-.5-1.732-.737-2.852-1.706-2.852-2.474 0-.768 1.12-1.742 2.852-2.476.42-.18.88-.342 1.356-.494zm11.678 4.28c.265.657.49 1.312.676 1.948-.64.157-1.316.29-2.016.39a25.819 25.819 0 0 0 1.341-2.338zm-9.945.02c.2.392.41.783.64 1.175.23.39.465.772.705 1.143a22.005 22.005 0 0 1-2.006-.386c.18-.63.406-1.282.66-1.933zM17.92 16.32c.112.493.2.968.254 1.423.23 1.868-.054 3.32-.714 3.708-.147.09-.338.128-.563.128-1.012 0-2.514-.807-4.11-2.28.686-.72 1.37-1.536 2.02-2.44 1.107-.118 2.154-.3 3.113-.54zm-11.83.01c.96.234 2.006.415 3.107.532.66.905 1.345 1.727 2.035 2.446-1.595 1.483-3.092 2.295-4.11 2.295a1.185 1.185 0 0 1-.553-.132c-.666-.38-.955-1.834-.73-3.703.054-.46.142-.944.25-1.438zm4.56.64c.44.02.89.034 1.345.034.46 0 .915-.01 1.36-.034-.44.572-.895 1.095-1.345 1.565-.455-.47-.91-.993-1.36-1.565z"
    })
  }));
  const JavaScriptIcon = props => /*#__PURE__*/(0, _reactJsxRuntime.jsx)("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor"
  }, props, {
    children: /*#__PURE__*/(0, _reactJsxRuntime.jsx)("path", {
      d: "M0 0h24v24H0V0zm22.034 18.276c-.175-1.095-.888-2.015-3.003-2.873-.736-.345-1.554-.585-1.797-1.14-.091-.33-.105-.51-.046-.705.15-.646.915-.84 1.515-.66.39.12.75.42.976.9 1.034-.676 1.034-.676 1.755-1.125-.27-.42-.404-.601-.586-.78-.63-.705-1.469-1.065-2.834-1.034l-.705.089c-.676.165-1.32.525-1.71 1.005-1.14 1.291-.811 3.541.569 4.471 1.365 1.02 3.361 1.244 3.616 2.205.24 1.17-.87 1.545-1.966 1.41-.811-.18-1.26-.586-1.755-1.336l-1.83 1.051c.21.48.45.689.81 1.109 1.74 1.756 6.09 1.666 6.871-1.004.029-.09.24-.705.074-1.65l.046.067zm-8.983-7.245h-2.248c0 1.938-.009 3.864-.009 5.805 0 1.232.063 2.363-.138 2.711-.33.689-1.18.601-1.566.48-.396-.196-.597-.466-.83-.855-.063-.105-.11-.196-.127-.196l-1.825 1.125c.305.63.75 1.172 1.324 1.517.855.51 2.004.675 3.207.405.783-.226 1.458-.691 1.811-1.411.51-.93.402-2.07.397-3.346.012-2.054 0-4.109 0-6.179l.004-.056z"
    })
  }));
  function getCollapseMessage(stackFrames, collapsed) {
    if (stackFrames.length === 0) {
      return {
        full: 'No frames to show',
        short: 'No frames'
      };
    }
    const collapsedCount = stackFrames.reduce((count, {
      collapse
    }) => {
      if (collapse === true) {
        return count + 1;
      }
      return count;
    }, 0);
    if (collapsedCount === 0) {
      return {
        full: 'Showing all frames',
        short: 'Show all'
      };
    }
    const short = collapsed ? 'Show' : 'Hide';
    const framePlural = `frame${collapsedCount > 1 ? 's' : ''}`;
    if (collapsedCount === stackFrames.length) {
      return {
        full: `${short}${collapsedCount > 1 ? ' all ' : ' '}${collapsedCount} ignore-listed ${framePlural}`,
        short
      };
    } else {
      // Match the chrome inspector wording
      return {
        full: `${short} ${collapsedCount} ignored-listed ${framePlural}`,
        short
      };
    }
  }
},331,[35,267,317,332,335,323]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  'use client';
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  function _interopDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  exports.LogBoxInspectorSourceMapStatus = LogBoxInspectorSourceMapStatus;
  var _react = require(_dependencyMap[0]);
  var _reactNativeWebDistExportsAnimated = require(_dependencyMap[1]);
  var Animated = _interopDefault(_reactNativeWebDistExportsAnimated);
  var _reactNativeWebDistExportsEasing = require(_dependencyMap[2]);
  var Easing = _interopDefault(_reactNativeWebDistExportsEasing);
  var _reactNativeWebDistExportsStyleSheet = require(_dependencyMap[3]);
  var StyleSheet = _interopDefault(_reactNativeWebDistExportsStyleSheet);
  var _reactNativeWebDistExportsText = require(_dependencyMap[4]);
  var Text = _interopDefault(_reactNativeWebDistExportsText);
  require(_dependencyMap[5]);
  var _reactNativeWebDistExportsPressable = require(_dependencyMap[6]);
  var Pressable = _interopDefault(_reactNativeWebDistExportsPressable);
  var _reactNativeWebDistExportsView = require(_dependencyMap[7]);
  var View = _interopDefault(_reactNativeWebDistExportsView);
  var _reactJsxRuntime = require(_dependencyMap[8]);
  function getBackgroundColor(opacity) {
    return `rgba(51, 51, 51, ${opacity == null ? 1 : opacity})`;
  }
  function getTextColor(opacity) {
    return `rgba(255, 255, 255, ${opacity == null ? 1 : opacity})`;
  }
  function LogBoxButton(props) {
    const [pressed, setPressed] = (0, _react.useState)(false);
    let backgroundColor = props.backgroundColor;
    if (!backgroundColor) {
      backgroundColor = {
        default: getBackgroundColor(0.95),
        pressed: getBackgroundColor(0.6)
      };
    }
    const content = /*#__PURE__*/(0, _reactJsxRuntime.jsx)(View.default, {
      style: [Object.assign({
        backgroundColor: pressed ? backgroundColor.pressed : backgroundColor.default
      }, {
        cursor: 'pointer'
      }), props.style],
      children: props.children
    });
    return props.onPress == null ? content : /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Pressable.default, {
      hitSlop: props.hitSlop,
      onPress: props.onPress,
      onPressIn: () => setPressed(true),
      onPressOut: () => setPressed(false),
      children: content
    });
  }
  function LogBoxInspectorSourceMapStatus(props) {
    const [state, setState] = (0, _react.useState)({
      animation: null,
      rotate: null
    });
    (0, _react.useEffect)(() => {
      if (props.status === 'PENDING') {
        if (state.animation == null) {
          const animated = new Animated.default.Value(0);
          const animation = Animated.default.loop(Animated.default.timing(animated, {
            duration: 2000,
            easing: Easing.default.linear,
            toValue: 1,
            useNativeDriver: true
          }), {
            iterations: -1
          });
          setState({
            animation,
            rotate: animated.interpolate({
              inputRange: [0, 1],
              outputRange: ['0deg', '360deg']
            })
          });
          animation.start();
        }
      } else {
        if (state.animation != null) {
          state.animation.stop();
          setState({
            animation: null,
            rotate: null
          });
        }
      }
      return () => {
        if (state.animation != null) {
          state.animation.stop();
        }
      };
    }, [props.status, state.animation]);
    let image;
    let color;
    switch (props.status) {
      case 'FAILED':
        image = require(_dependencyMap[9]);
        color = `rgba(243, 83, 105, 1)`;
        break;
      case 'PENDING':
        image = require(_dependencyMap[10]);
        color = `rgba(250, 186, 48, 1)`;
        break;
    }
    if (props.status === 'COMPLETE' || image == null) {
      return null;
    }
    return /*#__PURE__*/(0, _reactJsxRuntime.jsxs)(LogBoxButton, {
      backgroundColor: {
        default: 'transparent',
        pressed: getBackgroundColor(1)
      },
      hitSlop: {
        bottom: 8,
        left: 8,
        right: 8,
        top: 8
      },
      onPress: props.onPress,
      style: styles.root,
      children: [/*#__PURE__*/(0, _reactJsxRuntime.jsx)(Animated.default.Image, {
        source: image,
        tintColor: color ?? getTextColor(0.4),
        style: [styles.image, state.rotate == null || props.status !== 'PENDING' ? null : {
          transform: [{
            rotate: state.rotate
          }]
        }]
      }), /*#__PURE__*/(0, _reactJsxRuntime.jsx)(Text.default, {
        style: [styles.text, {
          color
        }],
        children: "Source Map"
      })]
    });
  }
  const styles = StyleSheet.default.create({
    root: {
      alignItems: 'center',
      borderRadius: 12,
      flexDirection: 'row',
      height: 24,
      paddingHorizontal: 8
    },
    image: {
      height: 14,
      width: 16,
      marginEnd: 4
    },
    text: {
      fontSize: 12,
      includeFontPadding: false,
      lineHeight: 16
    }
  });
},332,[35,133,234,43,216,96,267,138,323,333,334]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "./assets/_metro-runtime/assets/alert-triangle.4f355ba1efca4b9c0e7a6271af047f61.png",
    width: 48,
    height: 42
  };
},333,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = {
    uri: "./assets/_metro-runtime/assets/loader.817aca47ff3cea63020753d336e628a4.png",
    width: 44,
    height: 44
  };
},334,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = Object.assign({
    "stackFrameTitle": "LSZLAG_stackFrameTitle",
    "collapseTitle": "LSZLAG_collapseTitle",
    "stackFrameFile": "LSZLAG_stackFrameFile",
    "stackFrame": "LSZLAG_stackFrame"
  }, {
    unstable_styles: {
      "stackFrameTitle": {
        "$$css": true,
        "_": "LSZLAG_stackFrameTitle"
      },
      "collapseTitle": {
        "$$css": true,
        "_": "LSZLAG_collapseTitle"
      },
      "stackFrameFile": {
        "$$css": true,
        "_": "LSZLAG_stackFrameFile"
      },
      "stackFrame": {
        "$$css": true,
        "_": "LSZLAG_stackFrame"
      }
    }
  }, {});
},335,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {},336,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  module.exports = Object.assign({
    "headerBlur": "aF6zBW_headerBlur",
    "fadeOut": "aF6zBW_fadeOut",
    "content": "aF6zBW_content",
    "overlay": "aF6zBW_overlay",
    "containerExit": "aF6zBW_containerExit",
    "bgExit": "aF6zBW_bgExit",
    "container": "aF6zBW_container",
    "scroll": "aF6zBW_scroll",
    "bg": "aF6zBW_bg",
    "data-expo-log-backdrop-fade-in": "aF6zBW_data-expo-log-backdrop-fade-in",
    "fadeInUp": "aF6zBW_fadeInUp",
    "fadeOutUp": "aF6zBW_fadeOutUp",
    "footer": "aF6zBW_footer"
  }, {
    unstable_styles: {
      "headerBlur": {
        "$$css": true,
        "_": "aF6zBW_headerBlur"
      },
      "fadeOut": {
        "$$css": true,
        "_": "aF6zBW_fadeOut"
      },
      "content": {
        "$$css": true,
        "_": "aF6zBW_content"
      },
      "overlay": {
        "$$css": true,
        "_": "aF6zBW_overlay"
      },
      "containerExit": {
        "$$css": true,
        "_": "aF6zBW_containerExit"
      },
      "bgExit": {
        "$$css": true,
        "_": "aF6zBW_bgExit"
      },
      "container": {
        "$$css": true,
        "_": "aF6zBW_container"
      },
      "scroll": {
        "$$css": true,
        "_": "aF6zBW_scroll"
      },
      "bg": {
        "$$css": true,
        "_": "aF6zBW_bg"
      },
      "data-expo-log-backdrop-fade-in": {
        "$$css": true,
        "_": "aF6zBW_data-expo-log-backdrop-fade-in"
      },
      "fadeInUp": {
        "$$css": true,
        "_": "aF6zBW_fadeInUp"
      },
      "fadeOutUp": {
        "$$css": true,
        "_": "aF6zBW_fadeOutUp"
      },
      "footer": {
        "$$css": true,
        "_": "aF6zBW_footer"
      }
    }
  }, {});
},337,[]);
__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  "use strict";

  Object.defineProperty(exports, '__esModule', {
    value: true
  });
  exports.LogBoxMessage = LogBoxMessage;
  require(_dependencyMap[0]);
  var _reactJsxRuntime = require(_dependencyMap[1]);
  /**
   * Copyright (c) 650 Industries.
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  const cleanContent = content => content;
  // const cleanContent = (content: string) =>
  //   content.replace(/^(TransformError |Warning: (Warning: )?|Error: )/g, '');

  function LogBoxMessage(props) {
    const {
      content,
      substitutions
    } = props.message;
    const maxLength = props.maxLength != null ? props.maxLength : Infinity;
    const substitutionStyle = {
      opacity: 0.6
    };
    const elements = [];
    let length = 0;
    const createUnderLength = (key, message, style) => {
      let cleanMessage = cleanContent(message);
      if (props.maxLength != null) {
        cleanMessage = cleanMessage.slice(0, props.maxLength - length);
      }
      if (length < maxLength) {
        elements.push(/*#__PURE__*/(0, _reactJsxRuntime.jsx)("span", {
          //@ts-expect-error
          style: style,
          children: cleanMessage
        }, key));
      }
      length += cleanMessage.length;
    };
    const lastOffset = substitutions.reduce((prevOffset, substitution, index) => {
      const key = String(index);
      if (substitution.offset > prevOffset) {
        const prevPart = content.substr(prevOffset, substitution.offset - prevOffset);
        createUnderLength(key, prevPart);
      }
      const substititionPart = content.substr(substitution.offset, substitution.length);
      createUnderLength(key + '.5', substititionPart, substitutionStyle);
      return substitution.offset + substitution.length;
    }, 0);
    if (lastOffset < content.length) {
      const lastPart = content.substr(lastOffset);
      createUnderLength('-1', lastPart);
    }
    return /*#__PURE__*/(0, _reactJsxRuntime.jsx)(_reactJsxRuntime.Fragment, {
      children: elements
    });
  }
},338,[35,323]);
__r(3);
__r(0);